/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  has: ReflectHas$LWS,
  get: ReflectGet$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  ownKeys: ReflectOwnKeys$LWS
} = Reflect;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  filter: ArrayProtoFilter$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  pop: ArrayProtoPop$LWS,
  shift: ArrayProtoShift$LWS,
  some: ArrayProtoSome$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
const {
  push: ArrayProtoPush$LWS,
  slice: ArrayProtoSlice$LWS
} = ArrayProto$LWS;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
  const {
    length: length$LWS
  } = args$LWS;

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];
    ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, ArrayIsArray$LWS(value$LWS) ? value$LWS : [value$LWS]);
  }

  return result$LWS;
}

function ArrayFilter$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoFilter$LWS, array$LWS, [iteratee$LWS]);
}

function ArrayIncludes$LWS(array$LWS, value$LWS) {
  return ReflectApply$LWS(ArrayProtoIncludes$LWS, array$LWS, [value$LWS]);
}

function ArrayIndexOf$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoIndexOf$LWS, array$LWS, args$LWS);
}

function ArrayJoin$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoJoin$LWS, array$LWS, args$LWS);
}

function ArrayPop$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoPop$LWS, array$LWS, []);
}

function ArrayShift$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoShift$LWS, array$LWS, []);
}

function ArraySlice$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, args$LWS);
}

function ArraySome$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoSome$LWS, array$LWS, [iteratee$LWS]);
}

function ArraySort$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSort$LWS, array$LWS, []);
}

function ArrayUnshift$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoUnshift$LWS, array$LWS, args$LWS);
}

const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  freeze: ObjectFreeze$LWS,
  getOwnPropertyNames: ObjectGetOwnPropertyNames$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupGetter__: ObjectProto__lookupGetter__$LWS,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupSetter__: ObjectProto__lookupSetter__$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

function ObjectHasOwnProperty$LWS(object$LWS, key$LWS) {
  return object$LWS !== null && object$LWS !== undefined && ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupGetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupSetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return object$LWS[key$LWS];
}

function ObjectToString$LWS(object$LWS) {
  return ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength');

function isArrayBuffer$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
    ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  return false;
} // https://caniuse.com/bigint


const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
const isBigIntObject$LWS = SUPPORTS_BIG_INT$LWS ? function isBigIntObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }

  return false;
} : function isBigIntObject$LWS(_value$LWS) {
  return false;
};
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;

function isBooleanObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.3.3 Properties of the Boolean Prototype Object
      // https://tc39.es/ecma262/#thisbooleanvalue
      // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
      //     a. Let b be value.[[BooleanData]].
      //     b. Assert: Type(b) is Boolean.
      ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused3$LWS) {}
  }

  return false;
}

function toBoolean$LWS(value$LWS) {
  return !!value$LWS;
}

const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const QUOTE_CHAR_DOUBLE$LWS = '"';
const QUOTE_CHAR_SINGLE$LWS = "'";
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_ERROR$LWS = '[object Error]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  now: DateNow$LWS
} = DateCtor$LWS;

function isDate$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.4.4 Properties of the Date Prototype Object
      // https://tc39.es/ecma262/#thistimevalue
      // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
      //     a. Return value.[[DateValue]].
      // Step 2: Throw a TypeError exception.
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
  }

  return false;
}

const {
  bind: FunctionProtoBind$LWS
} = Function.prototype;

const FunctionBind$LWS = (func$LWS, thisArg$LWS) => ReflectApply$LWS(FunctionProtoBind$LWS, func$LWS, [thisArg$LWS]);

function wrap$LWS(func$LWS, wrapper$LWS) {
  return function wrapped$LWS(...args$LWS) {
    return ReflectApply$LWS(wrapper$LWS, this, [func$LWS, args$LWS]);
  };
}

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  entries: MapProtoEntries$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');

function isMap$LWS(value$LWS) {
  try {
    // Section 24.1.3.10 get Map.prototype.size
    // https://tc39.es/ecma262/#sec-get-map.prototype.size
    // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
    ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused5$LWS) {}

  return false;
}

function MapClear$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoClear$LWS, map$LWS, []);
}

function MapEntries$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []);
}

function MapForEach$LWS(map$LWS, iteratee$LWS) {
  return ReflectApply$LWS(MapProtoForEach$LWS, map$LWS, [iteratee$LWS]);
}

function MapGet$LWS(map$LWS, key$LWS) {
  return ReflectApply$LWS(MapProtoGet$LWS, map$LWS, [key$LWS]);
}

function MapSet$LWS(map$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(MapProtoSet$LWS, map$LWS, [key$LWS, value$LWS]);
}

const NumberCtor$LWS = Number;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberCtor$LWS.prototype;
const {
  isFinite: NumberIsFinite$LWS
} = NumberCtor$LWS;

function isNumberObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.1.3 Properties of the Number Prototype Object
      // https://tc39.es/ecma262/#thisnumbervalue
      // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
      //     a. Let n be value.[[NumberData]].
      //     b. Assert: Type(n) is Number.
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused6$LWS) {}
  }

  return false;
}

function NumberToFixed$LWS(num$LWS, digits$LWS = 0) {
  return ReflectApply$LWS(NumberProtoToFixed$LWS, num$LWS, [digits$LWS]);
}

const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  charCodeAt: StringProtoCharCodeAt$LWS,
  includes: StringProtoIncludes$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const QUOTE_CHAR_REG_EXP_MAP$LWS = {
  __proto__: null,
  [QUOTE_CHAR_DOUBLE$LWS]: /\\?"/g,
  [QUOTE_CHAR_SINGLE$LWS]: /\\?'/g
};

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (!length$LWS) {
    return string$LWS;
  }

  const upper$LWS = StringToUpperCase$LWS(string$LWS[0]);
  return length$LWS === 1 ? upper$LWS : upper$LWS + StringSlice$LWS(string$LWS, 1);
}

function enquote$LWS(string$LWS, quoteChar$LWS = QUOTE_CHAR_SINGLE$LWS) {
  return quoteChar$LWS + escapeQuotes$LWS(string$LWS, quoteChar$LWS) + quoteChar$LWS;
}

function escapeQuotes$LWS(string$LWS, quoteChar$LWS = QUOTE_CHAR_SINGLE$LWS) {
  return string$LWS.replace(QUOTE_CHAR_REG_EXP_MAP$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`);
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused7$LWS) {}
  }

  return false;
}

function isStringObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 22.1.3 Properties of the String Prototype Object
      // https://tc39.es/ecma262/#thisstringvalue
      // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
      //     a. Let s be value.[[StringData]].
      //     b. Assert: Type(s) is String.
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
  }

  return false;
}

function StringCharCodeAt$LWS(string$LWS, index$LWS) {
  return ReflectApply$LWS(StringProtoCharCodeAt$LWS, string$LWS, [index$LWS]);
}

function StringIncludes$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoIncludes$LWS, string$LWS, args$LWS);
}

function StringMatch$LWS(string$LWS, regexp$LWS) {
  return ReflectApply$LWS(StringProtoMatch$LWS, string$LWS, [regexp$LWS]);
}

function StringReplace$LWS(string$LWS, pattern$LWS, replacement$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [pattern$LWS, replacement$LWS]);
}

function StringSlice$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, args$LWS);
}

function StringSplit$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSplit$LWS, string$LWS, args$LWS);
}

function StringStartsWith$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoStartsWith$LWS, string$LWS, args$LWS);
}

function StringToLowerCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToLowerCase$LWS, string$LWS, []);
}

function StringToUpperCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS, []);
}

function toString$LWS(value$LWS) {
  try {
    // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value
    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused9$LWS) {}

  return '';
}

function toStringIfNotNullOrUndefined$LWS(value$LWS) {
  return value$LWS === null || value$LWS === undefined ? value$LWS : toString$LWS(value$LWS);
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return StringReplace$LWS(string$LWS, specialCharRegExp$LWS, '\\$&');
}

function isRegExp$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (value$LWS !== RegExpProto$LWS) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return true;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {}

  return false;
}

function RegExpTest$LWS(regexp$LWS, content$LWS) {
  return ReflectApply$LWS(RegExpProtoTest$LWS, regexp$LWS, [toString$LWS(content$LWS)]);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  add: SetProtoAdd$LWS,
  delete: SetProtoDelete$LWS,
  has: SetProtoHas$LWS,
  values: SetProtoValue$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');

function isSet$LWS(value$LWS) {
  try {
    // Section 24.2.3.9 get Set.prototype.size
    // https://tc39.es/ecma262/#sec-get-set.prototype.size
    // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
    ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused11$LWS) {}

  return false;
}

function SetAdd$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoAdd$LWS, set$LWS, [value$LWS]);
}

function SetDelete$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoDelete$LWS, set$LWS, [value$LWS]);
}

function SetHas$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoHas$LWS, set$LWS, [value$LWS]);
}

function SetValues$LWS(set$LWS) {
  return ReflectApply$LWS(SetProtoValue$LWS, set$LWS, []);
}

const SymbolCtor$LWS = Symbol;
const {
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS
} = SymbolCtor$LWS;

function isSymbolObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.4.3 Properties of the Symbol Prototype Object
      // https://tc39.es/ecma262/#thissymbolvalue
      // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
      //     a. Let s be value.[[SymbolData]].
      //     b. Assert: Type(s) is Symbol.
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
  }

  return false;
}

const WeakMapCtor$LWS = WeakMap;
const {
  get: WeakMapProtoGet$LWS,
  has: WeakMapProtoHas$LWS,
  set: WeakMapProtoSet$LWS
} = WeakMapCtor$LWS.prototype;

function isWeakMap$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.3.3.4 WeakMap.prototype.has ( key )
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // Step 2: Perform ? RequireInternalSlot(M, [[WeakMapData]]).
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  return false;
}

function WeakMapGet$LWS(weakMap$LWS, key$LWS) {
  return ReflectApply$LWS(WeakMapProtoGet$LWS, weakMap$LWS, [key$LWS]);
}

function WeakMapSet$LWS(weakMap$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(WeakMapProtoSet$LWS, weakMap$LWS, [key$LWS, value$LWS]);
}

const {
  has: WeakSetProtoHas$LWS
} = WeakSet.prototype;

function isWeakSet$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.4.3.4 WeakSet.prototype.has ( value )
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      // Step 2: 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
  }

  return false;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol;

function getBrandByTrailAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  if (isDate$LWS(value$LWS)) {
    return TO_STRING_BRAND_DATE$LWS;
  }

  if (isMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_MAP$LWS;
  }

  if (isRegExp$LWS(value$LWS)) {
    return TO_STRING_BRAND_REG_EXP$LWS;
  }

  if (isSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_SET$LWS;
  }

  if (isWeakMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_MAP$LWS;
  }

  if (isWeakSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_SET$LWS;
  }

  if (isBigIntObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BIG_INT$LWS;
  }

  if (isBooleanObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BOOLEAN$LWS;
  }

  if (isNumberObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_NUMBER$LWS;
  }

  if (isStringObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_STRING$LWS;
  }

  if (isSymbolObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_SYMBOL$LWS;
  } // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return ReflectHas$LWS(value$LWS, TO_STRING_TAG_SYMBOL$LWS) ? getBrandByTrailAndError$LWS(value$LWS) : ObjectToString$LWS(value$LWS);
}

const getTimestamp$LWS = typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : FunctionBind$LWS(performance.now, performance);

function toSafeDescriptor$LWS(desc$LWS) {
  ReflectSetPrototypeOf$LWS(desc$LWS, null);
  return desc$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}

const ProxyCtor$LWS = Proxy;
const ProxyRevocable$LWS = Proxy.revocable;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}

function maskDistortion$LWS(distortedFunc$LWS, rawFunc$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(rawFunc$LWS, ObjectFreeze$LWS({
    apply(_target$LWS, thisArg$LWS, args$LWS) {
      if (thisArg$LWS === proxy$LWS) {
        thisArg$LWS = distortedFunc$LWS;
      }

      return ReflectApply$LWS(distortedFunc$LWS, thisArg$LWS, args$LWS);
    },

    construct(_target$LWS, args$LWS, newTarget$LWS) {
      if (newTarget$LWS === proxy$LWS) {
        newTarget$LWS = distortedFunc$LWS;
      }

      return ReflectConstruct$LWS(distortedFunc$LWS, args$LWS, newTarget$LWS);
    }

  }));
  return proxy$LWS;
}

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_LIVE_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerLiveValue'); // This is used by packages/locker-core-engine/src/LockerFilter.js

const SYMBOL_LIVE_OBJECT$LWS = LOCKER_LIVE_VALUE_SYMBOL$LWS;

function isLiveObject$LWS(value$LWS) {
  if (value$LWS === null || value$LWS === undefined || value$LWS === ObjectProto$LWS || !(typeof value$LWS === 'object' || typeof value$LWS === 'function')) {
    return false;
  } // Based on the isTargetLive() function of
  // salesforce/near-membrane/packages/near-membrane-base/src/membrane.ts.


  if (typeof value$LWS === 'object') {
    const {
      constructor: constructor$LWS
    } = value$LWS;

    if (constructor$LWS === ObjectCtor$LWS) {
      // If the constructor, own or inherited, points to `Object`
      // then `value` is not likely a prototype object.
      return true;
    }

    let result$LWS = false;

    if (ReflectGetPrototypeOf$LWS(value$LWS) === null) {
      // Ensure `value` is not an `Object.prototype` from an iframe.
      result$LWS = typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== value$LWS;
    }

    if (!result$LWS) {
      result$LWS = ArrayIsArray$LWS(value$LWS) || ArrayBufferIsView$LWS(value$LWS) || isArrayBuffer$LWS(value$LWS) || isRegExp$LWS(value$LWS);
    }

    if (result$LWS) {
      return result$LWS;
    }
  }

  return ObjectHasOwnProperty$LWS(value$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS);
}

function markLiveObject$LWS(target$LWS) {
  ReflectDefineProperty$LWS(target$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS, {
    __proto__: null,
    value: undefined
  });
  return target$LWS;
}

function toLiveValue$LWS(value$LWS) {
  if (isObjectLike$LWS(value$LWS)) {
    return isLiveObject$LWS(value$LWS) ? value$LWS : markLiveObject$LWS(value$LWS);
  }

  return value$LWS;
}

const MathMin$LWS = Math.min;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  return isObjectLike$LWS(value$LWS) && !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
}

const {
  then: PromiseProtoThen$LWS
} = Promise.prototype;
const PromiseReject$LWS = Promise.reject.bind(Promise);

function PromiseThen$LWS(promise$LWS, ...args$LWS) {
  return ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, args$LWS);
}

exports.ArrayBufferIsView = ArrayBufferIsView$LWS;
exports.ArrayConcat = ArrayConcat$LWS;
exports.ArrayCtor = ArrayCtor$LWS;
exports.ArrayFilter = ArrayFilter$LWS;
exports.ArrayIncludes = ArrayIncludes$LWS;
exports.ArrayIndexOf = ArrayIndexOf$LWS;
exports.ArrayIsArray = ArrayIsArray$LWS;
exports.ArrayJoin = ArrayJoin$LWS;
exports.ArrayPop = ArrayPop$LWS;
exports.ArrayProtoPush = ArrayProtoPush$LWS;
exports.ArrayProtoSlice = ArrayProtoSlice$LWS;
exports.ArrayShift = ArrayShift$LWS;
exports.ArraySlice = ArraySlice$LWS;
exports.ArraySome = ArraySome$LWS;
exports.ArraySort = ArraySort$LWS;
exports.ArrayUnshift = ArrayUnshift$LWS;
exports.DateNow = DateNow$LWS;
exports.FunctionBind = FunctionBind$LWS;
exports.JSONParse = JSONParse$LWS;
exports.JSONStringify = JSONStringify$LWS;
exports.LOCKER_IDENTIFIER_MARKER = LOCKER_IDENTIFIER_MARKER$LWS;
exports.LOCKER_UNMINIFIED_FLAG = LOCKER_UNMINIFIED_FLAG$LWS;
exports.LockerSecurityError = LockerSecurityError$LWS;
exports.MapClear = MapClear$LWS;
exports.MapCtor = MapCtor$LWS;
exports.MapEntries = MapEntries$LWS;
exports.MapForEach = MapForEach$LWS;
exports.MapGet = MapGet$LWS;
exports.MapSet = MapSet$LWS;
exports.MathMin = MathMin$LWS;
exports.NumberIsFinite = NumberIsFinite$LWS;
exports.NumberToFixed = NumberToFixed$LWS;
exports.ObjectAssign = ObjectAssign$LWS;
exports.ObjectCtor = ObjectCtor$LWS;
exports.ObjectFreeze = ObjectFreeze$LWS;
exports.ObjectGetOwnPropertyDescriptors = ObjectGetOwnPropertyDescriptors$LWS;
exports.ObjectGetOwnPropertyNames = ObjectGetOwnPropertyNames$LWS;
exports.ObjectGetOwnPropertySymbols = ObjectGetOwnPropertySymbols$LWS;
exports.ObjectHasOwnProperty = ObjectHasOwnProperty$LWS;
exports.ObjectKeys = ObjectKeys$LWS;
exports.ObjectLookupOwnGetter = ObjectLookupOwnGetter$LWS;
exports.ObjectLookupOwnSetter = ObjectLookupOwnSetter$LWS;
exports.ObjectLookupOwnValue = ObjectLookupOwnValue$LWS;
exports.ObjectPreventExtensions = ObjectPreventExtensions$LWS;
exports.ObjectProto = ObjectProto$LWS;
exports.ObjectToString = ObjectToString$LWS;
exports.PromiseReject = PromiseReject$LWS;
exports.PromiseThen = PromiseThen$LWS;
exports.ProxyCtor = ProxyCtor$LWS;
exports.ProxyRevocable = ProxyRevocable$LWS;
exports.QUOTE_CHAR_DOUBLE = QUOTE_CHAR_DOUBLE$LWS;
exports.QUOTE_CHAR_SINGLE = QUOTE_CHAR_SINGLE$LWS;
exports.ReflectApply = ReflectApply$LWS;
exports.ReflectConstruct = ReflectConstruct$LWS;
exports.ReflectDefineProperty = ReflectDefineProperty$LWS;
exports.ReflectDeleteProperty = ReflectDeleteProperty$LWS;
exports.ReflectGet = ReflectGet$LWS;
exports.ReflectGetOwnPropertyDescriptor = ReflectGetOwnPropertyDescriptor$LWS;
exports.ReflectGetPrototypeOf = ReflectGetPrototypeOf$LWS;
exports.ReflectHas = ReflectHas$LWS;
exports.ReflectOwnKeys = ReflectOwnKeys$LWS;
exports.ReflectSet = ReflectSet$LWS;
exports.ReflectSetPrototypeOf = ReflectSetPrototypeOf$LWS;
exports.RegExpCtor = RegExpCtor$LWS;
exports.RegExpTest = RegExpTest$LWS;
exports.SANDBOX_EVAL_CONTEXT_NAME = SANDBOX_EVAL_CONTEXT_NAME$LWS;
exports.SANDBOX_EVAL_HELPERS_NAME = SANDBOX_EVAL_HELPERS_NAME$LWS;
exports.SYMBOL_LIVE_OBJECT = SYMBOL_LIVE_OBJECT$LWS;
exports.SetAdd = SetAdd$LWS;
exports.SetCtor = SetCtor$LWS;
exports.SetDelete = SetDelete$LWS;
exports.SetHas = SetHas$LWS;
exports.SetValues = SetValues$LWS;
exports.StringCharCodeAt = StringCharCodeAt$LWS;
exports.StringCtor = StringCtor$LWS;
exports.StringIncludes = StringIncludes$LWS;
exports.StringMatch = StringMatch$LWS;
exports.StringReplace = StringReplace$LWS;
exports.StringSlice = StringSlice$LWS;
exports.StringSplit = StringSplit$LWS;
exports.StringStartsWith = StringStartsWith$LWS;
exports.StringToLowerCase = StringToLowerCase$LWS;
exports.StringToUpperCase = StringToUpperCase$LWS;
exports.SymbolFor = SymbolFor$LWS;
exports.SymbolIterator = SymbolIterator$LWS;
exports.TO_STRING_BRAND_ARRAY = TO_STRING_BRAND_ARRAY$LWS;
exports.TO_STRING_BRAND_BIG_INT = TO_STRING_BRAND_BIG_INT$LWS;
exports.TO_STRING_BRAND_BOOLEAN = TO_STRING_BRAND_BOOLEAN$LWS;
exports.TO_STRING_BRAND_DATE = TO_STRING_BRAND_DATE$LWS;
exports.TO_STRING_BRAND_ERROR = TO_STRING_BRAND_ERROR$LWS;
exports.TO_STRING_BRAND_FUNCTION = TO_STRING_BRAND_FUNCTION$LWS;
exports.TO_STRING_BRAND_MAP = TO_STRING_BRAND_MAP$LWS;
exports.TO_STRING_BRAND_NULL = TO_STRING_BRAND_NULL$LWS;
exports.TO_STRING_BRAND_NUMBER = TO_STRING_BRAND_NUMBER$LWS;
exports.TO_STRING_BRAND_OBJECT = TO_STRING_BRAND_OBJECT$LWS;
exports.TO_STRING_BRAND_REG_EXP = TO_STRING_BRAND_REG_EXP$LWS;
exports.TO_STRING_BRAND_SET = TO_STRING_BRAND_SET$LWS;
exports.TO_STRING_BRAND_STRING = TO_STRING_BRAND_STRING$LWS;
exports.TO_STRING_BRAND_SYMBOL = TO_STRING_BRAND_SYMBOL$LWS;
exports.TO_STRING_BRAND_UNDEFINED = TO_STRING_BRAND_UNDEFINED$LWS;
exports.TO_STRING_BRAND_WEAK_MAP = TO_STRING_BRAND_WEAK_MAP$LWS;
exports.TO_STRING_BRAND_WEAK_SET = TO_STRING_BRAND_WEAK_SET$LWS;
exports.UNCOMPILED_LOCATION_NAME = UNCOMPILED_LOCATION_NAME$LWS;
exports.WEBPACK_REQUIRE_NAME = WEBPACK_REQUIRE_NAME$LWS;
exports.WeakMapCtor = WeakMapCtor$LWS;
exports.WeakMapGet = WeakMapGet$LWS;
exports.WeakMapSet = WeakMapSet$LWS;
exports.capitalizeFirstChar = capitalizeFirstChar$LWS;
exports.consoleWarn = consoleWarn$LWS;
exports.createRevokedProxy = createRevokedProxy$LWS;
exports.enquote = enquote$LWS;
exports.escapeQuotes = escapeQuotes$LWS;
exports.escapeRegExp = escapeRegExp$LWS;
exports.getBrand = getBrand$LWS;
exports.getNearMembraneSerializedValue = getNearMembraneSerializedValue$LWS;
exports.getTimestamp = getTimestamp$LWS;
exports.isArrayBuffer = isArrayBuffer$LWS;
exports.isBigIntObject = isBigIntObject$LWS;
exports.isBooleanObject = isBooleanObject$LWS;
exports.isConvertibleToString = isConvertibleToString$LWS;
exports.isDate = isDate$LWS;
exports.isLiveObject = isLiveObject$LWS;
exports.isMap = isMap$LWS;
exports.isNearMembrane = isNearMembrane$LWS;
exports.isNumberObject = isNumberObject$LWS;
exports.isObject = isObject$LWS;
exports.isObjectLike = isObjectLike$LWS;
exports.isRegExp = isRegExp$LWS;
exports.isSet = isSet$LWS;
exports.isStringObject = isStringObject$LWS;
exports.isSymbolObject = isSymbolObject$LWS;
exports.isWeakMap = isWeakMap$LWS;
exports.isWeakSet = isWeakSet$LWS;
exports.markLiveObject = markLiveObject$LWS;
exports.maskDistortion = maskDistortion$LWS;
exports.shallowCloneArray = shallowCloneArray$LWS;
exports.shallowCloneOptions = shallowCloneOptions$LWS;
exports.toBoolean = toBoolean$LWS;
exports.toLiveValue = toLiveValue$LWS;
exports.toSafeDescriptor = toSafeDescriptor$LWS;
exports.toString = toString$LWS;
exports.toStringIfNotNullOrUndefined = toStringIfNotNullOrUndefined$LWS;
exports.wrap = wrap$LWS;
/*! version: 0.15.16 */
