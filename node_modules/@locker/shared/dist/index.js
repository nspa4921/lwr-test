/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  has: ReflectHas$LWS,
  get: ReflectGet$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  ownKeys: ReflectOwnKeys$LWS
} = Reflect;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  filter: ArrayProtoFilter$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  pop: ArrayProtoPop$LWS,
  shift: ArrayProtoShift$LWS,
  some: ArrayProtoSome$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
const {
  push: ArrayProtoPush$LWS,
  slice: ArrayProtoSlice$LWS
} = ArrayProto$LWS;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
  const {
    length: length$LWS
  } = args$LWS;

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];
    ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, ArrayIsArray$LWS(value$LWS) ? value$LWS : [value$LWS]);
  }

  return result$LWS;
}

function ArrayFilter$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoFilter$LWS, array$LWS, [iteratee$LWS]);
}

function ArrayIncludes$LWS(array$LWS, value$LWS) {
  return ReflectApply$LWS(ArrayProtoIncludes$LWS, array$LWS, [value$LWS]);
}

function ArrayIndexOf$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoIndexOf$LWS, array$LWS, args$LWS);
}

function ArrayJoin$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoJoin$LWS, array$LWS, args$LWS);
}

function ArrayPop$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoPop$LWS, array$LWS, []);
}

function ArrayShift$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoShift$LWS, array$LWS, []);
}

function ArraySlice$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, args$LWS);
}

function ArraySome$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoSome$LWS, array$LWS, [iteratee$LWS]);
}

function ArraySort$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSort$LWS, array$LWS, []);
}

function ArrayUnshift$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoUnshift$LWS, array$LWS, args$LWS);
}

const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  freeze: ObjectFreeze$LWS,
  getOwnPropertyNames: ObjectGetOwnPropertyNames$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupGetter__: ObjectProto__lookupGetter__$LWS,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupSetter__: ObjectProto__lookupSetter__$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

function ObjectHasOwnProperty$LWS(object$LWS, key$LWS) {
  return object$LWS !== null && object$LWS !== undefined && ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupGetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupSetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return object$LWS[key$LWS];
}

function ObjectToString$LWS(object$LWS) {
  return ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength');

function isArrayBuffer$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
    ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  return false;
} // https://caniuse.com/bigint


const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
const isBigIntObject$LWS = SUPPORTS_BIG_INT$LWS ? function isBigIntObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }

  return false;
} : function isBigIntObject$LWS(_value$LWS) {
  return false;
};
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;

function isBooleanObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.3.3 Properties of the Boolean Prototype Object
      // https://tc39.es/ecma262/#thisbooleanvalue
      // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
      //     a. Let b be value.[[BooleanData]].
      //     b. Assert: Type(b) is Boolean.
      ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused3$LWS) {}
  }

  return false;
}

function toBoolean$LWS(value$LWS) {
  return !!value$LWS;
}

const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const QUOTE_CHAR_DOUBLE$LWS = '"';
const QUOTE_CHAR_SINGLE$LWS = "'";
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_ERROR$LWS = '[object Error]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  now: DateNow$LWS
} = DateCtor$LWS;

function isDate$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.4.4 Properties of the Date Prototype Object
      // https://tc39.es/ecma262/#thistimevalue
      // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
      //     a. Return value.[[DateValue]].
      // Step 2: Throw a TypeError exception.
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
  }

  return false;
}

const {
  bind: FunctionProtoBind$LWS
} = Function.prototype;

const FunctionBind$LWS = (func$LWS, thisArg$LWS) => ReflectApply$LWS(FunctionProtoBind$LWS, func$LWS, [thisArg$LWS]);

function wrap$LWS(func$LWS, wrapper$LWS) {
  return function wrapped$LWS(...args$LWS) {
    return ReflectApply$LWS(wrapper$LWS, this, [func$LWS, args$LWS]);
  };
}

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  entries: MapProtoEntries$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');

function isMap$LWS(value$LWS) {
  try {
    // Section 24.1.3.10 get Map.prototype.size
    // https://tc39.es/ecma262/#sec-get-map.prototype.size
    // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
    ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused5$LWS) {}

  return false;
}

function MapClear$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoClear$LWS, map$LWS, []);
}

function MapEntries$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []);
}

function MapForEach$LWS(map$LWS, iteratee$LWS) {
  return ReflectApply$LWS(MapProtoForEach$LWS, map$LWS, [iteratee$LWS]);
}

function MapGet$LWS(map$LWS, key$LWS) {
  return ReflectApply$LWS(MapProtoGet$LWS, map$LWS, [key$LWS]);
}

function MapSet$LWS(map$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(MapProtoSet$LWS, map$LWS, [key$LWS, value$LWS]);
}

const NumberCtor$LWS = Number;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberCtor$LWS.prototype;
const {
  isFinite: NumberIsFinite$LWS
} = NumberCtor$LWS;

function isNumberObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.1.3 Properties of the Number Prototype Object
      // https://tc39.es/ecma262/#thisnumbervalue
      // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
      //     a. Let n be value.[[NumberData]].
      //     b. Assert: Type(n) is Number.
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused6$LWS) {}
  }

  return false;
}

function NumberToFixed$LWS(num$LWS, digits$LWS = 0) {
  return ReflectApply$LWS(NumberProtoToFixed$LWS, num$LWS, [digits$LWS]);
}

const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  charCodeAt: StringProtoCharCodeAt$LWS,
  includes: StringProtoIncludes$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const QUOTE_CHAR_REG_EXP_MAP$LWS = {
  __proto__: null,
  [QUOTE_CHAR_DOUBLE$LWS]: /\\?"/g,
  [QUOTE_CHAR_SINGLE$LWS]: /\\?'/g
};

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (!length$LWS) {
    return string$LWS;
  }

  const upper$LWS = StringToUpperCase$LWS(string$LWS[0]);
  return length$LWS === 1 ? upper$LWS : upper$LWS + StringSlice$LWS(string$LWS, 1);
}

function enquote$LWS(string$LWS, quoteChar$LWS = QUOTE_CHAR_SINGLE$LWS) {
  return quoteChar$LWS + escapeQuotes$LWS(string$LWS, quoteChar$LWS) + quoteChar$LWS;
}

function escapeQuotes$LWS(string$LWS, quoteChar$LWS = QUOTE_CHAR_SINGLE$LWS) {
  return string$LWS.replace(QUOTE_CHAR_REG_EXP_MAP$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`);
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused7$LWS) {}
  }

  return false;
}

function isStringObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 22.1.3 Properties of the String Prototype Object
      // https://tc39.es/ecma262/#thisstringvalue
      // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
      //     a. Let s be value.[[StringData]].
      //     b. Assert: Type(s) is String.
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
  }

  return false;
}

function StringCharCodeAt$LWS(string$LWS, index$LWS) {
  return ReflectApply$LWS(StringProtoCharCodeAt$LWS, string$LWS, [index$LWS]);
}

function StringIncludes$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoIncludes$LWS, string$LWS, args$LWS);
}

function StringMatch$LWS(string$LWS, regexp$LWS) {
  return ReflectApply$LWS(StringProtoMatch$LWS, string$LWS, [regexp$LWS]);
}

function StringReplace$LWS(string$LWS, pattern$LWS, replacement$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [pattern$LWS, replacement$LWS]);
}

function StringSlice$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, args$LWS);
}

function StringSplit$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSplit$LWS, string$LWS, args$LWS);
}

function StringStartsWith$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoStartsWith$LWS, string$LWS, args$LWS);
}

function StringToLowerCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToLowerCase$LWS, string$LWS, []);
}

function StringToUpperCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS, []);
}

function toString$LWS(value$LWS) {
  try {
    // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value
    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused9$LWS) {}

  return '';
}

function toStringIfNotNullOrUndefined$LWS(value$LWS) {
  return value$LWS === null || value$LWS === undefined ? value$LWS : toString$LWS(value$LWS);
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return StringReplace$LWS(string$LWS, specialCharRegExp$LWS, '\\$&');
}

function isRegExp$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (value$LWS !== RegExpProto$LWS) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return true;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {}

  return false;
}

function RegExpTest$LWS(regexp$LWS, content$LWS) {
  return ReflectApply$LWS(RegExpProtoTest$LWS, regexp$LWS, [toString$LWS(content$LWS)]);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  add: SetProtoAdd$LWS,
  delete: SetProtoDelete$LWS,
  has: SetProtoHas$LWS,
  values: SetProtoValue$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');

function isSet$LWS(value$LWS) {
  try {
    // Section 24.2.3.9 get Set.prototype.size
    // https://tc39.es/ecma262/#sec-get-set.prototype.size
    // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
    ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused11$LWS) {}

  return false;
}

function SetAdd$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoAdd$LWS, set$LWS, [value$LWS]);
}

function SetDelete$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoDelete$LWS, set$LWS, [value$LWS]);
}

function SetHas$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoHas$LWS, set$LWS, [value$LWS]);
}

function SetValues$LWS(set$LWS) {
  return ReflectApply$LWS(SetProtoValue$LWS, set$LWS, []);
}

const SymbolCtor$LWS = Symbol;
const {
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS
} = SymbolCtor$LWS;

function isSymbolObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.4.3 Properties of the Symbol Prototype Object
      // https://tc39.es/ecma262/#thissymbolvalue
      // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
      //     a. Let s be value.[[SymbolData]].
      //     b. Assert: Type(s) is Symbol.
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
  }

  return false;
}

const WeakMapCtor$LWS = WeakMap;
const {
  get: WeakMapProtoGet$LWS,
  has: WeakMapProtoHas$LWS,
  set: WeakMapProtoSet$LWS
} = WeakMapCtor$LWS.prototype;

function isWeakMap$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.3.3.4 WeakMap.prototype.has ( key )
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // Step 2: Perform ? RequireInternalSlot(M, [[WeakMapData]]).
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  return false;
}

function WeakMapGet$LWS(weakMap$LWS, key$LWS) {
  return ReflectApply$LWS(WeakMapProtoGet$LWS, weakMap$LWS, [key$LWS]);
}

function WeakMapSet$LWS(weakMap$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(WeakMapProtoSet$LWS, weakMap$LWS, [key$LWS, value$LWS]);
}

const {
  has: WeakSetProtoHas$LWS
} = WeakSet.prototype;

function isWeakSet$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.4.3.4 WeakSet.prototype.has ( value )
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      // Step 2: 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
  }

  return false;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol;

function getBrandByTrailAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  if (isDate$LWS(value$LWS)) {
    return TO_STRING_BRAND_DATE$LWS;
  }

  if (isMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_MAP$LWS;
  }

  if (isRegExp$LWS(value$LWS)) {
    return TO_STRING_BRAND_REG_EXP$LWS;
  }

  if (isSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_SET$LWS;
  }

  if (isWeakMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_MAP$LWS;
  }

  if (isWeakSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_SET$LWS;
  }

  if (isBigIntObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BIG_INT$LWS;
  }

  if (isBooleanObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BOOLEAN$LWS;
  }

  if (isNumberObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_NUMBER$LWS;
  }

  if (isStringObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_STRING$LWS;
  }

  if (isSymbolObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_SYMBOL$LWS;
  } // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return ReflectHas$LWS(value$LWS, TO_STRING_TAG_SYMBOL$LWS) ? getBrandByTrailAndError$LWS(value$LWS) : ObjectToString$LWS(value$LWS);
}

const getTimestamp$LWS = typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : FunctionBind$LWS(performance.now, performance);

function toSafeDescriptor$LWS(desc$LWS) {
  ReflectSetPrototypeOf$LWS(desc$LWS, null);
  return desc$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}

const ProxyCtor$LWS = Proxy;
const ProxyRevocable$LWS = Proxy.revocable;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}

function maskDistortion$LWS(distortedFunc$LWS, rawFunc$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(rawFunc$LWS, ObjectFreeze$LWS({
    apply(_target$LWS, thisArg$LWS, args$LWS) {
      if (thisArg$LWS === proxy$LWS) {
        thisArg$LWS = distortedFunc$LWS;
      }

      return ReflectApply$LWS(distortedFunc$LWS, thisArg$LWS, args$LWS);
    },

    construct(_target$LWS, args$LWS, newTarget$LWS) {
      if (newTarget$LWS === proxy$LWS) {
        newTarget$LWS = distortedFunc$LWS;
      }

      return ReflectConstruct$LWS(distortedFunc$LWS, args$LWS, newTarget$LWS);
    }

  }));
  return proxy$LWS;
}

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_LIVE_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerLiveValue'); // This is used by packages/locker-core-engine/src/LockerFilter.js

const SYMBOL_LIVE_OBJECT$LWS = LOCKER_LIVE_VALUE_SYMBOL$LWS;

function isLiveObject$LWS(value$LWS) {
  if (value$LWS === null || value$LWS === undefined || value$LWS === ObjectProto$LWS || !(typeof value$LWS === 'object' || typeof value$LWS === 'function')) {
    return false;
  } // Based on the isTargetLive() function of
  // salesforce/near-membrane/packages/near-membrane-base/src/membrane.ts.


  if (typeof value$LWS === 'object') {
    const {
      constructor: constructor$LWS
    } = value$LWS;

    if (constructor$LWS === ObjectCtor$LWS) {
      // If the constructor, own or inherited, points to `Object`
      // then `value` is not likely a prototype object.
      return true;
    }

    let result$LWS = false;

    if (ReflectGetPrototypeOf$LWS(value$LWS) === null) {
      // Ensure `value` is not an `Object.prototype` from an iframe.
      result$LWS = typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== value$LWS;
    }

    if (!result$LWS) {
      result$LWS = ArrayIsArray$LWS(value$LWS) || ArrayBufferIsView$LWS(value$LWS) || isArrayBuffer$LWS(value$LWS) || isRegExp$LWS(value$LWS);
    }

    if (result$LWS) {
      return result$LWS;
    }
  }

  return ObjectHasOwnProperty$LWS(value$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS);
}

function markLiveObject$LWS(target$LWS) {
  ReflectDefineProperty$LWS(target$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS, {
    __proto__: null,
    value: undefined
  });
  return target$LWS;
}

function toLiveValue$LWS(value$LWS) {
  if (isObjectLike$LWS(value$LWS)) {
    return isLiveObject$LWS(value$LWS) ? value$LWS : markLiveObject$LWS(value$LWS);
  }

  return value$LWS;
}

const MathMin$LWS = Math.min;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  return isObjectLike$LWS(value$LWS) && !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
}

const {
  then: PromiseProtoThen$LWS
} = Promise.prototype;
const PromiseReject$LWS = Promise.reject.bind(Promise);

function PromiseThen$LWS(promise$LWS, ...args$LWS) {
  return ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, args$LWS);
}

export { ArrayBufferIsView$LWS as ArrayBufferIsView, ArrayConcat$LWS as ArrayConcat, ArrayCtor$LWS as ArrayCtor, ArrayFilter$LWS as ArrayFilter, ArrayIncludes$LWS as ArrayIncludes, ArrayIndexOf$LWS as ArrayIndexOf, ArrayIsArray$LWS as ArrayIsArray, ArrayJoin$LWS as ArrayJoin, ArrayPop$LWS as ArrayPop, ArrayProtoPush$LWS as ArrayProtoPush, ArrayProtoSlice$LWS as ArrayProtoSlice, ArrayShift$LWS as ArrayShift, ArraySlice$LWS as ArraySlice, ArraySome$LWS as ArraySome, ArraySort$LWS as ArraySort, ArrayUnshift$LWS as ArrayUnshift, DateNow$LWS as DateNow, FunctionBind$LWS as FunctionBind, JSONParse$LWS as JSONParse, JSONStringify$LWS as JSONStringify, LOCKER_IDENTIFIER_MARKER$LWS as LOCKER_IDENTIFIER_MARKER, LOCKER_UNMINIFIED_FLAG$LWS as LOCKER_UNMINIFIED_FLAG, LockerSecurityError$LWS as LockerSecurityError, MapClear$LWS as MapClear, MapCtor$LWS as MapCtor, MapEntries$LWS as MapEntries, MapForEach$LWS as MapForEach, MapGet$LWS as MapGet, MapSet$LWS as MapSet, MathMin$LWS as MathMin, NumberIsFinite$LWS as NumberIsFinite, NumberToFixed$LWS as NumberToFixed, ObjectAssign$LWS as ObjectAssign, ObjectCtor$LWS as ObjectCtor, ObjectFreeze$LWS as ObjectFreeze, ObjectGetOwnPropertyDescriptors$LWS as ObjectGetOwnPropertyDescriptors, ObjectGetOwnPropertyNames$LWS as ObjectGetOwnPropertyNames, ObjectGetOwnPropertySymbols$LWS as ObjectGetOwnPropertySymbols, ObjectHasOwnProperty$LWS as ObjectHasOwnProperty, ObjectKeys$LWS as ObjectKeys, ObjectLookupOwnGetter$LWS as ObjectLookupOwnGetter, ObjectLookupOwnSetter$LWS as ObjectLookupOwnSetter, ObjectLookupOwnValue$LWS as ObjectLookupOwnValue, ObjectPreventExtensions$LWS as ObjectPreventExtensions, ObjectProto$LWS as ObjectProto, ObjectToString$LWS as ObjectToString, PromiseReject$LWS as PromiseReject, PromiseThen$LWS as PromiseThen, ProxyCtor$LWS as ProxyCtor, ProxyRevocable$LWS as ProxyRevocable, QUOTE_CHAR_DOUBLE$LWS as QUOTE_CHAR_DOUBLE, QUOTE_CHAR_SINGLE$LWS as QUOTE_CHAR_SINGLE, ReflectApply$LWS as ReflectApply, ReflectConstruct$LWS as ReflectConstruct, ReflectDefineProperty$LWS as ReflectDefineProperty, ReflectDeleteProperty$LWS as ReflectDeleteProperty, ReflectGet$LWS as ReflectGet, ReflectGetOwnPropertyDescriptor$LWS as ReflectGetOwnPropertyDescriptor, ReflectGetPrototypeOf$LWS as ReflectGetPrototypeOf, ReflectHas$LWS as ReflectHas, ReflectOwnKeys$LWS as ReflectOwnKeys, ReflectSet$LWS as ReflectSet, ReflectSetPrototypeOf$LWS as ReflectSetPrototypeOf, RegExpCtor$LWS as RegExpCtor, RegExpTest$LWS as RegExpTest, SANDBOX_EVAL_CONTEXT_NAME$LWS as SANDBOX_EVAL_CONTEXT_NAME, SANDBOX_EVAL_HELPERS_NAME$LWS as SANDBOX_EVAL_HELPERS_NAME, SYMBOL_LIVE_OBJECT$LWS as SYMBOL_LIVE_OBJECT, SetAdd$LWS as SetAdd, SetCtor$LWS as SetCtor, SetDelete$LWS as SetDelete, SetHas$LWS as SetHas, SetValues$LWS as SetValues, StringCharCodeAt$LWS as StringCharCodeAt, StringCtor$LWS as StringCtor, StringIncludes$LWS as StringIncludes, StringMatch$LWS as StringMatch, StringReplace$LWS as StringReplace, StringSlice$LWS as StringSlice, StringSplit$LWS as StringSplit, StringStartsWith$LWS as StringStartsWith, StringToLowerCase$LWS as StringToLowerCase, StringToUpperCase$LWS as StringToUpperCase, SymbolFor$LWS as SymbolFor, SymbolIterator$LWS as SymbolIterator, TO_STRING_BRAND_ARRAY$LWS as TO_STRING_BRAND_ARRAY, TO_STRING_BRAND_BIG_INT$LWS as TO_STRING_BRAND_BIG_INT, TO_STRING_BRAND_BOOLEAN$LWS as TO_STRING_BRAND_BOOLEAN, TO_STRING_BRAND_DATE$LWS as TO_STRING_BRAND_DATE, TO_STRING_BRAND_ERROR$LWS as TO_STRING_BRAND_ERROR, TO_STRING_BRAND_FUNCTION$LWS as TO_STRING_BRAND_FUNCTION, TO_STRING_BRAND_MAP$LWS as TO_STRING_BRAND_MAP, TO_STRING_BRAND_NULL$LWS as TO_STRING_BRAND_NULL, TO_STRING_BRAND_NUMBER$LWS as TO_STRING_BRAND_NUMBER, TO_STRING_BRAND_OBJECT$LWS as TO_STRING_BRAND_OBJECT, TO_STRING_BRAND_REG_EXP$LWS as TO_STRING_BRAND_REG_EXP, TO_STRING_BRAND_SET$LWS as TO_STRING_BRAND_SET, TO_STRING_BRAND_STRING$LWS as TO_STRING_BRAND_STRING, TO_STRING_BRAND_SYMBOL$LWS as TO_STRING_BRAND_SYMBOL, TO_STRING_BRAND_UNDEFINED$LWS as TO_STRING_BRAND_UNDEFINED, TO_STRING_BRAND_WEAK_MAP$LWS as TO_STRING_BRAND_WEAK_MAP, TO_STRING_BRAND_WEAK_SET$LWS as TO_STRING_BRAND_WEAK_SET, UNCOMPILED_LOCATION_NAME$LWS as UNCOMPILED_LOCATION_NAME, WEBPACK_REQUIRE_NAME$LWS as WEBPACK_REQUIRE_NAME, WeakMapCtor$LWS as WeakMapCtor, WeakMapGet$LWS as WeakMapGet, WeakMapSet$LWS as WeakMapSet, capitalizeFirstChar$LWS as capitalizeFirstChar, consoleWarn$LWS as consoleWarn, createRevokedProxy$LWS as createRevokedProxy, enquote$LWS as enquote, escapeQuotes$LWS as escapeQuotes, escapeRegExp$LWS as escapeRegExp, getBrand$LWS as getBrand, getNearMembraneSerializedValue$LWS as getNearMembraneSerializedValue, getTimestamp$LWS as getTimestamp, isArrayBuffer$LWS as isArrayBuffer, isBigIntObject$LWS as isBigIntObject, isBooleanObject$LWS as isBooleanObject, isConvertibleToString$LWS as isConvertibleToString, isDate$LWS as isDate, isLiveObject$LWS as isLiveObject, isMap$LWS as isMap, isNearMembrane$LWS as isNearMembrane, isNumberObject$LWS as isNumberObject, isObject$LWS as isObject, isObjectLike$LWS as isObjectLike, isRegExp$LWS as isRegExp, isSet$LWS as isSet, isStringObject$LWS as isStringObject, isSymbolObject$LWS as isSymbolObject, isWeakMap$LWS as isWeakMap, isWeakSet$LWS as isWeakSet, markLiveObject$LWS as markLiveObject, maskDistortion$LWS as maskDistortion, shallowCloneArray$LWS as shallowCloneArray, shallowCloneOptions$LWS as shallowCloneOptions, toBoolean$LWS as toBoolean, toLiveValue$LWS as toLiveValue, toSafeDescriptor$LWS as toSafeDescriptor, toString$LWS as toString, toStringIfNotNullOrUndefined$LWS as toStringIfNotNullOrUndefined, wrap$LWS as wrap };
/*! version: 0.15.16 */
