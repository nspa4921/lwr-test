/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { StringToLowerCase as StringToLowerCase$LWS, MapCtor as MapCtor$LWS, MapSet as MapSet$LWS, MapEntries as MapEntries$LWS, ObjectLookupOwnSetter as ObjectLookupOwnSetter$LWS, ReflectApply as ReflectApply$LWS, ArrayPop as ArrayPop$LWS, StringSplit as StringSplit$LWS, StringReplace as StringReplace$LWS, isObjectLike as isObjectLike$LWS, shallowCloneOptions as shallowCloneOptions$LWS, StringStartsWith as StringStartsWith$LWS, StringSlice as StringSlice$LWS, isConvertibleToString as isConvertibleToString$LWS, PromiseThen as PromiseThen$LWS, PromiseReject as PromiseReject$LWS, LockerSecurityError as LockerSecurityError$LWS, StringCharCodeAt as StringCharCodeAt$LWS, SetCtor as SetCtor$LWS, SetAdd as SetAdd$LWS, SetHas as SetHas$LWS, ObjectLookupOwnGetter as ObjectLookupOwnGetter$LWS, toLiveValue as toLiveValue$LWS, toString as toString$LWS, ArrayJoin as ArrayJoin$LWS, ReflectSetPrototypeOf as ReflectSetPrototypeOf$LWS, shallowCloneArray as shallowCloneArray$LWS, RegExpTest as RegExpTest$LWS, ObjectAssign as ObjectAssign$LWS, ReflectGetPrototypeOf as ReflectGetPrototypeOf$LWS, WeakMapCtor as WeakMapCtor$LWS, WeakMapSet as WeakMapSet$LWS, WeakMapGet as WeakMapGet$LWS, toStringIfNotNullOrUndefined as toStringIfNotNullOrUndefined$LWS, ArrayIndexOf as ArrayIndexOf$LWS, ArraySlice as ArraySlice$LWS, ReflectGetOwnPropertyDescriptor as ReflectGetOwnPropertyDescriptor$LWS, toSafeDescriptor as toSafeDescriptor$LWS, consoleWarn as consoleWarn$LWS, ObjectLookupOwnValue as ObjectLookupOwnValue$LWS, capitalizeFirstChar as capitalizeFirstChar$LWS, StringMatch as StringMatch$LWS, ReflectDefineProperty as ReflectDefineProperty$LWS, UNCOMPILED_LOCATION_NAME as UNCOMPILED_LOCATION_NAME$LWS, maskDistortion as maskDistortion$LWS, createRevokedProxy as createRevokedProxy$LWS, ObjectKeys as ObjectKeys$LWS, ArrayCtor as ArrayCtor$LWS, markLiveObject as markLiveObject$LWS, ReflectGet as ReflectGet$LWS, ObjectHasOwnProperty as ObjectHasOwnProperty$LWS, ReflectSet as ReflectSet$LWS, ReflectDeleteProperty as ReflectDeleteProperty$LWS, ObjectGetOwnPropertySymbols as ObjectGetOwnPropertySymbols$LWS, ArrayConcat as ArrayConcat$LWS, ReflectHas as ReflectHas$LWS, isObject as isObject$LWS, ArrayIncludes as ArrayIncludes$LWS, ObjectFreeze as ObjectFreeze$LWS, ProxyCtor as ProxyCtor$LWS, ObjectGetOwnPropertyDescriptors as ObjectGetOwnPropertyDescriptors$LWS, ArrayProtoPush as ArrayProtoPush$LWS, LOCKER_IDENTIFIER_MARKER as LOCKER_IDENTIFIER_MARKER$LWS } from '@locker/shared';
import { NAMESPACE_DEFAULT as NAMESPACE_DEFAULT$LWS, AttrOwnerElementGetter as AttrOwnerElementGetter$LWS, AttrNameGetter as AttrNameGetter$LWS, AttrNamespaceURIGetter as AttrNamespaceURIGetter$LWS, nsCookieKey as nsCookieKey$LWS, nsCookieRootKey as nsCookieRootKey$LWS, DocumentCookieGetter as DocumentCookieGetter$LWS, DocumentCookieSetter as DocumentCookieSetter$LWS, getValidator as getValidator$LWS, getPatchedWindow as getPatchedWindow$LWS, DocumentHeadGetter as DocumentHeadGetter$LWS, AttrValueGetter as AttrValueGetter$LWS, ElementGetAttributeNode as ElementGetAttributeNode$LWS, ElementRemoveAttributeNode as ElementRemoveAttributeNode$LWS, AttrValueSetter as AttrValueSetter$LWS, ElementGetAttributeNodeNS as ElementGetAttributeNodeNS$LWS, EventCurrentTargetGetter as EventCurrentTargetGetter$LWS, partialStructuredClone as partialStructuredClone$LWS, HTMLIFrameElementSrcSetter as HTMLIFrameElementSrcSetter$LWS, DOMTokenListValueGetter as DOMTokenListValueGetter$LWS, HTMLElementDatasetGetter as HTMLElementDatasetGetter$LWS, ElementGetNamespaceURI as ElementGetNamespaceURI$LWS, ElementSetAttributeNS as ElementSetAttributeNS$LWS, HTMLAnchorElementHrefSetter as HTMLAnchorElementHrefSetter$LWS, HTMLAnchorElementHrefGetter as HTMLAnchorElementHrefGetter$LWS, HTMLAnchorElementHostnameGetter as HTMLAnchorElementHostnameGetter$LWS, XhrCtor as XhrCtor$LWS, XhrWithCredentialsSetter as XhrWithCredentialsSetter$LWS, EventTargetAddEventListener as EventTargetAddEventListener$LWS, XhrStatusGetter as XhrStatusGetter$LWS, XhrResponseTextGetter as XhrResponseTextGetter$LWS, URLCreateObjectURL as URLCreateObjectURL$LWS, BlobCtor as BlobCtor$LWS, XhrOpen as XhrOpen$LWS, XhrSend as XhrSend$LWS, transformUncompiledSource as transformUncompiledSource$LWS, WindowEncodeURIComponent as WindowEncodeURIComponent$LWS, DocumentCreateElement as DocumentCreateElement$LWS, NAMESPACE_XHTML as NAMESPACE_XHTML$LWS, NAMESPACE_XLINK as NAMESPACE_XLINK$LWS, DocumentFragmentQuerySelector as DocumentFragmentQuerySelector$LWS, StorageProtoKey as StorageProtoKey$LWS, StorageProtoGetItem as StorageProtoGetItem$LWS, StorageProtoSetItem as StorageProtoSetItem$LWS, StorageProtoRemoveItem as StorageProtoRemoveItem$LWS, ElementHasAttribute as ElementHasAttribute$LWS, ElementGetAttribute as ElementGetAttribute$LWS, SVGElementDatasetGetter as SVGElementDatasetGetter$LWS, BlobTypeGetter as BlobTypeGetter$LWS, BlobSlice as BlobSlice$LWS, BlobSizeGetter as BlobSizeGetter$LWS, URLRevokeObjectURL as URLRevokeObjectURL$LWS, RequestURLGetter as RequestURLGetter$LWS, WindowLengthGetter as WindowLengthGetter$LWS, isWindowLike as isWindowLike$LWS, isWindow as isWindow$LWS, getPatchedPostMessage as getPatchedPostMessage$LWS } from '@locker/shared-dom';
import { sanitize as sanitize$LWS, sanitizeSvgInnerHtml as sanitizeSvgInnerHtml$LWS, sanitizeSvgHref as sanitizeSvgHref$LWS, blobSanitizer as blobSanitizer$LWS, sanitizeDocument as sanitizeDocument$LWS } from '@locker/html-sanitizer';
import { sanitizeURLForElement as sanitizeURLForElement$LWS, isValidURLScheme as isValidURLScheme$LWS, TRUSTED_DOMAINS as TRUSTED_DOMAINS$LWS, parseURL as parseURL$LWS, isInvalidURL as isInvalidURL$LWS, isMIMETypeAllowed as isMIMETypeAllowed$LWS } from '@locker/shared-url';
const CustomElementRegistryBlockedProperties$LWS = ['define'];
/**
 * this registry is going to be used by Attr, NameNodeMap, setAttribute* distortions
 */

const distortionsBySandboxKeyRegistry$LWS = {
  __proto__: null
}; // An array of factories traversed when we create a new sandbox. The result of
// parsing this registry will be a new registry with initialized distortions.

const factories$LWS = [];

function storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  const {
    [attributeName$LWS]: byAttributeNamespaceRegistry$LWS = {
      __proto__: null
    }
  } = registry$LWS;
  const {
    [attributeNamespace$LWS]: byElementCtor$LWS = new MapCtor$LWS()
  } = byAttributeNamespaceRegistry$LWS;
  MapSet$LWS(byElementCtor$LWS, ElementCtor$LWS, distortion$LWS);
  byAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = byElementCtor$LWS;
  registry$LWS[attributeName$LWS] = byAttributeNamespaceRegistry$LWS;
}

function getAttributeDistortion$LWS(element$LWS, key$LWS, attributeName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    [key$LWS]: registry$LWS
  } = distortionsBySandboxKeyRegistry$LWS;
  attributeName$LWS = StringToLowerCase$LWS(attributeName$LWS);
  const byAttributeNamespaceRegistry$LWS = registry$LWS[attributeName$LWS];

  if (!byAttributeNamespaceRegistry$LWS) {
    return undefined;
  }

  const {
    [attributeNamespace$LWS]: byElementCtor$LWS
  } = byAttributeNamespaceRegistry$LWS;

  if (!byElementCtor$LWS) {
    return undefined;
  }

  const mapIterator$LWS = MapEntries$LWS(byElementCtor$LWS); // using a restricted syntax to avoid accessing .next on iterator
  // eslint-disable-next-line no-restricted-syntax

  for (const entry$LWS of mapIterator$LWS) {
    const Ctor$LWS = entry$LWS[0];
    const distortion$LWS = entry$LWS[1]; // element can inherit from Ctor but Ctor
    // may not be the first entry in the proto chain
    // thus element.prototype checks are not sufficient

    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function makeElementDistortionsForSandboxKey$LWS(key$LWS) {
  // This registry is created per sandbox.
  const registry$LWS = {
    __proto__: null
  };
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(registry$LWS);

    if (entry$LWS) {
      entries$LWS[entriesOffset$LWS++] = entry$LWS;
    }
  }

  distortionsBySandboxKeyRegistry$LWS[key$LWS] = registry$LWS;
  return entries$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}

function registerElementSetDistortion$LWS(ElementCtor$LWS, options$LWS) {
  factories$LWS[factories$LWS.length] = registry$LWS => {
    const {
      attributeNamespace: attributeNamespace$LWS,
      distortion: distortion$LWS
    } = options$LWS;
    const attributeName$LWS = StringToLowerCase$LWS(options$LWS.attributeName);
    storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS);
    return null;
  };
}

function distortionAttrValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');

  function value$LWS(val$LWS) {
    const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

    if (ownerElement$LWS) {
      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [val$LWS]);
        return;
      }
    }

    ReflectApply$LWS(originalAttrValueSetter$LWS, this, [val$LWS]);
  }

  return [originalAttrValueSetter$LWS, value$LWS];
}

function distortionAuraUtilGlobalEval$LWS(globalObject$LWS, options$LWS) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;

  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval;

  if (typeof originalGlobalEval$LWS !== 'function') {
    return null;
  }

  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS; // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.

  const globalEval$LWS = function globalEval$LWS(src$LWS, descriptor$LWS, type$LWS) {
    let compiled$LWS = `(function s(){return(${src$LWS})})()`;

    if (typeof descriptor$LWS === 'string') {
      const name$LWS = ArrayPop$LWS(StringSplit$LWS(descriptor$LWS, '://'));
      compiled$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${StringReplace$LWS(name$LWS, '.', '/')}` : `/components/${StringReplace$LWS(name$LWS, ':', '/')}.js`);
    }

    return evaluator$LWS(key$LWS, compiled$LWS);
  };

  return [originalGlobalEval$LWS, globalEval$LWS];
}

function nsCacheRootKey$LWS(ns$LWS) {
  return `LSKey-${ns$LWS}$`;
}

function nsCacheKey$LWS(key$LWS, ns$LWS) {
  return `${nsCacheRootKey$LWS(ns$LWS)}${key$LWS}`;
}

function prefixCacheName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.cacheName = nsCacheKey$LWS(clonedDetails$LWS.cacheName, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = nsCacheKey$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCacheName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = nsCacheRootKey$LWS(key$LWS); // First check that this Cache object belongs to this sandbox,
  // if not then return null.

  if (!StringStartsWith$LWS(name$LWS, rootKey$LWS)) {
    return null;
  }

  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  return StringSlice$LWS(name$LWS, rootKeyLength$LWS);
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageDelete$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const patchedDelete$LWS = function patchedDelete$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, patchedDelete$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageHas$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy2$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const has$LWS = function has$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalHas$LWS, this, args$LWS);
  };

  return [originalHas$LWS, has$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageKeys$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy3$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const keys$LWS = function keys$LWS() {
    return PromiseThen$LWS(ReflectApply$LWS(originalKeys$LWS, this, []), result$LWS => {
      const sandboxedCacheNames$LWS = [];

      for (let i$LWS = 0, j$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cacheName$LWS = unprefixCacheName$LWS(result$LWS[i$LWS], key$LWS);

        if (typeof cacheName$LWS === 'string') {
          sandboxedCacheNames$LWS[j$LWS++] = cacheName$LWS;
        }
      }

      return sandboxedCacheNames$LWS;
    });
  };

  return [originalKeys$LWS, keys$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageMatch$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy4$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const match$LWS = function match$LWS( // @ts-ignore TypeScript's confusion about using CacheStorage here.
  ...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // This should be sufficient enough to affirm the presense of at least the
    // request | string argument. We want to skip the distorted behavior
    // ONLY in cases where there are no arguments at all, or the request argument
    // is invalid, which is then handled by the host function.

    if (length$LWS && isConvertibleToString$LWS(args$LWS[0])) {
      // Next we check if length is 2, which means that options are present
      const options$LWS = length$LWS === 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the options.cacheName.
      // The value of options.cacheName must also be safely convertable to a string.

      if (!isObjectLike$LWS(options$LWS) || !options$LWS.cacheName || !isConvertibleToString$LWS(options$LWS.cacheName)) {
        return PromiseReject$LWS(new LockerSecurityError$LWS('caches.match() expects the options argument to be present and to have a "cacheName" property.'));
      }

      args$LWS[1] = prefixCacheName$LWS(options$LWS, key$LWS);
    }

    return ReflectApply$LWS(originalMatch$LWS, this, args$LWS);
  };

  return [originalMatch$LWS, match$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageOpen$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy5$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const open$LWS = function open$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  };

  return [originalOpen$LWS, open$LWS];
}

const CHAR_CODE_EQUALS$LWS = 61;
const COOKIE_DELIMITER$LWS = '; ';

function prefixCookieName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = nsCookieKey$LWS(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = nsCookieKey$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookieName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = nsCookieRootKey$LWS(key$LWS); // First check that this cookie belongs to this sandbox,
  // if not then return null.

  if (!StringStartsWith$LWS(name$LWS, rootKey$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key


  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  const rootKeySubstringLength$LWS = StringCharCodeAt$LWS(name$LWS, rootKeyLength$LWS) === CHAR_CODE_EQUALS$LWS ? rootKeyLength$LWS + 1 : rootKeyLength$LWS;
  return StringSlice$LWS(name$LWS, rootKeySubstringLength$LWS);
}

function normalizeCookieListItem$LWS(cookie$LWS, key$LWS) {
  if (cookie$LWS) {
    const unprefixedCookieName$LWS = unprefixCookieName$LWS(cookie$LWS.name, key$LWS); // If unprefixCookieName() returns null, that means this cookie
    // doesn't belong to the provided sandbox (based on the key)

    if (unprefixedCookieName$LWS === null) {
      return null;
    }

    cookie$LWS.name = unprefixedCookieName$LWS;
  }

  return cookie$LWS;
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreDelete$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const deleteValue$LWS = function deleteValue$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, deleteValue$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp2$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const get$LWS = function get$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return PromiseThen$LWS(ReflectApply$LWS(originalGet$LWS, this, args$LWS), result$LWS => normalizeCookieListItem$LWS(result$LWS, key$LWS));
  };

  return [originalGet$LWS, get$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGetAll$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp3$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const getAll$LWS = function getAll$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(args$LWS[0], key$LWS);
    }

    return PromiseThen$LWS(ReflectApply$LWS(originalGetAll$LWS, this, args$LWS), result$LWS => {
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = normalizeCookieListItem$LWS(result$LWS[i$LWS], key$LWS);

        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }

      return sandboxedCookies$LWS;
    });
  };

  return [originalGetAll$LWS, getAll$LWS];
}

const restrictionsBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(eventTarget$LWS, eventName$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    [key$LWS]: bySandboxKeyRegistry$LWS
  } = restrictionsBySandboxKeyRegistry$LWS;

  if (bySandboxKeyRegistry$LWS === undefined || bySandboxKeyRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  const {
    constructor: constructor$LWS
  } = eventTarget$LWS;
  return SetHas$LWS(bySandboxKeyRegistry$LWS[eventName$LWS], constructor$LWS);
}

function registerEventTargetRestriction$LWS(EventTargetCtor$LWS, eventName$LWS, options$LWS) {
  const {
    prototype: EventTargetProto$LWS
  } = EventTargetCtor$LWS;

  if (!isEventTargetRestricted$LWS(EventTargetProto$LWS, eventName$LWS, options$LWS)) {
    const {
      key: key$LWS
    } = options$LWS;
    const {
      [key$LWS]: bySandboxKeyRegistry$LWS = {
        __proto__: null
      }
    } = restrictionsBySandboxKeyRegistry$LWS;
    const {
      [eventName$LWS]: byEventName$LWS = new SetCtor$LWS()
    } = bySandboxKeyRegistry$LWS;
    SetAdd$LWS(byEventName$LWS, EventTargetCtor$LWS);
    bySandboxKeyRegistry$LWS[eventName$LWS] = byEventName$LWS;
    restrictionsBySandboxKeyRegistry$LWS[key$LWS] = bySandboxKeyRegistry$LWS;
  }
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreOnChange$LWS(globalObject$LWS, options$LWS) {
  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalOnChangeSetter$LWS = ObjectLookupOwnSetter$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return null;
  }

  const onchange$LWS = function onchange$LWS() {
    throw new LockerSecurityError$LWS('Cannot set cookieStore.onchange.');
  };

  registerEventTargetRestriction$LWS(CookieStore$LWS, 'change', options$LWS);
  return [originalOnChangeSetter$LWS, onchange$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreSet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp4$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const set$LWS = function set$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        0: name$LWS
      } = args$LWS;
      args$LWS[0] = nsCookieKey$LWS(name$LWS, key$LWS);
    } else if (length$LWS) {
      const {
        0: details$LWS
      } = args$LWS;

      if (isObjectLike$LWS(details$LWS)) {
        const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
        clonedDetails$LWS.name = nsCookieKey$LWS(clonedDetails$LWS.name, key$LWS);
        args$LWS[0] = clonedDetails$LWS;
      }
    }

    return ReflectApply$LWS(originalSet$LWS, this, args$LWS);
  };

  return [originalSet$LWS, set$LWS];
}

function distortionCSSStyleRuleStyleGetter$LWS(globalObject$LWS) {
  const {
    CSSStyleRule: CSSStyleRule$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(CSSStyleRule$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionCustomElementRegistryGet$LWS(globalObject$LWS, options$LWS) {
  var _CustomElementRegistr$LWS;

  const {
    key: key$LWS
  } = options$LWS;
  const LOWER_CASED_NS$LWS = StringToLowerCase$LWS(key$LWS);
  const {
    CustomElementRegistry: CustomElementRegistry$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    if (args$LWS.length) {
      const sanitizedName$LWS = toString$LWS(args$LWS[0]);
      const lowerCasedName$LWS = StringToLowerCase$LWS(sanitizedName$LWS);

      if (!StringStartsWith$LWS(lowerCasedName$LWS, `${LOWER_CASED_NS$LWS}-`)) {
        return undefined;
      }

      args$LWS[0] = sanitizedName$LWS;
    }

    return ReflectApply$LWS(originalGet$LWS, this, args$LWS);
  };

  return [originalGet$LWS, get$LWS];
}
/**
 * Factory patched cookie getter. Must be invoked with namespace argument.
 * Will return a patched cookie getter bound to the namespace.
 * @param key
 * @returns Distortion: string
 */


function distortionDocumentCookieGetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS(Document$LWS.prototype, 'cookie');

  function get$LWS() {
    const documentCookieValue$LWS = DocumentCookieGetter$LWS(this);
    const cookies$LWS = StringSplit$LWS(documentCookieValue$LWS, COOKIE_DELIMITER$LWS);
    const sandboxedCookies$LWS = [];
    let sandboxedCookiesOffset$LWS = 0;

    for (let i$LWS = 0, {
      length: length$LWS
    } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const cookie$LWS = unprefixCookieName$LWS(cookies$LWS[i$LWS], key$LWS);

      if (cookie$LWS) {
        sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
      }
    }

    return ArrayJoin$LWS(sandboxedCookies$LWS, COOKIE_DELIMITER$LWS);
  }

  return [originalCookieGetter$LWS, get$LWS];
}
/**
 * Factory patched cookie setter. Must be invoked with namespace argument.
 * Returns a distortion function bound to the namespace.
 * @param ns
 * @returns Distortion
 */


function distortionDocumentCookieSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');

  function set$LWS(value$LWS) {
    const cookieEntries$LWS = StringSplit$LWS(value$LWS, COOKIE_DELIMITER$LWS);
    let {
      0: newCookieEntry$LWS
    } = cookieEntries$LWS;

    if (StringCharCodeAt$LWS(newCookieEntry$LWS, 0) === CHAR_CODE_EQUALS$LWS) {
      newCookieEntry$LWS = StringSlice$LWS(newCookieEntry$LWS, 1);
    }

    cookieEntries$LWS[0] = nsCookieKey$LWS(newCookieEntry$LWS, key$LWS);
    DocumentCookieSetter$LWS(this, ArrayJoin$LWS(cookieEntries$LWS, COOKIE_DELIMITER$LWS));
  }

  return [originalCookieSetter$LWS, set$LWS];
}

function distortionDocumentDomainSetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');

  function domain$LWS() {
    throw new LockerSecurityError$LWS('Cannot set document.domain.');
  }

  return [originalDomainSetter$LWS, domain$LWS];
} // eslint-disable-next-line no-shadow


var CookieSameSite$LWS;

(function (CookieSameSite$LWS) {
  CookieSameSite$LWS[CookieSameSite$LWS["strict"] = 0] = "strict";
  CookieSameSite$LWS[CookieSameSite$LWS["lax"] = 1] = "lax";
  CookieSameSite$LWS[CookieSameSite$LWS["none"] = 2] = "none";
})(CookieSameSite$LWS || (CookieSameSite$LWS = {})); // eslint-disable-next-line no-shadow


var SandboxType$LWS;

(function (SandboxType$LWS) {
  SandboxType$LWS[SandboxType$LWS["External"] = 0] = "External";
  SandboxType$LWS[SandboxType$LWS["Internal"] = 1] = "Internal";
})(SandboxType$LWS || (SandboxType$LWS = {}));

ReflectSetPrototypeOf$LWS(SandboxType$LWS, null);

function distortionDocumentExecCommand$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS,
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const {
    execCommand: originalExecCommand$LWS
  } = Document$LWS.prototype;
  const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS(Document$LWS.prototype, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'isContentEditable'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);
  const {
    sandboxType: sandboxType$LWS
  } = options$LWS;

  function execCommand$LWS(...args$LWS) {
    if (args$LWS.length > 2) {
      const {
        2: unsanitizedValue$LWS
      } = args$LWS;

      if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
        const command$LWS = toString$LWS(args$LWS[0]);

        if (StringToLowerCase$LWS(command$LWS) === 'inserthtml') {
          if (sandboxType$LWS === SandboxType$LWS.External) {
            const activeElement$LWS = ReflectApply$LWS(originalActiveElement$LWS, this, []);

            if (isSharedElement$LWS(activeElement$LWS) && ReflectApply$LWS(originalIsContentEditable$LWS, activeElement$LWS, [])) {
              throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${toString$LWS(activeElement$LWS.nodeName)}.`);
            }
          }

          args$LWS[0] = command$LWS;
          args$LWS[2] = sanitize$LWS(unsanitizedValue$LWS);
        }
      }
    }

    return ReflectApply$LWS(originalExecCommand$LWS, this, args$LWS);
  }

  return [originalExecCommand$LWS, execCommand$LWS];
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    let windowFeatures$LWS = StringToLowerCase$LWS(toString$LWS(sanitizedArgs$LWS[2]));

    if (RegExpTest$LWS(noopenerRegExp$LWS, windowFeatures$LWS)) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      windowFeatures$LWS = StringReplace$LWS(windowFeatures$LWS, // RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`);
    }

    sanitizedArgs$LWS[2] = windowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function distortionDocumentOpen$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    open: originalDocumentOpen$LWS
  } = Document$LWS.prototype;

  function open$LWS(...args$LWS) {
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      const rawOpenWindow$LWS = ReflectApply$LWS(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
      return getPatchedWindow$LWS(rawOpenWindow$LWS);
    }

    return ReflectApply$LWS(originalDocumentOpen$LWS, this, args$LWS);
  }

  return [originalDocumentOpen$LWS, open$LWS];
}

function distortionDocumentReplaceChildren$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChild$LWS
  } = Document$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check if
    // its `head` property is a shared element. This will allow magenta window
    // documents to call replaceChildren successfully.
    if (isSharedElement$LWS(DocumentHeadGetter$LWS(this))) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    }

    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChildren$LWS];
}

function distortionDOMParserParseFromString$LWS(globalObject$LWS) {
  const {
    DOMParser: DOMParser$LWS
  } = globalObject$LWS;
  const {
    parseFromString: originalParseFromString$LWS
  } = DOMParser$LWS.prototype;

  function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with exactly
    // two arguments. If it receives one argument, it will fail. Some implementations
    // will also fail if it receives more than two arguments. Since any call that does
    // not have at least two arguments will fail no matter what, we only need to
    // expend effort to sanitize when we know that the operation is definitely
    // NOT going to fail.
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = toString$LWS(args$LWS[0]);
      const mimeType$LWS = toString$LWS(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? sanitizeSvgInnerHtml$LWS(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : sanitize$LWS(string$LWS);
    }

    return ReflectApply$LWS(originalParseFromString$LWS, this, args$LWS);
  }

  return [originalParseFromString$LWS, parseFromString$LWS];
}

function distortionElementAfter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    after: originalAfter$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function after$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAfter$LWS, this, args$LWS);
  }

  return [originalAfter$LWS, after$LWS];
}

function distortionElementAppend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    append: originalAppend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function append$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAppend$LWS, this, args$LWS);
  }

  return [originalAppend$LWS, append$LWS];
}

function distortionElementAttachShadow$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    attachShadow: originalAttachShadow$LWS
  } = Element$LWS.prototype;

  function attachShadow$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS;

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit because
        // attachShadow() accepts inherited shadowRootInit properties.


        const shadowRootInit$LWS = ObjectAssign$LWS({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment of mode
        // to avoid complications with inherited non-configurable/non-writable
        // mode properties.

        const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$LWS(originalShadowRootInit$LWS);
        ReflectSetPrototypeOf$LWS(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return ReflectApply$LWS(originalAttachShadow$LWS, this, args$LWS);
  }

  return [originalAttachShadow$LWS, attachShadow$LWS];
}

const registry$LWS = new WeakMapCtor$LWS();

function getPairedElement$LWS(attrInstance$LWS) {
  return WeakMapGet$LWS(registry$LWS, attrInstance$LWS);
}

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  WeakMapSet$LWS(registry$LWS, attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(originalMethod$LWS, nodeNameMap$LWS, attr$LWS, options$LWS) {
  const element$LWS = getPairedElement$LWS(nodeNameMap$LWS);

  if (element$LWS) {
    const {
      key: key$LWS
    } = options$LWS;
    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(element$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const attrValue$LWS = AttrValueGetter$LWS(attr$LWS);
      return ReflectApply$LWS(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  }

  return ReflectApply$LWS(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function distortionElementAttributesGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'attributes');

  function attributes$LWS() {
    const attrs$LWS = ReflectApply$LWS(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }

  return [originalAttributesGetter$LWS, attributes$LWS];
}

function distortionElementBefore$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    before: originalBefore$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function before$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalBefore$LWS, this, args$LWS);
  }

  return [originalBefore$LWS, before$LWS];
}

function distortionElementInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'innerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function innerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${this.nodeName}.`);
    }

    const sanitizedValue$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS);
    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [sanitizedValue$LWS]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionElementInsertAdjacentElement$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentElement: originalInsertAdjacentElement$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function insertAdjacentElement$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${element$LWS.nodeName} adjacent to ${this.nodeName}.`);
      }
    }

    return ReflectApply$LWS(originalInsertAdjacentElement$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentElement$LWS, insertAdjacentElement$LWS];
}

function distortionElementInsertAdjacentHTML$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentHTML: originalInsertAdjacentHTML$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${toString$LWS(this.nodeName)}.`);
    }

    if (args$LWS.length > 1) {
      args$LWS[1] = sanitize$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentHTML$LWS, insertAdjacentHTML$LWS];
}

function distortionElementOuterHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function outerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalOuterHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalOuterHTMLSetter$LWS, outerHTML$LWS];
}

function distortionElementPrepend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    prepend: originalPrepend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function prepend$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalPrepend$LWS, this, args$LWS);
  }

  return [originalPrepend$LWS, prepend$LWS];
}

function distortionElementRemove$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    remove: originalRemove$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function remove$LWS() {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalRemove$LWS, this, []);
  }

  return [originalRemove$LWS, remove$LWS];
}

function distortionElementReplaceChildren$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChildren$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChildren$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${toString$LWS(this.nodeName)}.`);
    }

    return ReflectApply$LWS(originalReplaceChildren$LWS, this, args$LWS);
  }

  return [originalReplaceChildren$LWS, replaceChildren$LWS];
}

function distortionElementReplaceWith$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceWith: originalReplaceWith$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceWith$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${toString$LWS(this.nodeName)}.`);
    }

    return ReflectApply$LWS(originalReplaceWith$LWS, this, args$LWS);
  }

  return [originalReplaceWith$LWS, replaceWith$LWS];
}

function normalizeAttrName$LWS(name$LWS) {
  return StringToLowerCase$LWS(toString$LWS(name$LWS));
}

function distortionElementSetAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element$LWS.prototype;

  function setAttribute$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const attrValue$LWS = toString$LWS(args$LWS[1]);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
        return;
      }

      args$LWS[0] = attrName$LWS;
      args$LWS[1] = attrValue$LWS;
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, args$LWS);
  }

  return [originalSetAttribute$LWS, setAttribute$LWS];
}

function distortionElementSetAttributeNode$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNode: originalSetAttributeNode$LWS
  } = Element$LWS.prototype;

  function setAttributeNode$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (AttrOwnerElementGetter$LWS(attr$LWS)) {
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    }

    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ElementGetAttributeNode$LWS(this, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect old attribute.
        ElementRemoveAttributeNode$LWS(this, oldAttr$LWS);
      }

      const attrValue$LWS = AttrValueGetter$LWS(attr$LWS);
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ElementGetAttributeNode$LWS(this, attrName$LWS);

      if (newAttr$LWS) {
        // Remove distorted attribute.
        ElementRemoveAttributeNode$LWS(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = AttrValueGetter$LWS(newAttr$LWS); // Set the distorted attr value.

        AttrValueSetter$LWS(attr$LWS, newValue$LWS); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNode$LWS, this, [attr$LWS]);
      }

      return undefined;
    }

    return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
  }

  return [originalSetAttributeNode$LWS, setAttributeNode$LWS];
}

function distortionElementSetAttributeNodeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNodeNS: originalSetAttributeNodeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNodeNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (AttrOwnerElementGetter$LWS(attr$LWS)) {
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    }

    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ElementGetAttributeNodeNS$LWS(this, attrNamespace$LWS, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect the old attribute.
        ElementRemoveAttributeNode$LWS(this, oldAttr$LWS);
      }

      const attrValue$LWS = toString$LWS(AttrValueGetter$LWS(attr$LWS));
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ElementGetAttributeNodeNS$LWS(this, attrNamespace$LWS, attrName$LWS);

      if (newAttr$LWS) {
        // Remove the distorted attribute.
        ElementRemoveAttributeNode$LWS(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = AttrValueGetter$LWS(newAttr$LWS); // Set the distorted attr value.

        AttrValueSetter$LWS(attr$LWS, newValue$LWS); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }

      return null;
    }

    return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
  }

  return [originalSetAttributeNodeNS$LWS, setAttributeNodeNS$LWS];
}

function distortionElementSetAttributeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNS: originalSetAttributeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNS$LWS(...args$LWS) {
    if (args$LWS.length < 3) {
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
      return;
    }

    const {
      1: qualifiedName$LWS
    } = args$LWS;
    const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
    const attrNamespace$LWS = toStringIfNotNullOrUndefined$LWS(args$LWS[0]);
    const attrValue$LWS = toString$LWS(args$LWS[2]);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      return;
    }

    args$LWS[0] = attrNamespace$LWS;
    args$LWS[1] = attrName$LWS;
    args$LWS[2] = attrValue$LWS;
    ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
  }

  return [originalSetAttributeNS$LWS, setAttributeNS$LWS];
}

function distortionElementShadowRootGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'shadowRoot');

  function shadowRoot$LWS() {
    return null;
  }

  return [originalShadowRootGetter$LWS, shadowRoot$LWS];
}

function distortionElementToggleAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    hasAttribute: ElementProtoHasAttribute$LWS,
    toggleAttribute: originalToggleAttribute$LWS
  } = Element$LWS.prototype;

  const toggleAttribute$LWS = function toggleAttribute$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 0) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely, if the distortion throws.

        ReflectApply$LWS(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to return true | false, based on
        // the presense or absense of this attribute.

        return ReflectApply$LWS(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
      }

      args$LWS[0] = attrName$LWS;
    }

    return ReflectApply$LWS(originalToggleAttribute$LWS, this, args$LWS);
  };

  return [originalToggleAttribute$LWS, toggleAttribute$LWS];
}

function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = EventCurrentTargetGetter$LWS(event$LWS);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$LWS(originalComposedPath$LWS, event$LWS, []);
  const indexOfcurrentTarget$LWS = ArrayIndexOf$LWS(rawComposedPath$LWS, currentTarget$LWS);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = indexOfcurrentTarget$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ArraySlice$LWS(rawComposedPath$LWS, i$LWS + 1);
      break;
    }
  }

  return distortedComposedPath$LWS;
}

function distortionEventComposedPath$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const {
    composedPath: originalComposedPath$LWS
  } = Event$LWS.prototype;

  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }

  return [originalComposedPath$LWS, composedPath$LWS];
}

function distortionEventPathGetter$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return null;
  }

  const path$LWS = function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  };

  return [originalPathGetter$LWS, path$LWS];
}

function distortionEventTargetAddEventListener$LWS(globalObject$LWS, options$LWS) {
  const {
    EventTarget: EventTarget$LWS
  } = globalObject$LWS;
  const {
    addEventListener: originalAddEventListener$LWS
  } = EventTarget$LWS.prototype;

  function addEventListener$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Ensure that we fallback to the default platform behavior which
    // should fail if less than 2 arguments are provided.

    if (length$LWS > 1) {
      const {
        0: eventName$LWS
      } = args$LWS;

      if (isEventTargetRestricted$LWS(this, eventName$LWS, options$LWS)) {
        var _safeDesc$LWS;

        const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(this.constructor, 'name');
        let safeDesc$LWS;

        if (unsafeDesc$LWS) {
          safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
        }

        const name$LWS = (_safeDesc$LWS = safeDesc$LWS) == null ? void 0 : _safeDesc$LWS.value;
        let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;

        if (typeof name$LWS === 'string') {
          exceptionMessage$LWS += ` to ${name$LWS} object`;
        }

        throw new LockerSecurityError$LWS(`${exceptionMessage$LWS}.`);
      }
    }

    return ReflectApply$LWS(originalAddEventListener$LWS, this, args$LWS);
  }

  return [originalAddEventListener$LWS, addEventListener$LWS];
}

function distortionHistoryPushState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    pushState: originalPushState$LWS
  } = History$LWS.prototype;

  function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPushState$LWS, this, args$LWS);
  }

  return [originalPushState$LWS, pushState$LWS];
}

function distortionHistoryReplaceState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    replaceState: originalReplaceState$LWS
  } = History$LWS.prototype;

  function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalReplaceState$LWS, this, args$LWS);
  }

  return [originalReplaceState$LWS, replaceState$LWS];
}

function distortionHTMLElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionHTMLElementInnerTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText');

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  const innerText$LWS = function innerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalInnerTextSetter$LWS, this, [value$LWS]);
  };

  return [originalInnerTextSetter$LWS, innerText$LWS];
} // outerText is not a standard property, so the descriptor could be undefined, like in the case
// of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility


function distortionHTMLElementOuterTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText');

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  const outerText$LWS = function outerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalOuterTextSetter$LWS, this, [value$LWS]);
  };

  return [originalOuterTextSetter$LWS, outerText$LWS];
}

function distortionHTMLElementStyleGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionHTMLFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLIFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementSrcSetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');

  function src$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
    }

    HTMLIFrameElementSrcSetter$LWS(this, urlString$LWS);
  }

  registerElementSetDistortion$LWS(HTMLIFrameElement$LWS, {
    attributeName: 'src',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

const IMPORT$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return !RegExpTest$LWS(IMPORT$LWS, value$LWS);
}

function distortionHTMLLinkElementRelSetter$LWS(globalObject$LWS) {
  const {
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const string$LWS = toString$LWS(value$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  registerElementSetDistortion$LWS(HTMLLinkElement$LWS, {
    attributeName: 'rel',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: rel$LWS
  });
  return [originalRelSetter$LWS, rel$LWS];
}

function distortionHTMLLinkElementRelListSetter$LWS(globalObject$LWS) {
  const {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');

  function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? DOMTokenListValueGetter$LWS(relListValue$LWS) : toString$LWS(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  return [originalRelListSetter$LWS, relList$LWS];
}

function distortionHTMLObjectElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLObjectElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLObjectElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLObjectElement$LWS.prototype, 'contentWindow'); // contentWindow is not supported on object elements in iOS < 13.
  // https://caniuse.com/mdn-api_htmlobjectelement_contentwindow

  if (typeof originalContentWindowGetter$LWS !== 'function') {
    return null;
  }

  const contentWindow$LWS = function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  };

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = HTMLElementDatasetGetter$LWS(el$LWS);
  const distortedSrc$LWS = ObjectLookupOwnValue$LWS(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function distortionHTMLScriptElementSrcGetter$LWS(globalObject$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLScriptElement$LWS.prototype, 'src');

  function src$LWS() {
    return getDatasetSrcValue$LWS(this) || ReflectApply$LWS(originalSrcGetter$LWS, this, []);
  }

  return [originalSrcGetter$LWS, src$LWS];
}

function abstractFactoryValueThrower$LWS(proto$LWS, propName$LWS) {
  return function valueThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const {
      [propName$LWS]: originalValue$LWS
    } = proto$LWS;

    function value$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalValue$LWS, value$LWS];
  };
}

function abstractFactoryGetThrower$LWS(proto$LWS, propName$LWS) {
  return function getThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalGet$LWS = ObjectLookupOwnGetter$LWS(proto$LWS, propName$LWS);

    function get$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalGet$LWS, get$LWS];
  };
}

function abstractFactorySetThrower$LWS(proto$LWS, propName$LWS) {
  return function setThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, propName$LWS);

    function set$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalSet$LWS, set$LWS];
  };
}
/**
 * Wraps the source content of a script tag in the evaluator
 * Creates a blob: url with the wrapped content
 * @param text String
 * @param key String
 * @returns String
 */


function createScriptUrl$LWS(text$LWS, key$LWS) {
  const transformedText$LWS = transformUncompiledSource$LWS(text$LWS);
  const payload$LWS = WindowEncodeURIComponent$LWS(transformedText$LWS);
  const blobScript$LWS = `
    {
        const { $evaluator$ } = document.currentScript;
        const text = decodeURIComponent(\`${payload$LWS}\`);
        delete document.currentScript.$evaluator$;
        $evaluator$('${key$LWS}', text, { ${UNCOMPILED_LOCATION_NAME$LWS}: location });
    }`;
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([blobScript$LWS], {
    type: 'text/javascript'
  }));
}

function scriptDistortion$LWS(attributeName$LWS, options$LWS, datasetGetter$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const normalizerAnchor$LWS = DocumentCreateElement$LWS(document, 'a');
  return function distortion$LWS(value$LWS) {
    const originalValue$LWS = value$LWS;
    const elementNamespaceURI$LWS = ElementGetNamespaceURI$LWS(this);
    const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;

    if (value$LWS === '') {
      ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, value$LWS);
      return;
    } // Normalize Value


    HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, value$LWS);
    value$LWS = HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS); // Create Synthetic Attribute

    const dataset$LWS = datasetGetter$LWS(this);
    dataset$LWS[`distorted${capitalizeFirstChar$LWS(attributeName$LWS)}`] = originalValue$LWS; // Create XHR

    const hostname$LWS = HTMLAnchorElementHostnameGetter$LWS(normalizerAnchor$LWS);
    const xhr$LWS = new XhrCtor$LWS();

    if (StringMatch$LWS(hostname$LWS, TRUSTED_DOMAINS$LWS)) {
      XhrWithCredentialsSetter$LWS(xhr$LWS, true);
    }

    EventTargetAddEventListener$LWS(xhr$LWS, 'load', () => {
      const status$LWS = XhrStatusGetter$LWS(xhr$LWS);

      if (status$LWS === 200) {
        const responseText$LWS = XhrResponseTextGetter$LWS(xhr$LWS);
        ReflectDefineProperty$LWS(this, '$evaluator$', {
          __proto__: null,
          configurable: true,
          value: evaluator$LWS
        });
        ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, createScriptUrl$LWS(responseText$LWS, key$LWS));
      } else if (status$LWS === 404) {
        ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found');
      }
    });
    XhrOpen$LWS(xhr$LWS, 'GET', value$LWS);
    XhrSend$LWS(xhr$LWS);
  };
}

function distortBlockedProperties$LWS(proto$LWS, propertyList$LWS) {
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = propertyList$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = propertyList$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;

        if (getter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactoryGetThrower$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactorySetThrower$LWS(proto$LWS, prop$LWS);
        }
      } else if (typeof value$LWS === 'function') {
        entries$LWS[entriesOffset$LWS++] = abstractFactoryValueThrower$LWS(proto$LWS, prop$LWS);
      }
    }
  }

  return entries$LWS;
}

function distortBlockedAttributes$LWS(ctor$LWS, attributes$LWS, elNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attributeName$LWS = attributes$LWS[i$LWS];
    const {
      name: ctorName$LWS
    } = ctor$LWS;
    registerElementSetDistortion$LWS(ctor$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: elNamespace$LWS,

      distortion() {
        throw new LockerSecurityError$LWS(`Attribute "${attributeName$LWS}" not allowed on ${ctorName$LWS}.`);
      }

    });
  }
}

function maybeMaskDistortion$LWS(distortedValue$LWS, rawValue$LWS) {
  if (typeof distortedValue$LWS === 'function' && typeof rawValue$LWS === 'function') {
    return maskDistortion$LWS(distortedValue$LWS, rawValue$LWS);
  }

  return distortedValue$LWS;
}

function distortionHTMLScriptElementSrcSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLScriptElement$LWS.prototype, 'src');
  const src$LWS = scriptDistortion$LWS('src', options$LWS, HTMLElementDatasetGetter$LWS);
  registerElementSetDistortion$LWS(HTMLScriptElement$LWS, {
    attributeName: 'src',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

function distortionIDBObjectStoreAdd$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    add: originalAdd$LWS
  } = IDBObjectStore$LWS.prototype;

  function add$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalAdd$LWS, this, args$LWS);
  }

  return [originalAdd$LWS, add$LWS];
}

function distortionIDBObjectStorePut$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    put: originalPut$LWS
  } = IDBObjectStore$LWS.prototype;

  function put$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPut$LWS, this, args$LWS);
  }

  return [originalPut$LWS, put$LWS];
}

function distortionMessageEventSourceGetter$LWS(globalObject$LWS) {
  const {
    MessageEvent: MessageEvent$LWS
  } = globalObject$LWS;
  const originalSourceGetter$LWS = ObjectLookupOwnGetter$LWS(MessageEvent$LWS.prototype, 'source');

  function source$LWS() {
    const rawSource$LWS = ReflectApply$LWS(originalSourceGetter$LWS, this, []);
    return toString$LWS(rawSource$LWS) === '[object Window]' ? getPatchedWindow$LWS(rawSource$LWS) : rawSource$LWS;
  }

  return [originalSourceGetter$LWS, source$LWS];
}

function distortionNamedNodeMapSetNamedItem$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItem: originalSetNamedItem$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItem$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetNamedItem$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItem$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItem$LWS, setNamedItem$LWS];
}

function distortionNamedNodeMapSetNamedItemNS$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItemNS: originalSetNamedItemNS$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItemNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetNamedItemNS$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItemNS$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItemNS$LWS, setNamedItemNS$LWS];
}

function distortionNavigatorSendBeacon$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const {
    sendBeacon: originalSendBeacon$LWS
  } = Navigator$LWS.prototype;

  function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: url$LWS
      } = args$LWS;
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return ReflectApply$LWS(originalSendBeacon$LWS, this, args$LWS);
  }

  return [originalSendBeacon$LWS, sendBeacon$LWS];
}

function distortionNavigatorServiceWorkerGetter$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS(Navigator$LWS.prototype, 'serviceWorker');

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS() {
    return undefined;
  };

  return [originalServiceWorkerGetter$LWS, get$LWS];
}

function distortionNodeInsertBefore$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    insertBefore: originalInsertBefore$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${toString$LWS(argValue$LWS.nodeName)} into ${toString$LWS(this.nodeName)},`);
      }
    }

    return ReflectApply$LWS(originalInsertBefore$LWS, this, args$LWS);
  }

  return [originalInsertBefore$LWS, insertBefore$LWS];
}

function distortionAttrNodeValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');

  function nodeValue$LWS(value$LWS) {
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the nodeValue property.
    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

      if (ownerElement$LWS === null) {
        return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
      }

      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [value$LWS]);
      }
    }

    return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
  }

  return [originalNodeValueSetter$LWS, nodeValue$LWS];
}

function distortionNodeRemoveChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    removeChild: originalRemoveChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${toString$LWS(argValue$LWS.nodeName)}.`);
      }
    }

    return ReflectApply$LWS(originalRemoveChild$LWS, this, args$LWS);
  }

  return [originalRemoveChild$LWS, removeChild$LWS];
}

function distortionNodeReplaceChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    replaceChild: originalReplaceChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments. If the "old element"
    // argument is a valid shared element, an exception is thrown.
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        1: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${toString$LWS(argValue$LWS.nodeName)}.`);
      }
    }

    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChild$LWS];
}

function distortionNodeTextContentSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalTextContentSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'textContent'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function textContent$LWS(value$LWS) {
    const valueString$LWS = toString$LWS(value$LWS); // There are two existence of the attribute textContent, one on Attr and one on Node.
    // This first if statement is checking to figure out which distortion should be applied.
    // The instanceof operator tests to see if the current global object, this, is of the type Attr,
    // while also taking inheritance into consideration.
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the textContent property.

    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

      if (ownerElement$LWS === null) {
        return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueString$LWS]);
      }

      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [valueString$LWS]);
      }
    }

    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set textContent of ${toString$LWS(this.nodeName)} elements.`);
    }

    return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueString$LWS]);
  }

  return [originalTextContentSetter$LWS, textContent$LWS];
}

function distortionNotificationCtor$LWS(globalObject$LWS) {
  const {
    Notification: originalNotificationCtor$LWS
  } = globalObject$LWS;

  if (typeof originalNotificationCtor$LWS !== 'function') {
    return null;
  }

  const Notification$LWS = function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = partialStructuredClone$LWS(args$LWS[1]);
    }

    return ReflectApply$LWS(originalNotificationCtor$LWS, this, args$LWS);
  };

  return [originalNotificationCtor$LWS, Notification$LWS];
}

function distortionRangeCreateContextualFragment$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    createContextualFragment: originalCreateContextualFragment$LWS
  } = Range$LWS.prototype;

  function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = sanitize$LWS(tagString$LWS);
      }
    }

    return ReflectApply$LWS(originalCreateContextualFragment$LWS, this, args$LWS);
  }

  return [originalCreateContextualFragment$LWS, createContextualFragment$LWS];
}

function distortionRangeDeleteContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    deleteContents: originalDeleteContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function deleteContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = ReflectApply$LWS(originalCloneContents$LWS, this, []);
    const elementFound$LWS = DocumentFragmentQuerySelector$LWS(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new LockerSecurityError$LWS(`Cannot delete contents of ${elementFound$LWS.nodeName}.`);
    }

    return ReflectApply$LWS(originalDeleteContents$LWS, this, args$LWS);
  }

  return [originalDeleteContents$LWS, deleteContents$LWS];
}

function distortionRangeExtractContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    extractContents: originalExtractContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function extractContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = ReflectApply$LWS(originalCloneContents$LWS, this, []);
    const elementFound$LWS = DocumentFragmentQuerySelector$LWS(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new LockerSecurityError$LWS(`Cannot extract contents of ${elementFound$LWS.nodeName}.`);
    }

    return ReflectApply$LWS(originalExtractContents$LWS, this, args$LWS);
  }

  return [originalExtractContents$LWS, extractContents$LWS];
}

function distortionRangeInsertNode$LWS(globalObject$LWS) {
  // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    insertNode: originalInsertNode$LWS
  } = Range$LWS.prototype;
  const originalCommonAncestorContainer$LWS = ObjectLookupOwnGetter$LWS(Range$LWS.prototype, 'commonAncestorContainer');

  function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;
      const commonAncestorContainer$LWS = ReflectApply$LWS(originalCommonAncestorContainer$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${commonAncestorContainer$LWS.nodeName}.`);
      }
    }

    return ReflectApply$LWS(originalInsertNode$LWS, this, args$LWS);
  }

  return [originalInsertNode$LWS, insertNode$LWS];
}

function distortionServiceWorkerContainer$LWS(globalObject$LWS) {
  const {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  } = globalObject$LWS;

  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionShadowRootInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');

  function innerHTML$LWS(value$LWS) {
    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionShadowRootModeGetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalModeGetter$LWS = ObjectLookupOwnGetter$LWS(ShadowRoot$LWS.prototype, 'mode');

  function mode$LWS() {
    return 'closed';
  }

  return [originalModeGetter$LWS, mode$LWS];
}

function distortionSharedWorkerCtor$LWS(globalObject$LWS) {
  const {
    SharedWorker: originalSharedWorkerCtor$LWS
  } = globalObject$LWS;

  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return null;
  }

  const SharedWorker$LWS = function SharedWorker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toString$LWS(scriptURL$LWS)}.`);
  };

  return [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
}

function distortionSharedWorkerProto$LWS(globalObject$LWS) {
  const {
    SharedWorker: SharedWorker$LWS
  } = globalObject$LWS;

  if (typeof SharedWorker$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (StringStartsWith$LWS(key$LWS, storageRootKey$LWS)) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = new ArrayCtor$LWS(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = StringReplace$LWS(key$LWS, storageRootKey$LWS, '');
  }

  return keys$LWS;
}

const meta$LWS = new WeakMap();

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = WeakMapGet$LWS(meta$LWS, storage$LWS);

  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(s$LWS) {
  return new Proxy(s$LWS, {
    get(target$LWS, key$LWS, receiver$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwnProperty$LWS(storage$LWS, keyForNamespace$LWS)) {
        return ReflectGet$LWS(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, descriptor$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const safeDesc$LWS = toSafeDescriptor$LWS(descriptor$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDefineProperty$LWS(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDeleteProperty$LWS(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, keyForNamespace$LWS);
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },

    has(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwnProperty$LWS(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return ReflectHas$LWS(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
}

class PatchedStorage$LWS {
  constructor() {
    throw new LockerSecurityError$LWS('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return StringReplace$LWS(resolvedKey$LWS, storageRootKey$LWS, '');
    }

    return ReflectApply$LWS(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    return ReflectApply$LWS(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
      args$LWS[1] = toString$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const target$LWS = {
    __proto__: PatchedStorage$LWS.prototype
  };
  markLiveObject$LWS(target$LWS);
  const proxy$LWS = createStorageProxy$LWS(target$LWS);
  const storageMeta$LWS = {
    proxy: proxy$LWS,
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  };
  WeakMapSet$LWS(meta$LWS, proxy$LWS, storageMeta$LWS);
  WeakMapSet$LWS(meta$LWS, target$LWS, storageMeta$LWS);
  return proxy$LWS;
}

const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorage$LWS.prototype;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS(PatchedStorage$LWS.prototype, 'length');

function createDistortionStorageFactory$LWS(storageName$LWS) {
  return function distortionStorageFactory$LWS(globalObject$LWS, options$LWS) {
    const storageObject$LWS = globalObject$LWS[storageName$LWS];

    if (!isObject$LWS(storageObject$LWS)) {
      return null;
    }

    const {
      key: key$LWS
    } = options$LWS;
    const rootKey$LWS = getStorageRootKey$LWS(key$LWS);
    const patchedStorageObject$LWS = createStorage$LWS(storageObject$LWS, rootKey$LWS);
    return [storageObject$LWS, patchedStorageObject$LWS];
  };
}

function distortionStorageLength$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(Storage$LWS.prototype, 'length');
  return [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
}

function distortionStorageGetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    getItem: originalStorageGetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
}

function distortionStorageSetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    setItem: originalStorageSetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
}

function distortionStorageKey$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    key: originalStorageKey$LWS
  } = Storage$LWS.prototype;
  return [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
}

function distortionStorageRemoveItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    removeItem: originalStorageRemoveItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
}

function distortionStorageClear$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    clear: originalStorageClear$LWS
  } = Storage$LWS.prototype;
  return [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
}

function distortionStorage$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  return [Storage$LWS, PatchedStorage$LWS];
}

const distortionLocalStorage$LWS = createDistortionStorageFactory$LWS('localStorage');
const distortionSessionStorage$LWS = createDistortionStorageFactory$LWS('sessionStorage');

function distortionSVGAnimateElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ElementHasAttribute$LWS(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = ElementGetAttribute$LWS(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'from');
      distortAttribute$LWS(this, 'to');
      distortAttribute$LWS(this, 'values');
    }
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGAnimateElementFromAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function from$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'from',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: from$LWS
  });
  return null;
}

function distortionSVGAnimateElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'to',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: to$LWS
  });
  return null;
}

function distortionSVGAnimateElementValuesAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      const valuesSplit$LWS = StringSplit$LWS(value$LWS, ';');
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = ArrayJoin$LWS(valuesSplit$LWS, ';');
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'values',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: values$LWS
  });
  return null;
}

function distortionSVGElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionSVGScriptElementHrefAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'href',
    attributeNamespace: NAMESPACE_XLINK$LWS,
    distortion: scriptDistortion$LWS('href', options$LWS, SVGElementDatasetGetter$LWS)
  });
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'xlink:href',
    attributeNamespace: NAMESPACE_XLINK$LWS,
    distortion: scriptDistortion$LWS('xlink:href', options$LWS, SVGElementDatasetGetter$LWS)
  });
  return null;
}

function distortionSVGSetElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ElementHasAttribute$LWS(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = ElementGetAttribute$LWS(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'to');
    }
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGSetElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'to',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: to$LWS
  });
  return null;
}

function createDistortionHrefAttributeFactory$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactory$LWS(globalObject$LWS) {
    const {
      SVGUseElement: SVGUseElement$LWS
    } = globalObject$LWS;
    const {
      setAttribute: originalSetAttribute$LWS,
      setAttributeNS: originalSetAttributeNS$LWS
    } = Element.prototype;

    if (attributeName$LWS === 'href') {
      const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
        ReflectApply$LWS(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
      };

      registerElementSetDistortion$LWS(SVGUseElement$LWS, {
        attributeName: attributeName$LWS,
        attributeNamespace: NAMESPACE_DEFAULT$LWS,
        distortion: defaultNamespaceDistortion$LWS
      });
    }

    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }

    registerElementSetDistortion$LWS(SVGUseElement$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: NAMESPACE_XLINK$LWS,
      distortion: xlinkNamespaceDistortion$LWS
    });
    return null;
  };
}

const distortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('href');
const distortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('xlink:href');

function distortionTrustedTypePolicyFactoryCreatePolicy$LWS(globalObject$LWS) {
  const {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  } = globalObject$LWS;

  if (typeof TrustedTypePolicyFactory$LWS !== 'function') {
    return null;
  }

  const {
    createPolicy: originalCreatePolicy$LWS
  } = TrustedTypePolicyFactory$LWS.prototype;

  const createPolicy$LWS = function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    }

    return ReflectApply$LWS(originalCreatePolicy$LWS, this, args$LWS);
  };

  return [originalCreatePolicy$LWS, createPolicy$LWS];
}

const HTML_MIME_TYPES$LWS = ['text/html', 'image/svg+xml', 'text/xml'];

function distortionURLCreateObjectURL$LWS(globalObject$LWS) {
  const {
    URL: URL$LWS
  } = globalObject$LWS;
  const {
    createObjectURL: originalCreateObjectURL$LWS
  } = URL$LWS;
  const {
    isEqualDomString: isEqualDomString$LWS,
    isMediaSourceObject: isMediaSourceObject$LWS
  } = getValidator$LWS(globalObject$LWS);

  function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [blobObject$LWS]); // MediaSource does not share the same proto object as Blob or File.
    // It can still be used with createObjectURL however we need to treat it separately.
    // MediaSource does not accept plain text input as Blob and File and does not have a MIME type.

    if (isMediaSourceObject$LWS(blobObject$LWS)) {
      return outURL$LWS;
    }

    const type$LWS = BlobTypeGetter$LWS(blobObject$LWS);

    if (type$LWS === '') {
      // browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      return ReflectApply$LWS(originalCreateObjectURL$LWS, this, [BlobSlice$LWS(blobObject$LWS, 0, undefined, 'text/plain')]);
    }

    if (ArrayIncludes$LWS(HTML_MIME_TYPES$LWS, type$LWS)) {
      const normalizedBlob$LWS = BlobSlice$LWS(blobObject$LWS, 0, BlobSizeGetter$LWS(blobObject$LWS), `${type$LWS};charset=utf-8`);
      URLRevokeObjectURL$LWS(outURL$LWS);
      outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new XhrCtor$LWS();
      XhrOpen$LWS(xhr$LWS, 'GET', outURL$LWS, false);
      XhrSend$LWS(xhr$LWS);
      const sanitizer$LWS = blobSanitizer$LWS();
      const responseText$LWS = XhrResponseTextGetter$LWS(xhr$LWS);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS(`Cannot "createObjectURL" using a unsecure ${toString$LWS(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (isMIMETypeAllowed$LWS(type$LWS)) {
      return outURL$LWS;
    }

    URLRevokeObjectURL$LWS(outURL$LWS);
    throw new LockerSecurityError$LWS('Unsupported MIME type.');
  }

  return [originalCreateObjectURL$LWS, createObjectURL$LWS];
}

function distortionWindowFetch$LWS(globalObject$LWS) {
  const {
    fetch: originalFetch$LWS
  } = globalObject$LWS;

  function fetch$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(RequestURLGetter$LWS(url$LWS));
      } else {
        parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toString$LWS(url$LWS)}.`));
      }
    }

    return ReflectApply$LWS(originalFetch$LWS, this, args$LWS);
  }

  return [originalFetch$LWS, fetch$LWS];
}
/* eslint-disable class-methods-use-this, max-classes-per-file */


function distortionWindowFramesGetter$LWS(globalObject$LWS) {
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'frames');

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return null;
  }

  let framesProxy$LWS;

  const frames$LWS = function frames$LWS() {
    if (!framesProxy$LWS) {
      const integerRegExp$LWS = /^0$|^[1-9][0-9]*$/;
      const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS(globalObject$LWS);
      const WindowProperties$LWS = ReflectGetPrototypeOf$LWS(WindowPrototype$LWS);

      const getFrameByIndexKey$LWS = key$LWS => {
        if (isFrameIndexKey$LWS(key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return getPatchedWindow$LWS(value$LWS);
          }
        }

        return undefined;
      };

      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
        !ObjectHasOwnProperty$LWS(globalObject$LWS, key$LWS) && // ...Or its prototype.
        !ObjectHasOwnProperty$LWS(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return getPatchedWindow$LWS(value$LWS);
          }
        }

        return undefined;
      };

      const getValueByKey$LWS = key$LWS => {
        if (key$LWS === 'length') {
          return WindowLengthGetter$LWS(globalObject$LWS);
        }

        if (isFrameIndexKey$LWS(key$LWS)) {
          return getFrameByIndexKey$LWS(key$LWS);
        }

        return undefined;
      };

      const isFrame$LWS = value$LWS => value$LWS !== undefined && value$LWS !== globalObject$LWS && isWindowLike$LWS(value$LWS) && isWindow$LWS(value$LWS);

      const isFrameIndexKey$LWS = key$LWS => RegExpTest$LWS(integerRegExp$LWS, key$LWS) && key$LWS < WindowLengthGetter$LWS(globalObject$LWS); // The rules for this proxy are as follows:
      //
      // If the key is a string...
      //      ...And the key is a valid index that matches an existing
      //      index in the frame list or matches the value of a name
      //      property of a frame in the frame list, then return the
      //      appropriate frame from the frame list.
      //
      //      ...Or the key's value is "length", then return the number of
      //      frames in the in the frame list.
      //  Else,
      //      ...Return the value of the key from the shadow target


      class BaseFrameHandler$LWS {
        defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
          return false;
        }

        deleteProperty(_target$LWS, _key$LWS) {
          return false;
        }

        getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
          return undefined;
        }

        isExtensible(_target$LWS) {
          return true;
        }

        ownKeys(_target$LWS) {
          return [];
        }

        preventExtensions(_target$LWS) {
          return true;
        }

        set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
          return false;
        }

        setPrototypeOf(_target$LWS) {
          return false;
        }

      }

      ReflectSetPrototypeOf$LWS(BaseFrameHandler$LWS.prototype, null);
      ObjectFreeze$LWS(BaseFrameHandler$LWS.prototype);

      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.length
          // window.frames[n]
          // window.frames['n']
          const value$LWS = getValueByKey$LWS(key$LWS);

          if (value$LWS !== undefined) {
            return value$LWS;
          } // window.frames.foo when iframe.name is 'foo'


          return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              configurable: true,
              enumerable: true,

              get() {
                return getValueByKey$LWS('length');
              },

              set(_v$LWS) {}

            };
          }

          const value$LWS = isFrameIndexKey$LWS(key$LWS) ? getFrameByIndexKey$LWS(key$LWS) : undefined;

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getValueByKey$LWS(key$LWS) !== undefined || ReflectHas$LWS(target$LWS, key$LWS);
        }

        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = ArrayCtor$LWS(length$LWS + 1);

          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }

          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }

      }

      class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.foo when iframe.name is 'foo'
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ? ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getFrameByNameKey$LWS(key$LWS) !== undefined || ReflectHas$LWS(target$LWS, key$LWS);
        }

        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const descMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
          ReflectSetPrototypeOf$LWS(descMap$LWS, null);

          for (const key$LWS in descMap$LWS) {
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = descMap$LWS[key$LWS];

              if (ObjectHasOwnProperty$LWS(unsafeDesc$LWS, 'value') && isFrame$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }

          return keys$LWS;
        }

      } // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.


      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = ObjectFreeze$LWS(new ShadowFrameHandler$LWS());
      const shadowFramesPrototypeHandler$LWS = ObjectFreeze$LWS(new ShadowFramesPrototypeHandler$LWS());
      const shadowWindowPropertiesHandler$LWS = ObjectFreeze$LWS(new ShadowWindowPropertiesHandler$LWS());
      const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      ReflectSetPrototypeOf$LWS(shadowFrames$LWS, framesPrototypeProxy$LWS);
      ReflectSetPrototypeOf$LWS(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      framesProxy$LWS = new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
    }

    return framesProxy$LWS;
  };

  return [originalWindowFramesGetter$LWS, frames$LWS];
}

function distortionWindowGetComputedStyle$LWS(globalObject$LWS) {
  const {
    getComputedStyle: originalGetComputedStyle$LWS
  } = globalObject$LWS;

  function getComputedStyle$LWS(...args$LWS) {
    return toLiveValue$LWS(ReflectApply$LWS(originalGetComputedStyle$LWS, this, args$LWS));
  }

  return [originalGetComputedStyle$LWS, getComputedStyle$LWS];
}

function distortionWindowLengthGetter$LWS(globalObject$LWS) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'length');

  if (typeof originalLengthGetter$LWS !== 'function') {
    return null;
  }

  const length$LWS = function length$LWS() {
    return 0;
  };

  return [originalLengthGetter$LWS, length$LWS];
}

function distortionWindowOnstorage$LWS(globalObject$LWS, options$LWS) {
  const {
    Window: Window$LWS
  } = globalObject$LWS;
  const originalOnstorageSetter$LWS = ObjectLookupOwnSetter$LWS(globalObject$LWS, 'onstorage');

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return null;
  }

  const onstorage$LWS = function onstorage$LWS() {
    throw new LockerSecurityError$LWS('Cannot set window.onstorage.');
  };

  registerEventTargetRestriction$LWS(Window$LWS, 'storage', options$LWS);
  return [originalOnstorageSetter$LWS, onstorage$LWS];
}

function distortionWindowOpen$LWS(globalObject$LWS) {
  const {
    open: originalWindowOpen$LWS
  } = globalObject$LWS;

  function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    const rawOpenWindow$LWS = ReflectApply$LWS(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
    return getPatchedWindow$LWS(rawOpenWindow$LWS);
  }

  return [originalWindowOpen$LWS, open$LWS];
}

function distortionWindowOpenerGetter$LWS(globalObject$LWS) {
  const originalOpenerGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'opener');

  if (typeof originalOpenerGetter$LWS !== 'function') {
    return null;
  }

  const opener$LWS = function opener$LWS() {
    const rawOpener$LWS = ReflectApply$LWS(originalOpenerGetter$LWS, globalObject$LWS, []);
    return getPatchedWindow$LWS(rawOpener$LWS);
  };

  return [originalOpenerGetter$LWS, opener$LWS];
}

function distortionWindowParentGetter$LWS(globalObject$LWS) {
  const originalParentGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'parent');

  if (typeof originalParentGetter$LWS !== 'function') {
    return null;
  }

  const parent$LWS = function parent$LWS() {
    const rawParentWindow$LWS = ReflectApply$LWS(originalParentGetter$LWS, globalObject$LWS, []);
    return getPatchedWindow$LWS(rawParentWindow$LWS);
  };

  return [originalParentGetter$LWS, parent$LWS];
}

function distortionWindowPostMessage$LWS(globalObject$LWS) {
  return [globalObject$LWS.postMessage, getPatchedPostMessage$LWS(globalObject$LWS)];
}

function distortionWindowSetInterval$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setInterval: originalSetInterval$LWS
  } = globalObject$LWS;

  function setInterval$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetInterval$LWS, this, args$LWS);
  }

  return [originalSetInterval$LWS, setInterval$LWS];
}

function distortionWindowSetTimeout$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setTimeout: originalSetTimeout$LWS
  } = globalObject$LWS;

  function setTimeout$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetTimeout$LWS, this, args$LWS);
  }

  return [originalSetTimeout$LWS, setTimeout$LWS];
}

function distortionWindowStructuredClone$LWS(globalObject$LWS) {
  const {
    structuredClone: originalStructuredClone$LWS
  } = globalObject$LWS;

  if (typeof originalStructuredClone$LWS !== 'function') {
    return null;
  }

  const structuredClone$LWS = function structuredClone$LWS(...args$LWS) {
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalStructuredClone$LWS, this, args$LWS);
  };

  return [originalStructuredClone$LWS, structuredClone$LWS];
}

function distortionWorkerCtor$LWS(globalObject$LWS) {
  const {
    Worker: originalWorkerCtor$LWS
  } = globalObject$LWS;

  function Worker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create Worker with ${toString$LWS(scriptURL$LWS)}.`);
  }

  return [originalWorkerCtor$LWS, Worker$LWS];
}

function distortionWorkerProto$LWS(globalObject$LWS) {
  const {
    Worker: {
      prototype: originalPrototype$LWS
    }
  } = globalObject$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionXMLHttpRequestOpen$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const {
    open: originalOpen$LWS
  } = XMLHttpRequest$LWS.prototype;

  function open$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  }

  return [originalOpen$LWS, open$LWS];
}

function distortionXMLHttpRequestResponseGetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'response');

  function response$LWS() {
    const rawResponse$LWS = ReflectApply$LWS(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS) : rawResponse$LWS;
  }

  return [originalResponseGetter$LWS, response$LWS];
}

function distortionXMLHttpRequestResponseXMLGetter$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'responseXML');

  function responseXML$LWS() {
    const rawResponseXML$LWS = ReflectApply$LWS(originalResponseXMLGetter$LWS, this, []);
    return sanitizeDocument$LWS(rawResponseXML$LWS);
  }

  return [originalResponseXMLGetter$LWS, responseXML$LWS];
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const fundamentalDistortionFactories$LWS = [// CSSStyleRule
distortionCSSStyleRuleStyleGetter$LWS, // Document
distortionDocumentDomainSetter$LWS, distortionDocumentExecCommand$LWS, distortionDocumentOpen$LWS, // DOMParser
distortionDOMParserParseFromString$LWS, // Element
distortionElementAttachShadow$LWS, distortionElementAttributesGetter$LWS, distortionElementInnerHTMLSetter$LWS, distortionElementOuterHTMLSetter$LWS, distortionElementInsertAdjacentHTML$LWS, distortionElementRemove$LWS, distortionElementReplaceChildren$LWS, distortionElementReplaceWith$LWS, // Event
distortionEventComposedPath$LWS, distortionEventPathGetter$LWS, // EventTarget
distortionEventTargetAddEventListener$LWS, // History
distortionHistoryPushState$LWS, distortionHistoryReplaceState$LWS, // HTMLElement
distortionHTMLElementDatasetGetter$LWS, distortionHTMLElementInnerTextSetter$LWS, distortionHTMLElementOuterTextSetter$LWS, distortionHTMLElementStyleGetter$LWS, // HTMLFrameElement
distortionHTMLFrameElementContentDocumentGetter$LWS, distortionHTMLFrameElementContentWindowGetter$LWS, // HTMLIFrameElement
distortionHTMLIFrameElementSrcSetter$LWS, distortionHTMLIFrameElementContentDocumentGetter$LWS, distortionHTMLIFrameElementContentWindowGetter$LWS, // HTMLLinkElement
distortionHTMLLinkElementRelSetter$LWS, distortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
distortionHTMLObjectElementContentDocumentGetter$LWS, distortionHTMLObjectElementContentWindowGetter$LWS, // HTMLScriptElement
distortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
distortionIDBObjectStoreAdd$LWS, distortionIDBObjectStorePut$LWS, // MessageEvent
distortionMessageEventSourceGetter$LWS, // Navigator
distortionNavigatorSendBeacon$LWS, distortionNavigatorServiceWorkerGetter$LWS, // Node
distortionNodeRemoveChild$LWS, distortionNodeReplaceChild$LWS, distortionAttrNodeValueSetter$LWS, distortionNodeTextContentSetter$LWS, // Notification
distortionNotificationCtor$LWS, // Range
distortionRangeCreateContextualFragment$LWS, distortionRangeDeleteContents$LWS, distortionRangeExtractContents$LWS, distortionRangeInsertNode$LWS, // ServiceWorkerContainer
distortionServiceWorkerContainer$LWS, // ShadowRoot
distortionShadowRootInnerHTMLSetter$LWS, distortionShadowRootModeGetter$LWS, // SharedWorker
distortionSharedWorkerCtor$LWS, distortionSharedWorkerProto$LWS, // Storage
distortionStorageLength$LWS, distortionStorageGetItem$LWS, distortionStorageSetItem$LWS, distortionStorageKey$LWS, distortionStorageRemoveItem$LWS, distortionStorageClear$LWS, distortionStorage$LWS, // SVGAnimateElement
distortionSVGAnimateElementAttributeNameAttribute$LWS, distortionSVGAnimateElementFromAttribute$LWS, distortionSVGAnimateElementToAttribute$LWS, distortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
distortionSVGElementDatasetGetter$LWS, // SVGSetElement
distortionSVGSetElementAttributeNameAttribute$LWS, distortionSVGSetElementToAttribute$LWS, // SVGUseElement
distortionSVGUseElementHrefAttribute$LWS, distortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
distortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
distortionURLCreateObjectURL$LWS, // Window
distortionWindowFetch$LWS, distortionWindowFramesGetter$LWS, distortionWindowGetComputedStyle$LWS, distortionWindowLengthGetter$LWS, distortionWindowOnstorage$LWS, distortionWindowOpen$LWS, distortionWindowOpenerGetter$LWS, distortionWindowParentGetter$LWS, distortionWindowPostMessage$LWS, distortionWindowStructuredClone$LWS, // Worker
distortionWorkerCtor$LWS, distortionWorkerProto$LWS, // XHR
distortionXMLHttpRequestOpen$LWS, distortionXMLHttpRequestResponseGetter$LWS, distortionXMLHttpRequestResponseXMLGetter$LWS];
const fundamentalKeyedDistortionFactories$LWS = [// Aura
distortionAuraUtilGlobalEval$LWS, // Attr
distortionAttrValueSetter$LWS, // CacheStorage
distortionCacheStorageDelete$LWS, distortionCacheStorageHas$LWS, distortionCacheStorageKeys$LWS, distortionCacheStorageMatch$LWS, distortionCacheStorageOpen$LWS, // CookieStore
distortionCookieStoreDelete$LWS, distortionCookieStoreGet$LWS, distortionCookieStoreGetAll$LWS, distortionCookieStoreOnChange$LWS, distortionCookieStoreSet$LWS, // Document
distortionDocumentCookieGetter$LWS, distortionDocumentCookieSetter$LWS, distortionDocumentReplaceChildren$LWS, // CustomElementRegistry
distortionCustomElementRegistryGet$LWS, // Element
distortionElementSetAttribute$LWS, distortionElementSetAttributeNS$LWS, distortionElementSetAttributeNode$LWS, distortionElementSetAttributeNodeNS$LWS, distortionElementToggleAttribute$LWS, // HTMLScriptElement,
distortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
distortionNamedNodeMapSetNamedItem$LWS, distortionNamedNodeMapSetNamedItemNS$LWS, // SVGScriptElement
distortionSVGScriptElementHrefAttribute$LWS, // Window
distortionWindowSetInterval$LWS, distortionWindowSetTimeout$LWS, // Storage
distortionLocalStorage$LWS, distortionSessionStorage$LWS];
const secondaryExternalDistortionFactories$LWS = [// Element
distortionElementAfter$LWS, distortionElementAppend$LWS, distortionElementBefore$LWS, distortionElementInsertAdjacentElement$LWS, distortionElementPrepend$LWS, distortionElementShadowRootGetter$LWS, // Node
// The distortionNodeAppendChild distortion is temporarily disabled until W-10409618 is resolved
// distortionNodeAppendChild,
distortionNodeInsertBefore$LWS];
const secondaryExternalKeyedDistortionFactories$LWS = [];
const secondaryInternalDistortionsFactories$LWS = [];
const secondaryInternalKeyedDistortionFactories$LWS = [];
const externalDistortionFactories$LWS = ArrayConcat$LWS(fundamentalDistortionFactories$LWS, secondaryExternalDistortionFactories$LWS);
const externalKeyedDistortionFactories$LWS = ArrayConcat$LWS(fundamentalKeyedDistortionFactories$LWS, secondaryExternalKeyedDistortionFactories$LWS);
const internalDistortionFactories$LWS = ArrayConcat$LWS(fundamentalDistortionFactories$LWS, secondaryInternalDistortionsFactories$LWS);
const internalKeyedDistortionFactories$LWS = ArrayConcat$LWS(fundamentalKeyedDistortionFactories$LWS, secondaryInternalKeyedDistortionFactories$LWS);
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument']; // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
const externalDistortionCache$LWS = new WeakMapCtor$LWS();
const internalDistortionCache$LWS = new WeakMapCtor$LWS();

function makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    Element: Element$LWS,
    HTMLElement: HTMLElement$LWS,
    HTMLIFrameElement: HTMLIFrameElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XSLTProcessor: XSLTProcessor$LWS
  } = globalObject$LWS;
  const blockedPropertyDistortionFactories$LWS = [];
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(CustomElementRegistry.prototype, CustomElementRegistryBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Document$LWS.prototype, DocumentBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Element$LWS.prototype, ElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS));

  if (typeof XSLTProcessor$LWS === 'function') {
    ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS));
  }

  distortBlockedAttributes$LWS(HTMLElement$LWS, HTMLElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLIFrameElement$LWS, HTMLIFrameElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLScriptElement$LWS, HTMLScriptElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(SVGElement$LWS, SVGElementBlockedAttributes$LWS);
  return blockedPropertyDistortionFactories$LWS;
}

function instrumentDistortionForSandbox$LWS(sandboxKey$LWS, fn$LWS, instrumentation$LWS, verboseInstrumentation$LWS, factoryName$LWS) {
  const {
    error,
    startActivity: startActivity$LWS
  } = instrumentation$LWS;

  if (verboseInstrumentation$LWS) {
    const factoryNameNoMarker$LWS = StringReplace$LWS(factoryName$LWS, LOCKER_IDENTIFIER_MARKER$LWS, '');
    return function verboseInstrumentedDistortionWrapper$LWS(...args$LWS) {
      const activity$LWS = startActivity$LWS(factoryNameNoMarker$LWS, {
        sandboxKey: sandboxKey$LWS
      });

      try {
        return ReflectApply$LWS(fn$LWS, this, args$LWS);
      } catch (e$LWS) {
        error({
          sandboxKey: sandboxKey$LWS,
          error: e$LWS
        });
        throw e$LWS;
      } finally {
        activity$LWS.stop();
      }
    };
  }

  return function instrumentedDistortionWrapper$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS(fn$LWS, this, args$LWS);
    } catch (e$LWS) {
      error({
        sandboxKey: sandboxKey$LWS,
        error: e$LWS
      });
      throw e$LWS;
    }
  };
}

function addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS) {
  const {
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = config$LWS;
  const options$LWS = {
    evaluator: evaluator$LWS,
    key: key$LWS,
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS
  };
  const pair$LWS = factory$LWS(globalObject$LWS, options$LWS);

  if (pair$LWS) {
    const {
      0: rawValue$LWS,
      1: distortedValue$LWS
    } = pair$LWS;

    if (rawValue$LWS) {
      let maybeInstrumentedDistortedValue$LWS = distortedValue$LWS;

      if (typeof distortedValue$LWS === 'function') {
        maybeInstrumentedDistortedValue$LWS = instrumentDistortionForSandbox$LWS(key$LWS, distortedValue$LWS, instrumentation$LWS, !!verboseInstrumentation$LWS, factory$LWS.name || '<unknown>');
      }

      entries$LWS[entries$LWS.length] = [rawValue$LWS, maybeMaskDistortion$LWS(maybeInstrumentedDistortedValue$LWS, rawValue$LWS)];
    }
  }
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages


function createExternalDistortionEntries$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS) {
  const entries$LWS = [];
  const cached$LWS = WeakMapGet$LWS(externalDistortionCache$LWS, globalObject$LWS);

  if (cached$LWS) {
    ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, cached$LWS);
  } else {
    const blockedPropertyDistortions$LWS = makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = blockedPropertyDistortions$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = blockedPropertyDistortions$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    for (let i$LWS = 0, {
      length: length$LWS
    } = externalDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = externalDistortionFactories$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    WeakMapSet$LWS(externalDistortionCache$LWS, globalObject$LWS, shallowCloneArray$LWS(entries$LWS));
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = externalKeyedDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = externalKeyedDistortionFactories$LWS[i$LWS];
    addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
  }

  ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, makeElementDistortionsForSandboxKey$LWS(key$LWS));
  return entries$LWS;
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages


function createInternalDistortionEntries$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS) {
  const entries$LWS = [];
  const cached$LWS = WeakMapGet$LWS(internalDistortionCache$LWS, globalObject$LWS);

  if (cached$LWS) {
    ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, cached$LWS);
  } else {
    const blockedPropertyDistortions$LWS = makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = blockedPropertyDistortions$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = blockedPropertyDistortions$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    for (let i$LWS = 0, {
      length: length$LWS
    } = internalDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = internalDistortionFactories$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    WeakMapSet$LWS(internalDistortionCache$LWS, globalObject$LWS, shallowCloneArray$LWS(entries$LWS));
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = internalKeyedDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = internalKeyedDistortionFactories$LWS[i$LWS];
    addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
  }

  ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, makeElementDistortionsForSandboxKey$LWS(key$LWS));
  return entries$LWS;
}

export { SandboxType$LWS as SandboxType, createExternalDistortionEntries$LWS as createExternalDistortionEntries, createInternalDistortionEntries$LWS as createInternalDistortionEntries };
/*! version: 0.15.16 */
