/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var shared$LWS = require('@locker/shared');

var sharedDom$LWS = require('@locker/shared-dom');

var htmlSanitizer$LWS = require('@locker/html-sanitizer');

var sharedUrl$LWS = require('@locker/shared-url');

const CustomElementRegistryBlockedProperties$LWS = ['define'];
/**
 * this registry is going to be used by Attr, NameNodeMap, setAttribute* distortions
 */

const distortionsBySandboxKeyRegistry$LWS = {
  __proto__: null
}; // An array of factories traversed when we create a new sandbox. The result of
// parsing this registry will be a new registry with initialized distortions.

const factories$LWS = [];

function storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  const {
    [attributeName$LWS]: byAttributeNamespaceRegistry$LWS = {
      __proto__: null
    }
  } = registry$LWS;
  const {
    [attributeNamespace$LWS]: byElementCtor$LWS = new shared$LWS.MapCtor()
  } = byAttributeNamespaceRegistry$LWS;
  shared$LWS.MapSet(byElementCtor$LWS, ElementCtor$LWS, distortion$LWS);
  byAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = byElementCtor$LWS;
  registry$LWS[attributeName$LWS] = byAttributeNamespaceRegistry$LWS;
}

function getAttributeDistortion$LWS(element$LWS, key$LWS, attributeName$LWS, attributeNamespace$LWS = sharedDom$LWS.NAMESPACE_DEFAULT) {
  const {
    [key$LWS]: registry$LWS
  } = distortionsBySandboxKeyRegistry$LWS;
  attributeName$LWS = shared$LWS.StringToLowerCase(attributeName$LWS);
  const byAttributeNamespaceRegistry$LWS = registry$LWS[attributeName$LWS];

  if (!byAttributeNamespaceRegistry$LWS) {
    return undefined;
  }

  const {
    [attributeNamespace$LWS]: byElementCtor$LWS
  } = byAttributeNamespaceRegistry$LWS;

  if (!byElementCtor$LWS) {
    return undefined;
  }

  const mapIterator$LWS = shared$LWS.MapEntries(byElementCtor$LWS); // using a restricted syntax to avoid accessing .next on iterator
  // eslint-disable-next-line no-restricted-syntax

  for (const entry$LWS of mapIterator$LWS) {
    const Ctor$LWS = entry$LWS[0];
    const distortion$LWS = entry$LWS[1]; // element can inherit from Ctor but Ctor
    // may not be the first entry in the proto chain
    // thus element.prototype checks are not sufficient

    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function makeElementDistortionsForSandboxKey$LWS(key$LWS) {
  // This registry is created per sandbox.
  const registry$LWS = {
    __proto__: null
  };
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(registry$LWS);

    if (entry$LWS) {
      entries$LWS[entriesOffset$LWS++] = entry$LWS;
    }
  }

  distortionsBySandboxKeyRegistry$LWS[key$LWS] = registry$LWS;
  return entries$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? sharedDom$LWS.NAMESPACE_DEFAULT : ns$LWS;
}

function registerElementSetDistortion$LWS(ElementCtor$LWS, options$LWS) {
  factories$LWS[factories$LWS.length] = registry$LWS => {
    const {
      attributeNamespace: attributeNamespace$LWS,
      distortion: distortion$LWS
    } = options$LWS;
    const attributeName$LWS = shared$LWS.StringToLowerCase(options$LWS.attributeName);
    storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS);
    return null;
  };
}

function distortionAttrValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalAttrValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Attr$LWS.prototype, 'value');

  function value$LWS(val$LWS) {
    const ownerElement$LWS = sharedDom$LWS.AttrOwnerElementGetter(this);

    if (ownerElement$LWS) {
      const attrName$LWS = sharedDom$LWS.AttrNameGetter(this);
      const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        shared$LWS.ReflectApply(distortion$LWS, ownerElement$LWS, [val$LWS]);
        return;
      }
    }

    shared$LWS.ReflectApply(originalAttrValueSetter$LWS, this, [val$LWS]);
  }

  return [originalAttrValueSetter$LWS, value$LWS];
}

function distortionAuraUtilGlobalEval$LWS(globalObject$LWS, options$LWS) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;

  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval;

  if (typeof originalGlobalEval$LWS !== 'function') {
    return null;
  }

  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS; // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.

  const globalEval$LWS = function globalEval$LWS(src$LWS, descriptor$LWS, type$LWS) {
    let compiled$LWS = `(function s(){return(${src$LWS})})()`;

    if (typeof descriptor$LWS === 'string') {
      const name$LWS = shared$LWS.ArrayPop(shared$LWS.StringSplit(descriptor$LWS, '://'));
      compiled$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${shared$LWS.StringReplace(name$LWS, '.', '/')}` : `/components/${shared$LWS.StringReplace(name$LWS, ':', '/')}.js`);
    }

    return evaluator$LWS(key$LWS, compiled$LWS);
  };

  return [originalGlobalEval$LWS, globalEval$LWS];
}

function nsCacheRootKey$LWS(ns$LWS) {
  return `LSKey-${ns$LWS}$`;
}

function nsCacheKey$LWS(key$LWS, ns$LWS) {
  return `${nsCacheRootKey$LWS(ns$LWS)}${key$LWS}`;
}

function prefixCacheName$LWS(detailsOrName$LWS, key$LWS) {
  if (shared$LWS.isObjectLike(detailsOrName$LWS)) {
    const clonedDetails$LWS = shared$LWS.shallowCloneOptions(detailsOrName$LWS);
    clonedDetails$LWS.cacheName = nsCacheKey$LWS(clonedDetails$LWS.cacheName, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = nsCacheKey$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCacheName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = nsCacheRootKey$LWS(key$LWS); // First check that this Cache object belongs to this sandbox,
  // if not then return null.

  if (!shared$LWS.StringStartsWith(name$LWS, rootKey$LWS)) {
    return null;
  }

  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  return shared$LWS.StringSlice(name$LWS, rootKeyLength$LWS);
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageDelete$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const patchedDelete$LWS = function patchedDelete$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, patchedDelete$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageHas$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy2$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const has$LWS = function has$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalHas$LWS, this, args$LWS);
  };

  return [originalHas$LWS, has$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageKeys$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy3$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const keys$LWS = function keys$LWS() {
    return shared$LWS.PromiseThen(shared$LWS.ReflectApply(originalKeys$LWS, this, []), result$LWS => {
      const sandboxedCacheNames$LWS = [];

      for (let i$LWS = 0, j$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cacheName$LWS = unprefixCacheName$LWS(result$LWS[i$LWS], key$LWS);

        if (typeof cacheName$LWS === 'string') {
          sandboxedCacheNames$LWS[j$LWS++] = cacheName$LWS;
        }
      }

      return sandboxedCacheNames$LWS;
    });
  };

  return [originalKeys$LWS, keys$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageMatch$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy4$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const match$LWS = function match$LWS( // @ts-ignore TypeScript's confusion about using CacheStorage here.
  ...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // This should be sufficient enough to affirm the presense of at least the
    // request | string argument. We want to skip the distorted behavior
    // ONLY in cases where there are no arguments at all, or the request argument
    // is invalid, which is then handled by the host function.

    if (length$LWS && shared$LWS.isConvertibleToString(args$LWS[0])) {
      // Next we check if length is 2, which means that options are present
      const options$LWS = length$LWS === 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the options.cacheName.
      // The value of options.cacheName must also be safely convertable to a string.

      if (!shared$LWS.isObjectLike(options$LWS) || !options$LWS.cacheName || !shared$LWS.isConvertibleToString(options$LWS.cacheName)) {
        return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError('caches.match() expects the options argument to be present and to have a "cacheName" property.'));
      }

      args$LWS[1] = prefixCacheName$LWS(options$LWS, key$LWS);
    }

    return shared$LWS.ReflectApply(originalMatch$LWS, this, args$LWS);
  };

  return [originalMatch$LWS, match$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageOpen$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy5$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const open$LWS = function open$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
  };

  return [originalOpen$LWS, open$LWS];
}

const CHAR_CODE_EQUALS$LWS = 61;
const COOKIE_DELIMITER$LWS = '; ';

function prefixCookieName$LWS(detailsOrName$LWS, key$LWS) {
  if (shared$LWS.isObjectLike(detailsOrName$LWS)) {
    const clonedDetails$LWS = shared$LWS.shallowCloneOptions(detailsOrName$LWS);
    clonedDetails$LWS.name = sharedDom$LWS.nsCookieKey(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = sharedDom$LWS.nsCookieKey(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookieName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = sharedDom$LWS.nsCookieRootKey(key$LWS); // First check that this cookie belongs to this sandbox,
  // if not then return null.

  if (!shared$LWS.StringStartsWith(name$LWS, rootKey$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key


  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  const rootKeySubstringLength$LWS = shared$LWS.StringCharCodeAt(name$LWS, rootKeyLength$LWS) === CHAR_CODE_EQUALS$LWS ? rootKeyLength$LWS + 1 : rootKeyLength$LWS;
  return shared$LWS.StringSlice(name$LWS, rootKeySubstringLength$LWS);
}

function normalizeCookieListItem$LWS(cookie$LWS, key$LWS) {
  if (cookie$LWS) {
    const unprefixedCookieName$LWS = unprefixCookieName$LWS(cookie$LWS.name, key$LWS); // If unprefixCookieName() returns null, that means this cookie
    // doesn't belong to the provided sandbox (based on the key)

    if (unprefixedCookieName$LWS === null) {
      return null;
    }

    cookie$LWS.name = unprefixedCookieName$LWS;
  }

  return cookie$LWS;
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreDelete$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const deleteValue$LWS = function deleteValue$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, deleteValue$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp2$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const get$LWS = function get$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return shared$LWS.PromiseThen(shared$LWS.ReflectApply(originalGet$LWS, this, args$LWS), result$LWS => normalizeCookieListItem$LWS(result$LWS, key$LWS));
  };

  return [originalGet$LWS, get$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGetAll$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp3$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const getAll$LWS = function getAll$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(args$LWS[0], key$LWS);
    }

    return shared$LWS.PromiseThen(shared$LWS.ReflectApply(originalGetAll$LWS, this, args$LWS), result$LWS => {
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = normalizeCookieListItem$LWS(result$LWS[i$LWS], key$LWS);

        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }

      return sandboxedCookies$LWS;
    });
  };

  return [originalGetAll$LWS, getAll$LWS];
}

const restrictionsBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(eventTarget$LWS, eventName$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    [key$LWS]: bySandboxKeyRegistry$LWS
  } = restrictionsBySandboxKeyRegistry$LWS;

  if (bySandboxKeyRegistry$LWS === undefined || bySandboxKeyRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  const {
    constructor: constructor$LWS
  } = eventTarget$LWS;
  return shared$LWS.SetHas(bySandboxKeyRegistry$LWS[eventName$LWS], constructor$LWS);
}

function registerEventTargetRestriction$LWS(EventTargetCtor$LWS, eventName$LWS, options$LWS) {
  const {
    prototype: EventTargetProto$LWS
  } = EventTargetCtor$LWS;

  if (!isEventTargetRestricted$LWS(EventTargetProto$LWS, eventName$LWS, options$LWS)) {
    const {
      key: key$LWS
    } = options$LWS;
    const {
      [key$LWS]: bySandboxKeyRegistry$LWS = {
        __proto__: null
      }
    } = restrictionsBySandboxKeyRegistry$LWS;
    const {
      [eventName$LWS]: byEventName$LWS = new shared$LWS.SetCtor()
    } = bySandboxKeyRegistry$LWS;
    shared$LWS.SetAdd(byEventName$LWS, EventTargetCtor$LWS);
    bySandboxKeyRegistry$LWS[eventName$LWS] = byEventName$LWS;
    restrictionsBySandboxKeyRegistry$LWS[key$LWS] = bySandboxKeyRegistry$LWS;
  }
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreOnChange$LWS(globalObject$LWS, options$LWS) {
  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalOnChangeSetter$LWS = shared$LWS.ObjectLookupOwnSetter(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return null;
  }

  const onchange$LWS = function onchange$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set cookieStore.onchange.');
  };

  registerEventTargetRestriction$LWS(CookieStore$LWS, 'change', options$LWS);
  return [originalOnChangeSetter$LWS, onchange$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreSet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp4$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const set$LWS = function set$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        0: name$LWS
      } = args$LWS;
      args$LWS[0] = sharedDom$LWS.nsCookieKey(name$LWS, key$LWS);
    } else if (length$LWS) {
      const {
        0: details$LWS
      } = args$LWS;

      if (shared$LWS.isObjectLike(details$LWS)) {
        const clonedDetails$LWS = shared$LWS.shallowCloneOptions(details$LWS);
        clonedDetails$LWS.name = sharedDom$LWS.nsCookieKey(clonedDetails$LWS.name, key$LWS);
        args$LWS[0] = clonedDetails$LWS;
      }
    }

    return shared$LWS.ReflectApply(originalSet$LWS, this, args$LWS);
  };

  return [originalSet$LWS, set$LWS];
}

function distortionCSSStyleRuleStyleGetter$LWS(globalObject$LWS) {
  const {
    CSSStyleRule: CSSStyleRule$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(CSSStyleRule$LWS.prototype, 'style');

  function style$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionCustomElementRegistryGet$LWS(globalObject$LWS, options$LWS) {
  var _CustomElementRegistr$LWS;

  const {
    key: key$LWS
  } = options$LWS;
  const LOWER_CASED_NS$LWS = shared$LWS.StringToLowerCase(key$LWS);
  const {
    CustomElementRegistry: CustomElementRegistry$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    if (args$LWS.length) {
      const sanitizedName$LWS = shared$LWS.toString(args$LWS[0]);
      const lowerCasedName$LWS = shared$LWS.StringToLowerCase(sanitizedName$LWS);

      if (!shared$LWS.StringStartsWith(lowerCasedName$LWS, `${LOWER_CASED_NS$LWS}-`)) {
        return undefined;
      }

      args$LWS[0] = sanitizedName$LWS;
    }

    return shared$LWS.ReflectApply(originalGet$LWS, this, args$LWS);
  };

  return [originalGet$LWS, get$LWS];
}
/**
 * Factory patched cookie getter. Must be invoked with namespace argument.
 * Will return a patched cookie getter bound to the namespace.
 * @param key
 * @returns Distortion: string
 */


function distortionDocumentCookieGetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Document$LWS.prototype, 'cookie');

  function get$LWS() {
    const documentCookieValue$LWS = sharedDom$LWS.DocumentCookieGetter(this);
    const cookies$LWS = shared$LWS.StringSplit(documentCookieValue$LWS, COOKIE_DELIMITER$LWS);
    const sandboxedCookies$LWS = [];
    let sandboxedCookiesOffset$LWS = 0;

    for (let i$LWS = 0, {
      length: length$LWS
    } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const cookie$LWS = unprefixCookieName$LWS(cookies$LWS[i$LWS], key$LWS);

      if (cookie$LWS) {
        sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
      }
    }

    return shared$LWS.ArrayJoin(sandboxedCookies$LWS, COOKIE_DELIMITER$LWS);
  }

  return [originalCookieGetter$LWS, get$LWS];
}
/**
 * Factory patched cookie setter. Must be invoked with namespace argument.
 * Returns a distortion function bound to the namespace.
 * @param ns
 * @returns Distortion
 */


function distortionDocumentCookieSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'cookie');

  function set$LWS(value$LWS) {
    const cookieEntries$LWS = shared$LWS.StringSplit(value$LWS, COOKIE_DELIMITER$LWS);
    let {
      0: newCookieEntry$LWS
    } = cookieEntries$LWS;

    if (shared$LWS.StringCharCodeAt(newCookieEntry$LWS, 0) === CHAR_CODE_EQUALS$LWS) {
      newCookieEntry$LWS = shared$LWS.StringSlice(newCookieEntry$LWS, 1);
    }

    cookieEntries$LWS[0] = sharedDom$LWS.nsCookieKey(newCookieEntry$LWS, key$LWS);
    sharedDom$LWS.DocumentCookieSetter(this, shared$LWS.ArrayJoin(cookieEntries$LWS, COOKIE_DELIMITER$LWS));
  }

  return [originalCookieSetter$LWS, set$LWS];
}

function distortionDocumentDomainSetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const originalDomainSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'domain');

  function domain$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set document.domain.');
  }

  return [originalDomainSetter$LWS, domain$LWS];
} // eslint-disable-next-line no-shadow


var CookieSameSite$LWS;

(function (CookieSameSite$LWS) {
  CookieSameSite$LWS[CookieSameSite$LWS["strict"] = 0] = "strict";
  CookieSameSite$LWS[CookieSameSite$LWS["lax"] = 1] = "lax";
  CookieSameSite$LWS[CookieSameSite$LWS["none"] = 2] = "none";
})(CookieSameSite$LWS || (CookieSameSite$LWS = {})); // eslint-disable-next-line no-shadow


exports.SandboxType = void 0;

(function (SandboxType$LWS) {
  SandboxType$LWS[SandboxType$LWS["External"] = 0] = "External";
  SandboxType$LWS[SandboxType$LWS["Internal"] = 1] = "Internal";
})(exports.SandboxType || (exports.SandboxType = {}));

shared$LWS.ReflectSetPrototypeOf(exports.SandboxType, null);

function distortionDocumentExecCommand$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS,
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const {
    execCommand: originalExecCommand$LWS
  } = Document$LWS.prototype;
  const originalActiveElement$LWS = shared$LWS.ObjectLookupOwnGetter(Document$LWS.prototype, 'activeElement');
  const originalIsContentEditable$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'isContentEditable'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);
  const {
    sandboxType: sandboxType$LWS
  } = options$LWS;

  function execCommand$LWS(...args$LWS) {
    if (args$LWS.length > 2) {
      const {
        2: unsanitizedValue$LWS
      } = args$LWS;

      if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
        const command$LWS = shared$LWS.toString(args$LWS[0]);

        if (shared$LWS.StringToLowerCase(command$LWS) === 'inserthtml') {
          if (sandboxType$LWS === exports.SandboxType.External) {
            const activeElement$LWS = shared$LWS.ReflectApply(originalActiveElement$LWS, this, []);

            if (isSharedElement$LWS(activeElement$LWS) && shared$LWS.ReflectApply(originalIsContentEditable$LWS, activeElement$LWS, [])) {
              throw new shared$LWS.LockerSecurityError(`Cannot execute command '${command$LWS}' on ${shared$LWS.toString(activeElement$LWS.nodeName)}.`);
            }
          }

          args$LWS[0] = command$LWS;
          args$LWS[2] = htmlSanitizer$LWS.sanitize(unsanitizedValue$LWS);
        }
      }
    }

    return shared$LWS.ReflectApply(originalExecCommand$LWS, this, args$LWS);
  }

  return [originalExecCommand$LWS, execCommand$LWS];
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shared$LWS.shallowCloneArray(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    let windowFeatures$LWS = shared$LWS.StringToLowerCase(shared$LWS.toString(sanitizedArgs$LWS[2]));

    if (shared$LWS.RegExpTest(noopenerRegExp$LWS, windowFeatures$LWS)) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      windowFeatures$LWS = shared$LWS.StringReplace(windowFeatures$LWS, // RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`);
    }

    sanitizedArgs$LWS[2] = windowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function distortionDocumentOpen$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    open: originalDocumentOpen$LWS
  } = Document$LWS.prototype;

  function open$LWS(...args$LWS) {
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      const rawOpenWindow$LWS = shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
      return sharedDom$LWS.getPatchedWindow(rawOpenWindow$LWS);
    }

    return shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, args$LWS);
  }

  return [originalDocumentOpen$LWS, open$LWS];
}

function distortionDocumentReplaceChildren$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChild$LWS
  } = Document$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check if
    // its `head` property is a shared element. This will allow magenta window
    // documents to call replaceChildren successfully.
    if (isSharedElement$LWS(sharedDom$LWS.DocumentHeadGetter(this))) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of document.`);
    }

    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChildren$LWS];
}

function distortionDOMParserParseFromString$LWS(globalObject$LWS) {
  const {
    DOMParser: DOMParser$LWS
  } = globalObject$LWS;
  const {
    parseFromString: originalParseFromString$LWS
  } = DOMParser$LWS.prototype;

  function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with exactly
    // two arguments. If it receives one argument, it will fail. Some implementations
    // will also fail if it receives more than two arguments. Since any call that does
    // not have at least two arguments will fail no matter what, we only need to
    // expend effort to sanitize when we know that the operation is definitely
    // NOT going to fail.
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = shared$LWS.toString(args$LWS[0]);
      const mimeType$LWS = shared$LWS.toString(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? htmlSanitizer$LWS.sanitizeSvgInnerHtml(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : htmlSanitizer$LWS.sanitize(string$LWS);
    }

    return shared$LWS.ReflectApply(originalParseFromString$LWS, this, args$LWS);
  }

  return [originalParseFromString$LWS, parseFromString$LWS];
}

function distortionElementAfter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    after: originalAfter$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function after$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} after ${shared$LWS.toString(this.nodeName)}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalAfter$LWS, this, args$LWS);
  }

  return [originalAfter$LWS, after$LWS];
}

function distortionElementAppend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    append: originalAppend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function append$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot append ${nodeNameOrString$LWS} to ${shared$LWS.toString(this.nodeName)}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalAppend$LWS, this, args$LWS);
  }

  return [originalAppend$LWS, append$LWS];
}

function distortionElementAttachShadow$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    attachShadow: originalAttachShadow$LWS
  } = Element$LWS.prototype;

  function attachShadow$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS;

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new shared$LWS.LockerSecurityError("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit because
        // attachShadow() accepts inherited shadowRootInit properties.


        const shadowRootInit$LWS = shared$LWS.ObjectAssign({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment of mode
        // to avoid complications with inherited non-configurable/non-writable
        // mode properties.

        const originalShadowRootInitProto$LWS = shared$LWS.ReflectGetPrototypeOf(originalShadowRootInit$LWS);
        shared$LWS.ReflectSetPrototypeOf(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return shared$LWS.ReflectApply(originalAttachShadow$LWS, this, args$LWS);
  }

  return [originalAttachShadow$LWS, attachShadow$LWS];
}

const registry$LWS = new shared$LWS.WeakMapCtor();

function getPairedElement$LWS(attrInstance$LWS) {
  return shared$LWS.WeakMapGet(registry$LWS, attrInstance$LWS);
}

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  shared$LWS.WeakMapSet(registry$LWS, attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(originalMethod$LWS, nodeNameMap$LWS, attr$LWS, options$LWS) {
  const element$LWS = getPairedElement$LWS(nodeNameMap$LWS);

  if (element$LWS) {
    const {
      key: key$LWS
    } = options$LWS;
    const attrName$LWS = sharedDom$LWS.AttrNameGetter(attr$LWS);
    const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(element$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const attrValue$LWS = sharedDom$LWS.AttrValueGetter(attr$LWS);
      return shared$LWS.ReflectApply(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  }

  return shared$LWS.ReflectApply(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function distortionElementAttributesGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalAttributesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'attributes');

  function attributes$LWS() {
    const attrs$LWS = shared$LWS.ReflectApply(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }

  return [originalAttributesGetter$LWS, attributes$LWS];
}

function distortionElementBefore$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    before: originalBefore$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function before$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} before ${shared$LWS.toString(this.nodeName)}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalBefore$LWS, this, args$LWS);
  }

  return [originalBefore$LWS, before$LWS];
}

function distortionElementInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Element$LWS.prototype, 'innerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function innerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set innerHTML of ${this.nodeName}.`);
    }

    const sanitizedValue$LWS = this instanceof SVGElement$LWS ? htmlSanitizer$LWS.sanitizeSvgInnerHtml(this, value$LWS) : htmlSanitizer$LWS.sanitize(value$LWS);
    shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [sanitizedValue$LWS]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionElementInsertAdjacentElement$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentElement: originalInsertAdjacentElement$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function insertAdjacentElement$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(element$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert ${element$LWS.nodeName} adjacent to ${this.nodeName}.`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertAdjacentElement$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentElement$LWS, insertAdjacentElement$LWS];
}

function distortionElementInsertAdjacentHTML$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentHTML: originalInsertAdjacentHTML$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot insert adjacent HTML to ${shared$LWS.toString(this.nodeName)}.`);
    }

    if (args$LWS.length > 1) {
      args$LWS[1] = htmlSanitizer$LWS.sanitize(args$LWS[1]);
    }

    shared$LWS.ReflectApply(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentHTML$LWS, insertAdjacentHTML$LWS];
}

function distortionElementOuterHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalOuterHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Element$LWS.prototype, 'outerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function outerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set outerHTML of ${shared$LWS.toString(this.nodeName)}.`);
    }

    shared$LWS.ReflectApply(originalOuterHTMLSetter$LWS, this, [htmlSanitizer$LWS.sanitize(value$LWS)]);
  }

  return [originalOuterHTMLSetter$LWS, outerHTML$LWS];
}

function distortionElementPrepend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    prepend: originalPrepend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function prepend$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot prepend ${nodeNameOrString$LWS} to ${shared$LWS.toString(this.nodeName)}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalPrepend$LWS, this, args$LWS);
  }

  return [originalPrepend$LWS, prepend$LWS];
}

function distortionElementRemove$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    remove: originalRemove$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function remove$LWS() {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.toString(this.nodeName)}.`);
    }

    shared$LWS.ReflectApply(originalRemove$LWS, this, []);
  }

  return [originalRemove$LWS, remove$LWS];
}

function distortionElementReplaceChildren$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChildren$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function replaceChildren$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of ${shared$LWS.toString(this.nodeName)}.`);
    }

    return shared$LWS.ReflectApply(originalReplaceChildren$LWS, this, args$LWS);
  }

  return [originalReplaceChildren$LWS, replaceChildren$LWS];
}

function distortionElementReplaceWith$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceWith: originalReplaceWith$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function replaceWith$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.toString(this.nodeName)}.`);
    }

    return shared$LWS.ReflectApply(originalReplaceWith$LWS, this, args$LWS);
  }

  return [originalReplaceWith$LWS, replaceWith$LWS];
}

function normalizeAttrName$LWS(name$LWS) {
  return shared$LWS.StringToLowerCase(shared$LWS.toString(name$LWS));
}

function distortionElementSetAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element$LWS.prototype;

  function setAttribute$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const attrValue$LWS = shared$LWS.toString(args$LWS[1]);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
        return;
      }

      args$LWS[0] = attrName$LWS;
      args$LWS[1] = attrValue$LWS;
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, args$LWS);
  }

  return [originalSetAttribute$LWS, setAttribute$LWS];
}

function distortionElementSetAttributeNode$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNode: originalSetAttributeNode$LWS
  } = Element$LWS.prototype;

  function setAttributeNode$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (sharedDom$LWS.AttrOwnerElementGetter(attr$LWS)) {
      return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
    }

    const attrName$LWS = sharedDom$LWS.AttrNameGetter(attr$LWS);
    const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = sharedDom$LWS.ElementGetAttributeNode(this, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect old attribute.
        sharedDom$LWS.ElementRemoveAttributeNode(this, oldAttr$LWS);
      }

      const attrValue$LWS = sharedDom$LWS.AttrValueGetter(attr$LWS);
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = sharedDom$LWS.ElementGetAttributeNode(this, attrName$LWS);

      if (newAttr$LWS) {
        // Remove distorted attribute.
        sharedDom$LWS.ElementRemoveAttributeNode(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = sharedDom$LWS.AttrValueGetter(newAttr$LWS); // Set the distorted attr value.

        sharedDom$LWS.AttrValueSetter(attr$LWS, newValue$LWS); // Replace old attr.

        return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [attr$LWS]);
      }

      return undefined;
    }

    return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
  }

  return [originalSetAttributeNode$LWS, setAttributeNode$LWS];
}

function distortionElementSetAttributeNodeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNodeNS: originalSetAttributeNodeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNodeNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (sharedDom$LWS.AttrOwnerElementGetter(attr$LWS)) {
      return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
    }

    const attrName$LWS = sharedDom$LWS.AttrNameGetter(attr$LWS);
    const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = sharedDom$LWS.ElementGetAttributeNodeNS(this, attrNamespace$LWS, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect the old attribute.
        sharedDom$LWS.ElementRemoveAttributeNode(this, oldAttr$LWS);
      }

      const attrValue$LWS = shared$LWS.toString(sharedDom$LWS.AttrValueGetter(attr$LWS));
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = sharedDom$LWS.ElementGetAttributeNodeNS(this, attrNamespace$LWS, attrName$LWS);

      if (newAttr$LWS) {
        // Remove the distorted attribute.
        sharedDom$LWS.ElementRemoveAttributeNode(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = sharedDom$LWS.AttrValueGetter(newAttr$LWS); // Set the distorted attr value.

        sharedDom$LWS.AttrValueSetter(attr$LWS, newValue$LWS); // Replace old attr.

        return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }

      return null;
    }

    return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
  }

  return [originalSetAttributeNodeNS$LWS, setAttributeNodeNS$LWS];
}

function distortionElementSetAttributeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNS: originalSetAttributeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNS$LWS(...args$LWS) {
    if (args$LWS.length < 3) {
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
      return;
    }

    const {
      1: qualifiedName$LWS
    } = args$LWS;
    const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
    const attrNamespace$LWS = shared$LWS.toStringIfNotNullOrUndefined(args$LWS[0]);
    const attrValue$LWS = shared$LWS.toString(args$LWS[2]);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      return;
    }

    args$LWS[0] = attrNamespace$LWS;
    args$LWS[1] = attrName$LWS;
    args$LWS[2] = attrValue$LWS;
    shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
  }

  return [originalSetAttributeNS$LWS, setAttributeNS$LWS];
}

function distortionElementShadowRootGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalShadowRootGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'shadowRoot');

  function shadowRoot$LWS() {
    return null;
  }

  return [originalShadowRootGetter$LWS, shadowRoot$LWS];
}

function distortionElementToggleAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    hasAttribute: ElementProtoHasAttribute$LWS,
    toggleAttribute: originalToggleAttribute$LWS
  } = Element$LWS.prototype;

  const toggleAttribute$LWS = function toggleAttribute$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 0) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely, if the distortion throws.

        shared$LWS.ReflectApply(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to return true | false, based on
        // the presense or absense of this attribute.

        return shared$LWS.ReflectApply(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
      }

      args$LWS[0] = attrName$LWS;
    }

    return shared$LWS.ReflectApply(originalToggleAttribute$LWS, this, args$LWS);
  };

  return [originalToggleAttribute$LWS, toggleAttribute$LWS];
}

function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = sharedDom$LWS.EventCurrentTargetGetter(event$LWS);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = shared$LWS.ReflectApply(originalComposedPath$LWS, event$LWS, []);
  const indexOfcurrentTarget$LWS = shared$LWS.ArrayIndexOf(rawComposedPath$LWS, currentTarget$LWS);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = indexOfcurrentTarget$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = shared$LWS.ArraySlice(rawComposedPath$LWS, i$LWS + 1);
      break;
    }
  }

  return distortedComposedPath$LWS;
}

function distortionEventComposedPath$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const {
    composedPath: originalComposedPath$LWS
  } = Event$LWS.prototype;

  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }

  return [originalComposedPath$LWS, composedPath$LWS];
}

function distortionEventPathGetter$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const originalPathGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return null;
  }

  const path$LWS = function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  };

  return [originalPathGetter$LWS, path$LWS];
}

function distortionEventTargetAddEventListener$LWS(globalObject$LWS, options$LWS) {
  const {
    EventTarget: EventTarget$LWS
  } = globalObject$LWS;
  const {
    addEventListener: originalAddEventListener$LWS
  } = EventTarget$LWS.prototype;

  function addEventListener$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Ensure that we fallback to the default platform behavior which
    // should fail if less than 2 arguments are provided.

    if (length$LWS > 1) {
      const {
        0: eventName$LWS
      } = args$LWS;

      if (isEventTargetRestricted$LWS(this, eventName$LWS, options$LWS)) {
        var _safeDesc$LWS;

        const unsafeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(this.constructor, 'name');
        let safeDesc$LWS;

        if (unsafeDesc$LWS) {
          safeDesc$LWS = shared$LWS.toSafeDescriptor(unsafeDesc$LWS);
        }

        const name$LWS = (_safeDesc$LWS = safeDesc$LWS) == null ? void 0 : _safeDesc$LWS.value;
        let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;

        if (typeof name$LWS === 'string') {
          exceptionMessage$LWS += ` to ${name$LWS} object`;
        }

        throw new shared$LWS.LockerSecurityError(`${exceptionMessage$LWS}.`);
      }
    }

    return shared$LWS.ReflectApply(originalAddEventListener$LWS, this, args$LWS);
  }

  return [originalAddEventListener$LWS, addEventListener$LWS];
}

function distortionHistoryPushState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    pushState: originalPushState$LWS
  } = History$LWS.prototype;

  function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalPushState$LWS, this, args$LWS);
  }

  return [originalPushState$LWS, pushState$LWS];
}

function distortionHistoryReplaceState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    replaceState: originalReplaceState$LWS
  } = History$LWS.prototype;

  function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalReplaceState$LWS, this, args$LWS);
  }

  return [originalReplaceState$LWS, replaceState$LWS];
}

function distortionHTMLElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionHTMLElementInnerTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalInnerTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'innerText');

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  const innerText$LWS = function innerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set innerText of ${shared$LWS.toString(this.nodeName)}.`);
    }

    shared$LWS.ReflectApply(originalInnerTextSetter$LWS, this, [value$LWS]);
  };

  return [originalInnerTextSetter$LWS, innerText$LWS];
} // outerText is not a standard property, so the descriptor could be undefined, like in the case
// of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility


function distortionHTMLElementOuterTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalOuterTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'outerText');

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  const outerText$LWS = function outerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set outerText of ${shared$LWS.toString(this.nodeName)}.`);
    }

    shared$LWS.ReflectApply(originalOuterTextSetter$LWS, this, [value$LWS]);
  };

  return [originalOuterTextSetter$LWS, outerText$LWS];
}

function distortionHTMLElementStyleGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'style');

  function style$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionHTMLFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    shared$LWS.ReflectApply(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = shared$LWS.ReflectApply(originalContentWindowGetter$LWS, this, []);
    return sharedDom$LWS.getPatchedWindow(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLIFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    shared$LWS.ReflectApply(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLIFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLIFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = shared$LWS.ReflectApply(originalContentWindowGetter$LWS, this, []);
    return sharedDom$LWS.getPatchedWindow(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementSrcSetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLIFrameElement$LWS.prototype, 'src');

  function src$LWS(value$LWS) {
    const urlString$LWS = sharedUrl$LWS.sanitizeURLForElement(value$LWS);

    if (!sharedUrl$LWS.isValidURLScheme(urlString$LWS)) {
      throw new shared$LWS.LockerSecurityError('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
    }

    sharedDom$LWS.HTMLIFrameElementSrcSetter(this, urlString$LWS);
  }

  registerElementSetDistortion$LWS(HTMLIFrameElement$LWS, {
    attributeName: 'src',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

const IMPORT$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return !shared$LWS.RegExpTest(IMPORT$LWS, value$LWS);
}

function distortionHTMLLinkElementRelSetter$LWS(globalObject$LWS) {
  const {
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const string$LWS = shared$LWS.toString(value$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      shared$LWS.ReflectApply(originalRelSetter$LWS, this, [string$LWS]);
      return;
    }

    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }

  registerElementSetDistortion$LWS(HTMLLinkElement$LWS, {
    attributeName: 'rel',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: rel$LWS
  });
  return [originalRelSetter$LWS, rel$LWS];
}

function distortionHTMLLinkElementRelListSetter$LWS(globalObject$LWS) {
  const {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelListSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'relList');

  function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? sharedDom$LWS.DOMTokenListValueGetter(relListValue$LWS) : shared$LWS.toString(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      shared$LWS.ReflectApply(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }

  return [originalRelListSetter$LWS, relList$LWS];
}

function distortionHTMLObjectElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLObjectElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    shared$LWS.ReflectApply(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLObjectElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLObjectElement$LWS.prototype, 'contentWindow'); // contentWindow is not supported on object elements in iOS < 13.
  // https://caniuse.com/mdn-api_htmlobjectelement_contentwindow

  if (typeof originalContentWindowGetter$LWS !== 'function') {
    return null;
  }

  const contentWindow$LWS = function contentWindow$LWS() {
    const rawContentWindow$LWS = shared$LWS.ReflectApply(originalContentWindowGetter$LWS, this, []);
    return sharedDom$LWS.getPatchedWindow(rawContentWindow$LWS);
  };

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = sharedDom$LWS.HTMLElementDatasetGetter(el$LWS);
  const distortedSrc$LWS = shared$LWS.ObjectLookupOwnValue(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function distortionHTMLScriptElementSrcGetter$LWS(globalObject$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLScriptElement$LWS.prototype, 'src');

  function src$LWS() {
    return getDatasetSrcValue$LWS(this) || shared$LWS.ReflectApply(originalSrcGetter$LWS, this, []);
  }

  return [originalSrcGetter$LWS, src$LWS];
}

function abstractFactoryValueThrower$LWS(proto$LWS, propName$LWS) {
  return function valueThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const {
      [propName$LWS]: originalValue$LWS
    } = proto$LWS;

    function value$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalValue$LWS, value$LWS];
  };
}

function abstractFactoryGetThrower$LWS(proto$LWS, propName$LWS) {
  return function getThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalGet$LWS = shared$LWS.ObjectLookupOwnGetter(proto$LWS, propName$LWS);

    function get$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalGet$LWS, get$LWS];
  };
}

function abstractFactorySetThrower$LWS(proto$LWS, propName$LWS) {
  return function setThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalSet$LWS = shared$LWS.ObjectLookupOwnSetter(proto$LWS, propName$LWS);

    function set$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalSet$LWS, set$LWS];
  };
}
/**
 * Wraps the source content of a script tag in the evaluator
 * Creates a blob: url with the wrapped content
 * @param text String
 * @param key String
 * @returns String
 */


function createScriptUrl$LWS(text$LWS, key$LWS) {
  const transformedText$LWS = sharedDom$LWS.transformUncompiledSource(text$LWS);
  const payload$LWS = sharedDom$LWS.WindowEncodeURIComponent(transformedText$LWS);
  const blobScript$LWS = `
    {
        const { $evaluator$ } = document.currentScript;
        const text = decodeURIComponent(\`${payload$LWS}\`);
        delete document.currentScript.$evaluator$;
        $evaluator$('${key$LWS}', text, { ${shared$LWS.UNCOMPILED_LOCATION_NAME}: location });
    }`;
  return sharedDom$LWS.URLCreateObjectURL(new sharedDom$LWS.BlobCtor([blobScript$LWS], {
    type: 'text/javascript'
  }));
}

function scriptDistortion$LWS(attributeName$LWS, options$LWS, datasetGetter$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const normalizerAnchor$LWS = sharedDom$LWS.DocumentCreateElement(document, 'a');
  return function distortion$LWS(value$LWS) {
    const originalValue$LWS = value$LWS;
    const elementNamespaceURI$LWS = sharedDom$LWS.ElementGetNamespaceURI(this);
    const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === sharedDom$LWS.NAMESPACE_XHTML ? '' : sharedDom$LWS.NAMESPACE_XLINK;

    if (value$LWS === '') {
      sharedDom$LWS.ElementSetAttributeNS(this, attributeNamespaceURI$LWS, attributeName$LWS, value$LWS);
      return;
    } // Normalize Value


    sharedDom$LWS.HTMLAnchorElementHrefSetter(normalizerAnchor$LWS, value$LWS);
    value$LWS = sharedDom$LWS.HTMLAnchorElementHrefGetter(normalizerAnchor$LWS); // Create Synthetic Attribute

    const dataset$LWS = datasetGetter$LWS(this);
    dataset$LWS[`distorted${shared$LWS.capitalizeFirstChar(attributeName$LWS)}`] = originalValue$LWS; // Create XHR

    const hostname$LWS = sharedDom$LWS.HTMLAnchorElementHostnameGetter(normalizerAnchor$LWS);
    const xhr$LWS = new sharedDom$LWS.XhrCtor();

    if (shared$LWS.StringMatch(hostname$LWS, sharedUrl$LWS.TRUSTED_DOMAINS)) {
      sharedDom$LWS.XhrWithCredentialsSetter(xhr$LWS, true);
    }

    sharedDom$LWS.EventTargetAddEventListener(xhr$LWS, 'load', () => {
      const status$LWS = sharedDom$LWS.XhrStatusGetter(xhr$LWS);

      if (status$LWS === 200) {
        const responseText$LWS = sharedDom$LWS.XhrResponseTextGetter(xhr$LWS);
        shared$LWS.ReflectDefineProperty(this, '$evaluator$', {
          __proto__: null,
          configurable: true,
          value: evaluator$LWS
        });
        sharedDom$LWS.ElementSetAttributeNS(this, attributeNamespaceURI$LWS, attributeName$LWS, createScriptUrl$LWS(responseText$LWS, key$LWS));
      } else if (status$LWS === 404) {
        sharedDom$LWS.ElementSetAttributeNS(this, attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found');
      }
    });
    sharedDom$LWS.XhrOpen(xhr$LWS, 'GET', value$LWS);
    sharedDom$LWS.XhrSend(xhr$LWS);
  };
}

function distortBlockedProperties$LWS(proto$LWS, propertyList$LWS) {
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = propertyList$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = propertyList$LWS[i$LWS];
    const unsafeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(proto$LWS, prop$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = shared$LWS.toSafeDescriptor(unsafeDesc$LWS);
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;

        if (getter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactoryGetThrower$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactorySetThrower$LWS(proto$LWS, prop$LWS);
        }
      } else if (typeof value$LWS === 'function') {
        entries$LWS[entriesOffset$LWS++] = abstractFactoryValueThrower$LWS(proto$LWS, prop$LWS);
      }
    }
  }

  return entries$LWS;
}

function distortBlockedAttributes$LWS(ctor$LWS, attributes$LWS, elNamespace$LWS = sharedDom$LWS.NAMESPACE_DEFAULT) {
  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attributeName$LWS = attributes$LWS[i$LWS];
    const {
      name: ctorName$LWS
    } = ctor$LWS;
    registerElementSetDistortion$LWS(ctor$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: elNamespace$LWS,

      distortion() {
        throw new shared$LWS.LockerSecurityError(`Attribute "${attributeName$LWS}" not allowed on ${ctorName$LWS}.`);
      }

    });
  }
}

function maybeMaskDistortion$LWS(distortedValue$LWS, rawValue$LWS) {
  if (typeof distortedValue$LWS === 'function' && typeof rawValue$LWS === 'function') {
    return shared$LWS.maskDistortion(distortedValue$LWS, rawValue$LWS);
  }

  return distortedValue$LWS;
}

function distortionHTMLScriptElementSrcSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLScriptElement$LWS.prototype, 'src');
  const src$LWS = scriptDistortion$LWS('src', options$LWS, sharedDom$LWS.HTMLElementDatasetGetter);
  registerElementSetDistortion$LWS(HTMLScriptElement$LWS, {
    attributeName: 'src',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

function distortionIDBObjectStoreAdd$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    add: originalAdd$LWS
  } = IDBObjectStore$LWS.prototype;

  function add$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalAdd$LWS, this, args$LWS);
  }

  return [originalAdd$LWS, add$LWS];
}

function distortionIDBObjectStorePut$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    put: originalPut$LWS
  } = IDBObjectStore$LWS.prototype;

  function put$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalPut$LWS, this, args$LWS);
  }

  return [originalPut$LWS, put$LWS];
}

function distortionMessageEventSourceGetter$LWS(globalObject$LWS) {
  const {
    MessageEvent: MessageEvent$LWS
  } = globalObject$LWS;
  const originalSourceGetter$LWS = shared$LWS.ObjectLookupOwnGetter(MessageEvent$LWS.prototype, 'source');

  function source$LWS() {
    const rawSource$LWS = shared$LWS.ReflectApply(originalSourceGetter$LWS, this, []);
    return shared$LWS.toString(rawSource$LWS) === '[object Window]' ? sharedDom$LWS.getPatchedWindow(rawSource$LWS) : rawSource$LWS;
  }

  return [originalSourceGetter$LWS, source$LWS];
}

function distortionNamedNodeMapSetNamedItem$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItem: originalSetNamedItem$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItem$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetNamedItem$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItem$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItem$LWS, setNamedItem$LWS];
}

function distortionNamedNodeMapSetNamedItemNS$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItemNS: originalSetNamedItemNS$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItemNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetNamedItemNS$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItemNS$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItemNS$LWS, setNamedItemNS$LWS];
}

function distortionNavigatorSendBeacon$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const {
    sendBeacon: originalSendBeacon$LWS
  } = Navigator$LWS.prototype;

  function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: url$LWS
      } = args$LWS;
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));

      if (sharedUrl$LWS.isInvalidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return shared$LWS.ReflectApply(originalSendBeacon$LWS, this, args$LWS);
  }

  return [originalSendBeacon$LWS, sendBeacon$LWS];
}

function distortionNavigatorServiceWorkerGetter$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const originalServiceWorkerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Navigator$LWS.prototype, 'serviceWorker');

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS() {
    return undefined;
  };

  return [originalServiceWorkerGetter$LWS, get$LWS];
}

function distortionNodeInsertBefore$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    insertBefore: originalInsertBefore$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);

  function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert child ${shared$LWS.toString(argValue$LWS.nodeName)} into ${shared$LWS.toString(this.nodeName)},`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertBefore$LWS, this, args$LWS);
  }

  return [originalInsertBefore$LWS, insertBefore$LWS];
}

function distortionAttrNodeValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalNodeValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Node$LWS.prototype, 'nodeValue');

  function nodeValue$LWS(value$LWS) {
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the nodeValue property.
    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = sharedDom$LWS.AttrOwnerElementGetter(this);

      if (ownerElement$LWS === null) {
        return shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
      }

      const attrName$LWS = sharedDom$LWS.AttrNameGetter(this);
      const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return shared$LWS.ReflectApply(distortion$LWS, ownerElement$LWS, [value$LWS]);
      }
    }

    return shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
  }

  return [originalNodeValueSetter$LWS, nodeValue$LWS];
}

function distortionNodeRemoveChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    removeChild: originalRemoveChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.toString(argValue$LWS.nodeName)}.`);
      }
    }

    return shared$LWS.ReflectApply(originalRemoveChild$LWS, this, args$LWS);
  }

  return [originalRemoveChild$LWS, removeChild$LWS];
}

function distortionNodeReplaceChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    replaceChild: originalReplaceChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments. If the "old element"
    // argument is a valid shared element, an exception is thrown.
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        1: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.toString(argValue$LWS.nodeName)}.`);
      }
    }

    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChild$LWS];
}

function distortionNodeTextContentSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalTextContentSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Node$LWS.prototype, 'textContent'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(window);

  function textContent$LWS(value$LWS) {
    const valueString$LWS = shared$LWS.toString(value$LWS); // There are two existence of the attribute textContent, one on Attr and one on Node.
    // This first if statement is checking to figure out which distortion should be applied.
    // The instanceof operator tests to see if the current global object, this, is of the type Attr,
    // while also taking inheritance into consideration.
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the textContent property.

    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = sharedDom$LWS.AttrOwnerElementGetter(this);

      if (ownerElement$LWS === null) {
        return shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueString$LWS]);
      }

      const attrName$LWS = sharedDom$LWS.AttrNameGetter(this);
      const attrNamespace$LWS = sharedDom$LWS.AttrNamespaceURIGetter(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return shared$LWS.ReflectApply(distortion$LWS, ownerElement$LWS, [valueString$LWS]);
      }
    }

    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set textContent of ${shared$LWS.toString(this.nodeName)} elements.`);
    }

    return shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueString$LWS]);
  }

  return [originalTextContentSetter$LWS, textContent$LWS];
}

function distortionNotificationCtor$LWS(globalObject$LWS) {
  const {
    Notification: originalNotificationCtor$LWS
  } = globalObject$LWS;

  if (typeof originalNotificationCtor$LWS !== 'function') {
    return null;
  }

  const Notification$LWS = function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = sharedDom$LWS.partialStructuredClone(args$LWS[1]);
    }

    return shared$LWS.ReflectApply(originalNotificationCtor$LWS, this, args$LWS);
  };

  return [originalNotificationCtor$LWS, Notification$LWS];
}

function distortionRangeCreateContextualFragment$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    createContextualFragment: originalCreateContextualFragment$LWS
  } = Range$LWS.prototype;

  function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = htmlSanitizer$LWS.sanitize(tagString$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalCreateContextualFragment$LWS, this, args$LWS);
  }

  return [originalCreateContextualFragment$LWS, createContextualFragment$LWS];
}

function distortionRangeDeleteContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    deleteContents: originalDeleteContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function deleteContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = shared$LWS.ReflectApply(originalCloneContents$LWS, this, []);
    const elementFound$LWS = sharedDom$LWS.DocumentFragmentQuerySelector(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new shared$LWS.LockerSecurityError(`Cannot delete contents of ${elementFound$LWS.nodeName}.`);
    }

    return shared$LWS.ReflectApply(originalDeleteContents$LWS, this, args$LWS);
  }

  return [originalDeleteContents$LWS, deleteContents$LWS];
}

function distortionRangeExtractContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    extractContents: originalExtractContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function extractContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = shared$LWS.ReflectApply(originalCloneContents$LWS, this, []);
    const elementFound$LWS = sharedDom$LWS.DocumentFragmentQuerySelector(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new shared$LWS.LockerSecurityError(`Cannot extract contents of ${elementFound$LWS.nodeName}.`);
    }

    return shared$LWS.ReflectApply(originalExtractContents$LWS, this, args$LWS);
  }

  return [originalExtractContents$LWS, extractContents$LWS];
}

function distortionRangeInsertNode$LWS(globalObject$LWS) {
  // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(window);
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    insertNode: originalInsertNode$LWS
  } = Range$LWS.prototype;
  const originalCommonAncestorContainer$LWS = shared$LWS.ObjectLookupOwnGetter(Range$LWS.prototype, 'commonAncestorContainer');

  function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;
      const commonAncestorContainer$LWS = shared$LWS.ReflectApply(originalCommonAncestorContainer$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert a new child node of ${commonAncestorContainer$LWS.nodeName}.`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertNode$LWS, this, args$LWS);
  }

  return [originalInsertNode$LWS, insertNode$LWS];
}

function distortionServiceWorkerContainer$LWS(globalObject$LWS) {
  const {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  } = globalObject$LWS;

  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function distortionShadowRootInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(ShadowRoot$LWS.prototype, 'innerHTML');

  function innerHTML$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [htmlSanitizer$LWS.sanitize(value$LWS)]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionShadowRootModeGetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalModeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(ShadowRoot$LWS.prototype, 'mode');

  function mode$LWS() {
    return 'closed';
  }

  return [originalModeGetter$LWS, mode$LWS];
}

function distortionSharedWorkerCtor$LWS(globalObject$LWS) {
  const {
    SharedWorker: originalSharedWorkerCtor$LWS
  } = globalObject$LWS;

  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return null;
  }

  const SharedWorker$LWS = function SharedWorker$LWS(scriptURL$LWS) {
    throw new shared$LWS.LockerSecurityError(`Cannot create SharedWorker with ${shared$LWS.toString(scriptURL$LWS)}.`);
  };

  return [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
}

function distortionSharedWorkerProto$LWS(globalObject$LWS) {
  const {
    SharedWorker: SharedWorker$LWS
  } = globalObject$LWS;

  if (typeof SharedWorker$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = shared$LWS.ObjectKeys(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (shared$LWS.StringStartsWith(key$LWS, storageRootKey$LWS)) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = new shared$LWS.ArrayCtor(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = shared$LWS.StringReplace(key$LWS, storageRootKey$LWS, '');
  }

  return keys$LWS;
}

const meta$LWS = new WeakMap();

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = shared$LWS.WeakMapGet(meta$LWS, storage$LWS);

  if (storageMeta$LWS === undefined) {
    throw new shared$LWS.LockerSecurityError('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(s$LWS) {
  return new Proxy(s$LWS, {
    get(target$LWS, key$LWS, receiver$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (shared$LWS.ObjectHasOwnProperty(storage$LWS, keyForNamespace$LWS)) {
        return shared$LWS.ReflectGet(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);
      return proto$LWS === null ? undefined : shared$LWS.ReflectGet(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectSet(target$LWS, key$LWS, value$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, descriptor$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const safeDesc$LWS = shared$LWS.toSafeDescriptor(descriptor$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDefineProperty(target$LWS, key$LWS, safeDesc$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectDefineProperty(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDeleteProperty(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectDeleteProperty(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectGetOwnPropertyDescriptor(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectGetOwnPropertyDescriptor(storage$LWS, keyForNamespace$LWS);
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = shared$LWS.ObjectGetOwnPropertySymbols(target$LWS);
      return shared$LWS.ArrayConcat(storageKeys$LWS, localSymbolKeys$LWS);
    },

    has(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectHas(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (shared$LWS.ObjectHasOwnProperty(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return shared$LWS.ReflectHas(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
}

class PatchedStorage$LWS {
  constructor() {
    throw new shared$LWS.LockerSecurityError('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return shared$LWS.StringReplace(resolvedKey$LWS, storageRootKey$LWS, '');
    }

    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoKey, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
    }

    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoGetItem, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
      args$LWS[1] = shared$LWS.toString(args$LWS[1]);
    }

    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
    }

    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const target$LWS = {
    __proto__: PatchedStorage$LWS.prototype
  };
  shared$LWS.markLiveObject(target$LWS);
  const proxy$LWS = createStorageProxy$LWS(target$LWS);
  const storageMeta$LWS = {
    proxy: proxy$LWS,
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  };
  shared$LWS.WeakMapSet(meta$LWS, proxy$LWS, storageMeta$LWS);
  shared$LWS.WeakMapSet(meta$LWS, target$LWS, storageMeta$LWS);
  return proxy$LWS;
}

const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorage$LWS.prototype;
const patchedStorageProtoLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(PatchedStorage$LWS.prototype, 'length');

function createDistortionStorageFactory$LWS(storageName$LWS) {
  return function distortionStorageFactory$LWS(globalObject$LWS, options$LWS) {
    const storageObject$LWS = globalObject$LWS[storageName$LWS];

    if (!shared$LWS.isObject(storageObject$LWS)) {
      return null;
    }

    const {
      key: key$LWS
    } = options$LWS;
    const rootKey$LWS = getStorageRootKey$LWS(key$LWS);
    const patchedStorageObject$LWS = createStorage$LWS(storageObject$LWS, rootKey$LWS);
    return [storageObject$LWS, patchedStorageObject$LWS];
  };
}

function distortionStorageLength$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Storage$LWS.prototype, 'length');
  return [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
}

function distortionStorageGetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    getItem: originalStorageGetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
}

function distortionStorageSetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    setItem: originalStorageSetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
}

function distortionStorageKey$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    key: originalStorageKey$LWS
  } = Storage$LWS.prototype;
  return [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
}

function distortionStorageRemoveItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    removeItem: originalStorageRemoveItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
}

function distortionStorageClear$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    clear: originalStorageClear$LWS
  } = Storage$LWS.prototype;
  return [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
}

function distortionStorage$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  return [Storage$LWS, PatchedStorage$LWS];
}

const distortionLocalStorage$LWS = createDistortionStorageFactory$LWS('localStorage');
const distortionSessionStorage$LWS = createDistortionStorageFactory$LWS('sessionStorage');

function distortionSVGAnimateElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (sharedDom$LWS.ElementHasAttribute(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = sharedDom$LWS.ElementGetAttribute(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'from');
      distortAttribute$LWS(this, 'to');
      distortAttribute$LWS(this, 'values');
    }
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGAnimateElementFromAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function from$LWS(value$LWS) {
    if (sharedDom$LWS.ElementGetAttribute(this, 'attributeName') === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'from',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: from$LWS
  });
  return null;
}

function distortionSVGAnimateElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (sharedDom$LWS.ElementGetAttribute(this, 'attributeName') === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'to',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: to$LWS
  });
  return null;
}

function distortionSVGAnimateElementValuesAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (sharedDom$LWS.ElementGetAttribute(this, 'attributeName') === 'href') {
      const valuesSplit$LWS = shared$LWS.StringSplit(value$LWS, ';');
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = htmlSanitizer$LWS.sanitizeSvgHref(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = shared$LWS.ArrayJoin(valuesSplit$LWS, ';');
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'values',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: values$LWS
  });
  return null;
}

function distortionSVGElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionSVGScriptElementHrefAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'href',
    attributeNamespace: sharedDom$LWS.NAMESPACE_XLINK,
    distortion: scriptDistortion$LWS('href', options$LWS, sharedDom$LWS.SVGElementDatasetGetter)
  });
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'xlink:href',
    attributeNamespace: sharedDom$LWS.NAMESPACE_XLINK,
    distortion: scriptDistortion$LWS('xlink:href', options$LWS, sharedDom$LWS.SVGElementDatasetGetter)
  });
  return null;
}

function distortionSVGSetElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (sharedDom$LWS.ElementHasAttribute(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = sharedDom$LWS.ElementGetAttribute(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'to');
    }
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGSetElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (sharedDom$LWS.ElementGetAttribute(this, 'attributeName') === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'to',
    attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
    distortion: to$LWS
  });
  return null;
}

function createDistortionHrefAttributeFactory$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactory$LWS(globalObject$LWS) {
    const {
      SVGUseElement: SVGUseElement$LWS
    } = globalObject$LWS;
    const {
      setAttribute: originalSetAttribute$LWS,
      setAttributeNS: originalSetAttributeNS$LWS
    } = Element.prototype;

    if (attributeName$LWS === 'href') {
      const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
        shared$LWS.ReflectApply(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
      };

      registerElementSetDistortion$LWS(SVGUseElement$LWS, {
        attributeName: attributeName$LWS,
        attributeNamespace: sharedDom$LWS.NAMESPACE_DEFAULT,
        distortion: defaultNamespaceDistortion$LWS
      });
    }

    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, [sharedDom$LWS.NAMESPACE_XLINK, attributeName$LWS, returnValue$LWS]);
    }

    registerElementSetDistortion$LWS(SVGUseElement$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: sharedDom$LWS.NAMESPACE_XLINK,
      distortion: xlinkNamespaceDistortion$LWS
    });
    return null;
  };
}

const distortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('href');
const distortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('xlink:href');

function distortionTrustedTypePolicyFactoryCreatePolicy$LWS(globalObject$LWS) {
  const {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  } = globalObject$LWS;

  if (typeof TrustedTypePolicyFactory$LWS !== 'function') {
    return null;
  }

  const {
    createPolicy: originalCreatePolicy$LWS
  } = TrustedTypePolicyFactory$LWS.prototype;

  const createPolicy$LWS = function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (name$LWS === 'default') {
      throw new shared$LWS.LockerSecurityError(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    }

    return shared$LWS.ReflectApply(originalCreatePolicy$LWS, this, args$LWS);
  };

  return [originalCreatePolicy$LWS, createPolicy$LWS];
}

const HTML_MIME_TYPES$LWS = ['text/html', 'image/svg+xml', 'text/xml'];

function distortionURLCreateObjectURL$LWS(globalObject$LWS) {
  const {
    URL: URL$LWS
  } = globalObject$LWS;
  const {
    createObjectURL: originalCreateObjectURL$LWS
  } = URL$LWS;
  const {
    isEqualDomString: isEqualDomString$LWS,
    isMediaSourceObject: isMediaSourceObject$LWS
  } = sharedDom$LWS.getValidator(globalObject$LWS);

  function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [blobObject$LWS]); // MediaSource does not share the same proto object as Blob or File.
    // It can still be used with createObjectURL however we need to treat it separately.
    // MediaSource does not accept plain text input as Blob and File and does not have a MIME type.

    if (isMediaSourceObject$LWS(blobObject$LWS)) {
      return outURL$LWS;
    }

    const type$LWS = sharedDom$LWS.BlobTypeGetter(blobObject$LWS);

    if (type$LWS === '') {
      // browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      return shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [sharedDom$LWS.BlobSlice(blobObject$LWS, 0, undefined, 'text/plain')]);
    }

    if (shared$LWS.ArrayIncludes(HTML_MIME_TYPES$LWS, type$LWS)) {
      const normalizedBlob$LWS = sharedDom$LWS.BlobSlice(blobObject$LWS, 0, sharedDom$LWS.BlobSizeGetter(blobObject$LWS), `${type$LWS};charset=utf-8`);
      sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
      outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new sharedDom$LWS.XhrCtor();
      sharedDom$LWS.XhrOpen(xhr$LWS, 'GET', outURL$LWS, false);
      sharedDom$LWS.XhrSend(xhr$LWS);
      const sanitizer$LWS = htmlSanitizer$LWS.blobSanitizer();
      const responseText$LWS = sharedDom$LWS.XhrResponseTextGetter(xhr$LWS);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
        throw new shared$LWS.LockerSecurityError(`Cannot "createObjectURL" using a unsecure ${shared$LWS.toString(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (sharedUrl$LWS.isMIMETypeAllowed(type$LWS)) {
      return outURL$LWS;
    }

    sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
    throw new shared$LWS.LockerSecurityError('Unsupported MIME type.');
  }

  return [originalCreateObjectURL$LWS, createObjectURL$LWS];
}

function distortionWindowFetch$LWS(globalObject$LWS) {
  const {
    fetch: originalFetch$LWS
  } = globalObject$LWS;

  function fetch$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = sharedUrl$LWS.parseURL(sharedDom$LWS.RequestURLGetter(url$LWS));
      } else {
        parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (sharedUrl$LWS.isInvalidURL(parsedURL$LWS)) {
        return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${shared$LWS.toString(url$LWS)}.`));
      }
    }

    return shared$LWS.ReflectApply(originalFetch$LWS, this, args$LWS);
  }

  return [originalFetch$LWS, fetch$LWS];
}
/* eslint-disable class-methods-use-this, max-classes-per-file */


function distortionWindowFramesGetter$LWS(globalObject$LWS) {
  const originalWindowFramesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'frames');

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return null;
  }

  let framesProxy$LWS;

  const frames$LWS = function frames$LWS() {
    if (!framesProxy$LWS) {
      const integerRegExp$LWS = /^0$|^[1-9][0-9]*$/;
      const WindowPrototype$LWS = shared$LWS.ReflectGetPrototypeOf(globalObject$LWS);
      const WindowProperties$LWS = shared$LWS.ReflectGetPrototypeOf(WindowPrototype$LWS);

      const getFrameByIndexKey$LWS = key$LWS => {
        if (isFrameIndexKey$LWS(key$LWS)) {
          const value$LWS = shared$LWS.ObjectLookupOwnValue(globalObject$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return sharedDom$LWS.getPatchedWindow(value$LWS);
          }
        }

        return undefined;
      };

      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
        !shared$LWS.ObjectHasOwnProperty(globalObject$LWS, key$LWS) && // ...Or its prototype.
        !shared$LWS.ObjectHasOwnProperty(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = shared$LWS.ObjectLookupOwnValue(WindowProperties$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return sharedDom$LWS.getPatchedWindow(value$LWS);
          }
        }

        return undefined;
      };

      const getValueByKey$LWS = key$LWS => {
        if (key$LWS === 'length') {
          return sharedDom$LWS.WindowLengthGetter(globalObject$LWS);
        }

        if (isFrameIndexKey$LWS(key$LWS)) {
          return getFrameByIndexKey$LWS(key$LWS);
        }

        return undefined;
      };

      const isFrame$LWS = value$LWS => value$LWS !== undefined && value$LWS !== globalObject$LWS && sharedDom$LWS.isWindowLike(value$LWS) && sharedDom$LWS.isWindow(value$LWS);

      const isFrameIndexKey$LWS = key$LWS => shared$LWS.RegExpTest(integerRegExp$LWS, key$LWS) && key$LWS < sharedDom$LWS.WindowLengthGetter(globalObject$LWS); // The rules for this proxy are as follows:
      //
      // If the key is a string...
      //      ...And the key is a valid index that matches an existing
      //      index in the frame list or matches the value of a name
      //      property of a frame in the frame list, then return the
      //      appropriate frame from the frame list.
      //
      //      ...Or the key's value is "length", then return the number of
      //      frames in the in the frame list.
      //  Else,
      //      ...Return the value of the key from the shadow target


      class BaseFrameHandler$LWS {
        defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
          return false;
        }

        deleteProperty(_target$LWS, _key$LWS) {
          return false;
        }

        getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
          return undefined;
        }

        isExtensible(_target$LWS) {
          return true;
        }

        ownKeys(_target$LWS) {
          return [];
        }

        preventExtensions(_target$LWS) {
          return true;
        }

        set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
          return false;
        }

        setPrototypeOf(_target$LWS) {
          return false;
        }

      }

      shared$LWS.ReflectSetPrototypeOf(BaseFrameHandler$LWS.prototype, null);
      shared$LWS.ObjectFreeze(BaseFrameHandler$LWS.prototype);

      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.length
          // window.frames[n]
          // window.frames['n']
          const value$LWS = getValueByKey$LWS(key$LWS);

          if (value$LWS !== undefined) {
            return value$LWS;
          } // window.frames.foo when iframe.name is 'foo'


          return shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS);
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              configurable: true,
              enumerable: true,

              get() {
                return getValueByKey$LWS('length');
              },

              set(_v$LWS) {}

            };
          }

          const value$LWS = isFrameIndexKey$LWS(key$LWS) ? getFrameByIndexKey$LWS(key$LWS) : undefined;

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getValueByKey$LWS(key$LWS) !== undefined || shared$LWS.ReflectHas(target$LWS, key$LWS);
        }

        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = shared$LWS.ArrayCtor(length$LWS + 1);

          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }

          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }

      }

      class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.foo when iframe.name is 'foo'
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ? shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS) : value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getFrameByNameKey$LWS(key$LWS) !== undefined || shared$LWS.ReflectHas(target$LWS, key$LWS);
        }

        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const descMap$LWS = shared$LWS.ObjectGetOwnPropertyDescriptors(WindowProperties$LWS);
          shared$LWS.ReflectSetPrototypeOf(descMap$LWS, null);

          for (const key$LWS in descMap$LWS) {
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = descMap$LWS[key$LWS];

              if (shared$LWS.ObjectHasOwnProperty(unsafeDesc$LWS, 'value') && isFrame$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }

          return keys$LWS;
        }

      } // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.


      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = shared$LWS.ObjectFreeze(new ShadowFrameHandler$LWS());
      const shadowFramesPrototypeHandler$LWS = shared$LWS.ObjectFreeze(new ShadowFramesPrototypeHandler$LWS());
      const shadowWindowPropertiesHandler$LWS = shared$LWS.ObjectFreeze(new ShadowWindowPropertiesHandler$LWS());
      const framesPrototypeProxy$LWS = new shared$LWS.ProxyCtor(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new shared$LWS.ProxyCtor(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      shared$LWS.ReflectSetPrototypeOf(shadowFrames$LWS, framesPrototypeProxy$LWS);
      shared$LWS.ReflectSetPrototypeOf(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      framesProxy$LWS = new shared$LWS.ProxyCtor(shadowFrames$LWS, shadowFramesHandler$LWS);
    }

    return framesProxy$LWS;
  };

  return [originalWindowFramesGetter$LWS, frames$LWS];
}

function distortionWindowGetComputedStyle$LWS(globalObject$LWS) {
  const {
    getComputedStyle: originalGetComputedStyle$LWS
  } = globalObject$LWS;

  function getComputedStyle$LWS(...args$LWS) {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalGetComputedStyle$LWS, this, args$LWS));
  }

  return [originalGetComputedStyle$LWS, getComputedStyle$LWS];
}

function distortionWindowLengthGetter$LWS(globalObject$LWS) {
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'length');

  if (typeof originalLengthGetter$LWS !== 'function') {
    return null;
  }

  const length$LWS = function length$LWS() {
    return 0;
  };

  return [originalLengthGetter$LWS, length$LWS];
}

function distortionWindowOnstorage$LWS(globalObject$LWS, options$LWS) {
  const {
    Window: Window$LWS
  } = globalObject$LWS;
  const originalOnstorageSetter$LWS = shared$LWS.ObjectLookupOwnSetter(globalObject$LWS, 'onstorage');

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return null;
  }

  const onstorage$LWS = function onstorage$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set window.onstorage.');
  };

  registerEventTargetRestriction$LWS(Window$LWS, 'storage', options$LWS);
  return [originalOnstorageSetter$LWS, onstorage$LWS];
}

function distortionWindowOpen$LWS(globalObject$LWS) {
  const {
    open: originalWindowOpen$LWS
  } = globalObject$LWS;

  function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    const rawOpenWindow$LWS = shared$LWS.ReflectApply(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
    return sharedDom$LWS.getPatchedWindow(rawOpenWindow$LWS);
  }

  return [originalWindowOpen$LWS, open$LWS];
}

function distortionWindowOpenerGetter$LWS(globalObject$LWS) {
  const originalOpenerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'opener');

  if (typeof originalOpenerGetter$LWS !== 'function') {
    return null;
  }

  const opener$LWS = function opener$LWS() {
    const rawOpener$LWS = shared$LWS.ReflectApply(originalOpenerGetter$LWS, globalObject$LWS, []);
    return sharedDom$LWS.getPatchedWindow(rawOpener$LWS);
  };

  return [originalOpenerGetter$LWS, opener$LWS];
}

function distortionWindowParentGetter$LWS(globalObject$LWS) {
  const originalParentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'parent');

  if (typeof originalParentGetter$LWS !== 'function') {
    return null;
  }

  const parent$LWS = function parent$LWS() {
    const rawParentWindow$LWS = shared$LWS.ReflectApply(originalParentGetter$LWS, globalObject$LWS, []);
    return sharedDom$LWS.getPatchedWindow(rawParentWindow$LWS);
  };

  return [originalParentGetter$LWS, parent$LWS];
}

function distortionWindowPostMessage$LWS(globalObject$LWS) {
  return [globalObject$LWS.postMessage, sharedDom$LWS.getPatchedPostMessage(globalObject$LWS)];
}

function distortionWindowSetInterval$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setInterval: originalSetInterval$LWS
  } = globalObject$LWS;

  function setInterval$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = shared$LWS.toString(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return shared$LWS.ReflectApply(originalSetInterval$LWS, this, args$LWS);
  }

  return [originalSetInterval$LWS, setInterval$LWS];
}

function distortionWindowSetTimeout$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setTimeout: originalSetTimeout$LWS
  } = globalObject$LWS;

  function setTimeout$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = shared$LWS.toString(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return shared$LWS.ReflectApply(originalSetTimeout$LWS, this, args$LWS);
  }

  return [originalSetTimeout$LWS, setTimeout$LWS];
}

function distortionWindowStructuredClone$LWS(globalObject$LWS) {
  const {
    structuredClone: originalStructuredClone$LWS
  } = globalObject$LWS;

  if (typeof originalStructuredClone$LWS !== 'function') {
    return null;
  }

  const structuredClone$LWS = function structuredClone$LWS(...args$LWS) {
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = sharedDom$LWS.partialStructuredClone(args$LWS);
    }

    return shared$LWS.ReflectApply(originalStructuredClone$LWS, this, args$LWS);
  };

  return [originalStructuredClone$LWS, structuredClone$LWS];
}

function distortionWorkerCtor$LWS(globalObject$LWS) {
  const {
    Worker: originalWorkerCtor$LWS
  } = globalObject$LWS;

  function Worker$LWS(scriptURL$LWS) {
    throw new shared$LWS.LockerSecurityError(`Cannot create Worker with ${shared$LWS.toString(scriptURL$LWS)}.`);
  }

  return [originalWorkerCtor$LWS, Worker$LWS];
}

function distortionWorkerProto$LWS(globalObject$LWS) {
  const {
    Worker: {
      prototype: originalPrototype$LWS
    }
  } = globalObject$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function distortionXMLHttpRequestOpen$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const {
    open: originalOpen$LWS
  } = XMLHttpRequest$LWS.prototype;

  function open$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));

      if (sharedUrl$LWS.isInvalidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
  }

  return [originalOpen$LWS, open$LWS];
}

function distortionXMLHttpRequestResponseGetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'response');

  function response$LWS() {
    const rawResponse$LWS = shared$LWS.ReflectApply(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? htmlSanitizer$LWS.sanitizeDocument(rawResponse$LWS) : rawResponse$LWS;
  }

  return [originalResponseGetter$LWS, response$LWS];
}

function distortionXMLHttpRequestResponseXMLGetter$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseXMLGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'responseXML');

  function responseXML$LWS() {
    const rawResponseXML$LWS = shared$LWS.ReflectApply(originalResponseXMLGetter$LWS, this, []);
    return htmlSanitizer$LWS.sanitizeDocument(rawResponseXML$LWS);
  }

  return [originalResponseXMLGetter$LWS, responseXML$LWS];
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const fundamentalDistortionFactories$LWS = [// CSSStyleRule
distortionCSSStyleRuleStyleGetter$LWS, // Document
distortionDocumentDomainSetter$LWS, distortionDocumentExecCommand$LWS, distortionDocumentOpen$LWS, // DOMParser
distortionDOMParserParseFromString$LWS, // Element
distortionElementAttachShadow$LWS, distortionElementAttributesGetter$LWS, distortionElementInnerHTMLSetter$LWS, distortionElementOuterHTMLSetter$LWS, distortionElementInsertAdjacentHTML$LWS, distortionElementRemove$LWS, distortionElementReplaceChildren$LWS, distortionElementReplaceWith$LWS, // Event
distortionEventComposedPath$LWS, distortionEventPathGetter$LWS, // EventTarget
distortionEventTargetAddEventListener$LWS, // History
distortionHistoryPushState$LWS, distortionHistoryReplaceState$LWS, // HTMLElement
distortionHTMLElementDatasetGetter$LWS, distortionHTMLElementInnerTextSetter$LWS, distortionHTMLElementOuterTextSetter$LWS, distortionHTMLElementStyleGetter$LWS, // HTMLFrameElement
distortionHTMLFrameElementContentDocumentGetter$LWS, distortionHTMLFrameElementContentWindowGetter$LWS, // HTMLIFrameElement
distortionHTMLIFrameElementSrcSetter$LWS, distortionHTMLIFrameElementContentDocumentGetter$LWS, distortionHTMLIFrameElementContentWindowGetter$LWS, // HTMLLinkElement
distortionHTMLLinkElementRelSetter$LWS, distortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
distortionHTMLObjectElementContentDocumentGetter$LWS, distortionHTMLObjectElementContentWindowGetter$LWS, // HTMLScriptElement
distortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
distortionIDBObjectStoreAdd$LWS, distortionIDBObjectStorePut$LWS, // MessageEvent
distortionMessageEventSourceGetter$LWS, // Navigator
distortionNavigatorSendBeacon$LWS, distortionNavigatorServiceWorkerGetter$LWS, // Node
distortionNodeRemoveChild$LWS, distortionNodeReplaceChild$LWS, distortionAttrNodeValueSetter$LWS, distortionNodeTextContentSetter$LWS, // Notification
distortionNotificationCtor$LWS, // Range
distortionRangeCreateContextualFragment$LWS, distortionRangeDeleteContents$LWS, distortionRangeExtractContents$LWS, distortionRangeInsertNode$LWS, // ServiceWorkerContainer
distortionServiceWorkerContainer$LWS, // ShadowRoot
distortionShadowRootInnerHTMLSetter$LWS, distortionShadowRootModeGetter$LWS, // SharedWorker
distortionSharedWorkerCtor$LWS, distortionSharedWorkerProto$LWS, // Storage
distortionStorageLength$LWS, distortionStorageGetItem$LWS, distortionStorageSetItem$LWS, distortionStorageKey$LWS, distortionStorageRemoveItem$LWS, distortionStorageClear$LWS, distortionStorage$LWS, // SVGAnimateElement
distortionSVGAnimateElementAttributeNameAttribute$LWS, distortionSVGAnimateElementFromAttribute$LWS, distortionSVGAnimateElementToAttribute$LWS, distortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
distortionSVGElementDatasetGetter$LWS, // SVGSetElement
distortionSVGSetElementAttributeNameAttribute$LWS, distortionSVGSetElementToAttribute$LWS, // SVGUseElement
distortionSVGUseElementHrefAttribute$LWS, distortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
distortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
distortionURLCreateObjectURL$LWS, // Window
distortionWindowFetch$LWS, distortionWindowFramesGetter$LWS, distortionWindowGetComputedStyle$LWS, distortionWindowLengthGetter$LWS, distortionWindowOnstorage$LWS, distortionWindowOpen$LWS, distortionWindowOpenerGetter$LWS, distortionWindowParentGetter$LWS, distortionWindowPostMessage$LWS, distortionWindowStructuredClone$LWS, // Worker
distortionWorkerCtor$LWS, distortionWorkerProto$LWS, // XHR
distortionXMLHttpRequestOpen$LWS, distortionXMLHttpRequestResponseGetter$LWS, distortionXMLHttpRequestResponseXMLGetter$LWS];
const fundamentalKeyedDistortionFactories$LWS = [// Aura
distortionAuraUtilGlobalEval$LWS, // Attr
distortionAttrValueSetter$LWS, // CacheStorage
distortionCacheStorageDelete$LWS, distortionCacheStorageHas$LWS, distortionCacheStorageKeys$LWS, distortionCacheStorageMatch$LWS, distortionCacheStorageOpen$LWS, // CookieStore
distortionCookieStoreDelete$LWS, distortionCookieStoreGet$LWS, distortionCookieStoreGetAll$LWS, distortionCookieStoreOnChange$LWS, distortionCookieStoreSet$LWS, // Document
distortionDocumentCookieGetter$LWS, distortionDocumentCookieSetter$LWS, distortionDocumentReplaceChildren$LWS, // CustomElementRegistry
distortionCustomElementRegistryGet$LWS, // Element
distortionElementSetAttribute$LWS, distortionElementSetAttributeNS$LWS, distortionElementSetAttributeNode$LWS, distortionElementSetAttributeNodeNS$LWS, distortionElementToggleAttribute$LWS, // HTMLScriptElement,
distortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
distortionNamedNodeMapSetNamedItem$LWS, distortionNamedNodeMapSetNamedItemNS$LWS, // SVGScriptElement
distortionSVGScriptElementHrefAttribute$LWS, // Window
distortionWindowSetInterval$LWS, distortionWindowSetTimeout$LWS, // Storage
distortionLocalStorage$LWS, distortionSessionStorage$LWS];
const secondaryExternalDistortionFactories$LWS = [// Element
distortionElementAfter$LWS, distortionElementAppend$LWS, distortionElementBefore$LWS, distortionElementInsertAdjacentElement$LWS, distortionElementPrepend$LWS, distortionElementShadowRootGetter$LWS, // Node
// The distortionNodeAppendChild distortion is temporarily disabled until W-10409618 is resolved
// distortionNodeAppendChild,
distortionNodeInsertBefore$LWS];
const secondaryExternalKeyedDistortionFactories$LWS = [];
const secondaryInternalDistortionsFactories$LWS = [];
const secondaryInternalKeyedDistortionFactories$LWS = [];
const externalDistortionFactories$LWS = shared$LWS.ArrayConcat(fundamentalDistortionFactories$LWS, secondaryExternalDistortionFactories$LWS);
const externalKeyedDistortionFactories$LWS = shared$LWS.ArrayConcat(fundamentalKeyedDistortionFactories$LWS, secondaryExternalKeyedDistortionFactories$LWS);
const internalDistortionFactories$LWS = shared$LWS.ArrayConcat(fundamentalDistortionFactories$LWS, secondaryInternalDistortionsFactories$LWS);
const internalKeyedDistortionFactories$LWS = shared$LWS.ArrayConcat(fundamentalKeyedDistortionFactories$LWS, secondaryInternalKeyedDistortionFactories$LWS);
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument']; // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
const externalDistortionCache$LWS = new shared$LWS.WeakMapCtor();
const internalDistortionCache$LWS = new shared$LWS.WeakMapCtor();

function makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    Element: Element$LWS,
    HTMLElement: HTMLElement$LWS,
    HTMLIFrameElement: HTMLIFrameElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XSLTProcessor: XSLTProcessor$LWS
  } = globalObject$LWS;
  const blockedPropertyDistortionFactories$LWS = [];
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(CustomElementRegistry.prototype, CustomElementRegistryBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Document$LWS.prototype, DocumentBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Element$LWS.prototype, ElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS));
  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS));

  if (typeof XSLTProcessor$LWS === 'function') {
    shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS));
  }

  distortBlockedAttributes$LWS(HTMLElement$LWS, HTMLElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLIFrameElement$LWS, HTMLIFrameElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLScriptElement$LWS, HTMLScriptElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(SVGElement$LWS, SVGElementBlockedAttributes$LWS);
  return blockedPropertyDistortionFactories$LWS;
}

function instrumentDistortionForSandbox$LWS(sandboxKey$LWS, fn$LWS, instrumentation$LWS, verboseInstrumentation$LWS, factoryName$LWS) {
  const {
    error,
    startActivity: startActivity$LWS
  } = instrumentation$LWS;

  if (verboseInstrumentation$LWS) {
    const factoryNameNoMarker$LWS = shared$LWS.StringReplace(factoryName$LWS, shared$LWS.LOCKER_IDENTIFIER_MARKER, '');
    return function verboseInstrumentedDistortionWrapper$LWS(...args$LWS) {
      const activity$LWS = startActivity$LWS(factoryNameNoMarker$LWS, {
        sandboxKey: sandboxKey$LWS
      });

      try {
        return shared$LWS.ReflectApply(fn$LWS, this, args$LWS);
      } catch (e$LWS) {
        error({
          sandboxKey: sandboxKey$LWS,
          error: e$LWS
        });
        throw e$LWS;
      } finally {
        activity$LWS.stop();
      }
    };
  }

  return function instrumentedDistortionWrapper$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(fn$LWS, this, args$LWS);
    } catch (e$LWS) {
      error({
        sandboxKey: sandboxKey$LWS,
        error: e$LWS
      });
      throw e$LWS;
    }
  };
}

function addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS) {
  const {
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = config$LWS;
  const options$LWS = {
    evaluator: evaluator$LWS,
    key: key$LWS,
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS
  };
  const pair$LWS = factory$LWS(globalObject$LWS, options$LWS);

  if (pair$LWS) {
    const {
      0: rawValue$LWS,
      1: distortedValue$LWS
    } = pair$LWS;

    if (rawValue$LWS) {
      let maybeInstrumentedDistortedValue$LWS = distortedValue$LWS;

      if (typeof distortedValue$LWS === 'function') {
        maybeInstrumentedDistortedValue$LWS = instrumentDistortionForSandbox$LWS(key$LWS, distortedValue$LWS, instrumentation$LWS, !!verboseInstrumentation$LWS, factory$LWS.name || '<unknown>');
      }

      entries$LWS[entries$LWS.length] = [rawValue$LWS, maybeMaskDistortion$LWS(maybeInstrumentedDistortedValue$LWS, rawValue$LWS)];
    }
  }
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages


function createExternalDistortionEntries$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS) {
  const entries$LWS = [];
  const cached$LWS = shared$LWS.WeakMapGet(externalDistortionCache$LWS, globalObject$LWS);

  if (cached$LWS) {
    shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, entries$LWS, cached$LWS);
  } else {
    const blockedPropertyDistortions$LWS = makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = blockedPropertyDistortions$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = blockedPropertyDistortions$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    for (let i$LWS = 0, {
      length: length$LWS
    } = externalDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = externalDistortionFactories$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    shared$LWS.WeakMapSet(externalDistortionCache$LWS, globalObject$LWS, shared$LWS.shallowCloneArray(entries$LWS));
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = externalKeyedDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = externalKeyedDistortionFactories$LWS[i$LWS];
    addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
  }

  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, entries$LWS, makeElementDistortionsForSandboxKey$LWS(key$LWS));
  return entries$LWS;
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages


function createInternalDistortionEntries$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS) {
  const entries$LWS = [];
  const cached$LWS = shared$LWS.WeakMapGet(internalDistortionCache$LWS, globalObject$LWS);

  if (cached$LWS) {
    shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, entries$LWS, cached$LWS);
  } else {
    const blockedPropertyDistortions$LWS = makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = blockedPropertyDistortions$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = blockedPropertyDistortions$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    for (let i$LWS = 0, {
      length: length$LWS
    } = internalDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = internalDistortionFactories$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    shared$LWS.WeakMapSet(internalDistortionCache$LWS, globalObject$LWS, shared$LWS.shallowCloneArray(entries$LWS));
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = internalKeyedDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = internalKeyedDistortionFactories$LWS[i$LWS];
    addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
  }

  shared$LWS.ReflectApply(shared$LWS.ArrayProtoPush, entries$LWS, makeElementDistortionsForSandboxKey$LWS(key$LWS));
  return entries$LWS;
}

exports.createExternalDistortionEntries = createExternalDistortionEntries$LWS;
exports.createInternalDistortionEntries = createInternalDistortionEntries$LWS;
/*! version: 0.15.16 */
