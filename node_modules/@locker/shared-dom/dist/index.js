/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { ObjectLookupOwnGetter as ObjectLookupOwnGetter$LWS, ReflectGetOwnPropertyDescriptor as ReflectGetOwnPropertyDescriptor$LWS, ReflectApply as ReflectApply$LWS, StringToUpperCase as StringToUpperCase$LWS, WeakMapCtor as WeakMapCtor$LWS, escapeRegExp as escapeRegExp$LWS, SANDBOX_EVAL_CONTEXT_NAME as SANDBOX_EVAL_CONTEXT_NAME$LWS, WEBPACK_REQUIRE_NAME as WEBPACK_REQUIRE_NAME$LWS, WeakMapGet as WeakMapGet$LWS, WeakMapSet as WeakMapSet$LWS, RegExpTest as RegExpTest$LWS, StringReplace as StringReplace$LWS, UNCOMPILED_LOCATION_NAME as UNCOMPILED_LOCATION_NAME$LWS, ArrayJoin as ArrayJoin$LWS, StringToLowerCase as StringToLowerCase$LWS, MapCtor as MapCtor$LWS, MapClear as MapClear$LWS, ArrayShift as ArrayShift$LWS, MapGet as MapGet$LWS, getBrand as getBrand$LWS, TO_STRING_BRAND_SET as TO_STRING_BRAND_SET$LWS, TO_STRING_BRAND_MAP as TO_STRING_BRAND_MAP$LWS, TO_STRING_BRAND_ARRAY as TO_STRING_BRAND_ARRAY$LWS, ArrayCtor as ArrayCtor$LWS, TO_STRING_BRAND_OBJECT as TO_STRING_BRAND_OBJECT$LWS, ReflectGetPrototypeOf as ReflectGetPrototypeOf$LWS, ObjectProto as ObjectProto$LWS, isNearMembrane as isNearMembrane$LWS, MapSet as MapSet$LWS, TO_STRING_BRAND_STRING as TO_STRING_BRAND_STRING$LWS, ObjectCtor as ObjectCtor$LWS, getNearMembraneSerializedValue as getNearMembraneSerializedValue$LWS, TO_STRING_BRAND_BIG_INT as TO_STRING_BRAND_BIG_INT$LWS, TO_STRING_BRAND_NUMBER as TO_STRING_BRAND_NUMBER$LWS, TO_STRING_BRAND_BOOLEAN as TO_STRING_BRAND_BOOLEAN$LWS, TO_STRING_BRAND_REG_EXP as TO_STRING_BRAND_REG_EXP$LWS, RegExpCtor as RegExpCtor$LWS, MapEntries as MapEntries$LWS, JSONParse as JSONParse$LWS, SetCtor as SetCtor$LWS, SetValues as SetValues$LWS, SetAdd as SetAdd$LWS, ObjectKeys as ObjectKeys$LWS, ObjectLookupOwnSetter as ObjectLookupOwnSetter$LWS, ObjectHasOwnProperty as ObjectHasOwnProperty$LWS, toSafeDescriptor as toSafeDescriptor$LWS, FunctionBind as FunctionBind$LWS, ReflectDefineProperty as ReflectDefineProperty$LWS } from '@locker/shared';
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Attr.prototype, 'value');

function AttrNameGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
}

function AttrNamespaceURIGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
}

function AttrOwnerElementGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, []);
}

function AttrValueGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
}

function AttrValueSetter$LWS(attr$LWS, value$LWS) {
  ReflectApply$LWS(AttrProtoValueSetter$LWS, attr$LWS, [value$LWS]);
}

const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Document.prototype, 'cookie');
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = Document.prototype;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'body');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'implementation');

function DocumentBodyGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, []);
}

function DocumentCookieGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoCookieGetter$LWS, doc$LWS, []);
}

function DocumentCookieSetter$LWS(doc$LWS, newCookie$LWS) {
  ReflectApply$LWS(DocumentProtoCookieSetter$LWS, doc$LWS, [newCookie$LWS]);
}

function DocumentImplementation$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
}

function DocumentCreateComment$LWS(doc$LWS, data$LWS = '') {
  return ReflectApply$LWS(DocumentProtoCreateComment$LWS, doc$LWS, [data$LWS]);
}

function DocumentCreateElement$LWS(doc$LWS, ...args$LWS) {
  return ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, args$LWS);
}

function DocumentCreateElementNS$LWS(doc$LWS, ...args$LWS) {
  return ReflectApply$LWS(DocumentProtoCreateElementNS$LWS, doc$LWS, args$LWS);
}

function DocumentDocumentElementGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, doc$LWS, []);
}

function DocumentGetElementById$LWS(doc$LWS, id$LWS) {
  return ReflectApply$LWS(DocumentProtoGetElementById$LWS, doc$LWS, [id$LWS]);
}

function DocumentHeadGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoHeadGetter$LWS, doc$LWS, []);
}

function nsCookieRootKey$LWS(ns$LWS) {
  return `LSKey-${ns$LWS}$`;
}

function nsCookieKey$LWS(key$LWS, ns$LWS) {
  return `${nsCookieRootKey$LWS(ns$LWS)}${key$LWS}`;
}

const {
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = Element.prototype;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS
} = Element.prototype;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Element.prototype, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Element.prototype, 'outerHTML');
const ElementProtoGetNamespaceURI$LWS = ObjectLookupOwnGetter$LWS(Element.prototype, 'namespaceURI');

function ElementClosest$LWS(el$LWS, selectors$LWS) {
  return ReflectApply$LWS(ElementProtoClosest$LWS, el$LWS, [selectors$LWS]);
}

function ElementInnerHTMLGetter$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, el$LWS, []);
}

function ElementInnerHTMLSetter$LWS(el$LWS, html$LWS) {
  ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, el$LWS, [html$LWS]);
}

function ElementOuterHTMLGetter$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoOuterHTMLGetter$LWS, el$LWS, []);
}

function ElementQuerySelector$LWS(el$LWS, selectors$LWS) {
  return ReflectApply$LWS(ElementProtoQuerySelector$LWS, el$LWS, [selectors$LWS]);
}

function ElementGetAttribute$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
}

function ElementGetAttributeNode$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttributeNode$LWS, el$LWS, [attrName$LWS]);
}

function ElementGetAttributeNodeNS$LWS(el$LWS, namespace$LWS, nodeName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttributeNodeNS$LWS, el$LWS, [namespace$LWS, nodeName$LWS]);
}

function ElementHasAttribute$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS]);
}

function ElementSetAttribute$LWS(el$LWS, name$LWS, value$LWS) {
  return ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, [name$LWS, value$LWS]);
}

function ElementSetAttributeNS$LWS(el$LWS, namespace$LWS, name$LWS, value$LWS) {
  return ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, el$LWS, [namespace$LWS, name$LWS, value$LWS]);
}

function ElementRemoveAttributeNode$LWS(el$LWS, attrNode$LWS) {
  return ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, el$LWS, [attrNode$LWS]);
}

function ElementGetNamespaceURI$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoGetNamespaceURI$LWS, el$LWS, []);
}

const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLTemplateElement.prototype, 'content');

function HTMLTemplateElementContentGetter$LWS(template$LWS) {
  return ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, template$LWS, []);
}

const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'firstChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'ownerDocument');

function NodeAppendChild$LWS(node$LWS, childNode$LWS) {
  return ReflectApply$LWS(NodeProtoAppendChild$LWS, node$LWS, [childNode$LWS]);
}

function NodeChildNodesGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, node$LWS, []);
}

function NodeClone$LWS(node$LWS, deep$LWS = false) {
  return ReflectApply$LWS(NodeProtoCloneNode$LWS, node$LWS, [deep$LWS]);
}

function NodeFirstChildGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoFirstChildGetter$LWS, node$LWS, []);
}

function NodeIsEqualNode$LWS(node$LWS, otherNode$LWS) {
  return ReflectApply$LWS(NodeProtoIsEqualNode$LWS, node$LWS, [otherNode$LWS]);
}

function NodeNameGetter$LWS(node$LWS) {
  // Normalize nodeName to upper case.
  // See https://johnresig.com/blog/nodename-case-sensitivity/.
  return StringToUpperCase$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []));
}

function NodeOwnerDocumentGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, node$LWS, []);
}

const globalObjectToValidatorMap$LWS = new WeakMapCtor$LWS();
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExp(`\\b${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}\\b`);
const webpackRequireNameRegExp$LWS = new RegExp(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExp(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? HTMLTemplateElementContentGetter$LWS(leftRoot$LWS) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? HTMLTemplateElementContentGetter$LWS(rightRoot$LWS) : rightRoot$LWS;

  if (NodeIsEqualNode$LWS(leftRootNode$LWS, rightRootNode$LWS)) {
    const leftChildNodes$LWS = NodeChildNodesGetter$LWS(leftRootNode$LWS);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = NodeChildNodesGetter$LWS(rightRootNode$LWS);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class Validator$LWS {
  constructor(globalObject$LWS) {
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ElementInnerHTMLSetter$LWS(this._templates.left, leftString$LWS);
      ElementInnerHTMLSetter$LWS(this._templates.right, rightString$LWS);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === DocumentHeadGetter$LWS(this._document) || element$LWS === DocumentBodyGetter$LWS(this._document) || element$LWS === DocumentDocumentElementGetter$LWS(this._document);

    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isMediaSourceObject = object$LWS => // MediaSource may not be defined in some browsers
    this._constructors.MediaSource && object$LWS instanceof this._constructors.MediaSource;

    const {
      document: document$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    } = globalObject$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: DocumentCreateElement$LWS(this._document, 'template'),
      right: DocumentCreateElement$LWS(this._document, 'template')
    };
  }

}

function getValidator$LWS(globalObject$LWS) {
  let validator$LWS = WeakMapGet$LWS(globalObjectToValidatorMap$LWS, globalObject$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(globalObject$LWS);
    WeakMapSet$LWS(globalObjectToValidatorMap$LWS, globalObject$LWS, validator$LWS);
  }

  return validator$LWS;
}

function transformUncompiledSource$LWS(source$LWS) {
  // To avoid conflicts with anyone else using SANDBOX_EVAL_CONTEXT_NAME,
  // we sniff the source code to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (RegExpTest$LWS(sandboxEvalContextNameRegExp$LWS, source$LWS)) {
    return source$LWS;
  }

  const destructuredBlueHelpers$LWS = []; // Input `source` is uncompiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  let locationTransformed$LWS = false;
  source$LWS = StringReplace$LWS(source$LWS, // RegExp.prototype[Symbol.replace] resets the lastIndex of global
  // regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  RegExpTest$LWS(webpackRequireNameRegExp$LWS, source$LWS) ? locationReferencesWithWebPackRegExp$LWS : locationReferencesRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
    locationTransformed$LWS = true;
    return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
  });

  if (locationTransformed$LWS) {
    destructuredBlueHelpers$LWS[destructuredBlueHelpers$LWS.length] = UNCOMPILED_LOCATION_NAME$LWS;
  }

  if (destructuredBlueHelpers$LWS.length) {
    source$LWS = `const {
            ${ArrayJoin$LWS(destructuredBlueHelpers$LWS, ',')}} = ${SANDBOX_EVAL_CONTEXT_NAME$LWS};${source$LWS}`;
  }

  return source$LWS;
}

const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(Blob.prototype, 'size');
const {
  slice: BlobProtoSlice$LWS
} = Blob.prototype;
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS(Blob.prototype, 'type');
const BlobCtor$LWS = Blob;

function BlobSizeGetter$LWS(blob$LWS) {
  return ReflectApply$LWS(BlobProtoSizeGetter$LWS, blob$LWS, []);
}

function BlobSlice$LWS(blob$LWS, ...args$LWS) {
  return ReflectApply$LWS(BlobProtoSlice$LWS, blob$LWS, args$LWS);
}

function BlobTypeGetter$LWS(blob$LWS) {
  return StringToLowerCase$LWS(ReflectApply$LWS(BlobProtoTypeGetter$LWS, blob$LWS, []));
}

const SEEN_OBJECTS_MAP$LWS = new MapCtor$LWS();

function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = MapEntries$LWS(map$LWS); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      MapSet$LWS(clone$LWS, subCloneKey$LWS, subCloneValue$LWS);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneSerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = SetValues$LWS(set$LWS); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      SetAdd$LWS(clone$LWS, subCloneValue$LWS);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ArrayShift$LWS(queue$LWS); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = MapGet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = getBrand$LWS(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS(originalValue$LWS);

          if (proto$LWS === ObjectProto$LWS || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = new ArrayCtor$LWS(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      if (!isNearMembrane$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        MapSet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN$LWS: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER$LWS: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT$LWS: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING$LWS:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    MapSet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  MapClear$LWS(SEEN_OBJECTS_MAP$LWS);
  return result$LWS;
}

const {
  getElementById: DocumentFragmentProtoGetElementById$LWS,
  querySelector: DocumentFragmentProtoQuerySelector$LWS
} = DocumentFragment.prototype;

function DocumentFragmentGetElementById$LWS(fragment$LWS, id$LWS) {
  return ReflectApply$LWS(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [id$LWS]);
}

function DocumentFragmentQuerySelector$LWS(doc$LWS, value$LWS) {
  return ReflectApply$LWS(DocumentFragmentProtoQuerySelector$LWS, doc$LWS, [value$LWS]);
}

const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;

function DOMImplementationCreateDocument$LWS(domImplementation$LWS, ...args$LWS) {
  return ReflectApply$LWS(DOMImplementationProtoCreateDocument$LWS, domImplementation$LWS, args$LWS);
}

const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenList.prototype, 'value');

function DOMTokenListValueGetter$LWS(tokenList$LWS) {
  return ReflectApply$LWS(DOMTokenListProtoValueGetter$LWS, tokenList$LWS, []);
}

const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS(Event.prototype, 'currentTarget');

function EventCurrentTargetGetter$LWS(event$LWS) {
  return ReflectApply$LWS(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
}

const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;

function EventTargetAddEventListener$LWS(target$LWS, ...args$LWS) {
  return ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, target$LWS, args$LWS);
}

const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'protocol');

function HTMLAnchorElementHostnameGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementHrefGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementHrefSetter$LWS(anchor$LWS, href$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, anchor$LWS, [href$LWS]);
}

function HTMLAnchorElementPathnameGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoPathnameGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementProtocolGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, anchor$LWS, []);
}

const HTMLElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'dataset');

function HTMLElementDatasetGetter$LWS(el$LWS) {
  return ReflectApply$LWS(HTMLElementProtoDatasetGetter$LWS, el$LWS, []);
}

const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement.prototype, 'src');

function HTMLIFrameElementSrcSetter$LWS(iframe$LWS, src$LWS) {
  ReflectApply$LWS(HTMLIFrameElementProtoSrcSetter$LWS, iframe$LWS, [src$LWS]);
}

const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const {
  createContextualFragment: RangeProtoCreateContextualFragment$LWS
} = Range.prototype;
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS(Request.prototype, 'url'); // This has to be done 1-by-1 because putting a full file ignore in this file will result in
// dist/index.js containing the directive and subsequently being ignored.
// istanbul ignore next

function RequestURLGetter$LWS(request$LWS) {
  return ReflectApply$LWS(RequestProtoURLGetter$LWS, request$LWS, []);
}

const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement.prototype, 'dataset');

function SVGElementDatasetGetter$LWS(svg$LWS) {
  return ReflectApply$LWS(SVGElementProtoDatasetGetter$LWS, svg$LWS, []);
}

const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL;
const ALLOW_LIST_PATCHED$LWS = ['opener', 'parent'];
const ALLOW_LIST_RAW$LWS = ['close', 'closed', 'focus'];
const DEFAULT_OVERWRITTEN_VALUE$LWS = {};
const rawToPatchedWindowMap$LWS = new WeakMapCtor$LWS(); // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowStaticClearInterval$LWS,
  setInterval: WindowStaticSetInterval$LWS
} = window;
const WindowStaticLengthGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'length');
const WindowStaticSelfGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'self');
const {
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS
} = window; // istanbul ignore next

function createPatchedWindow$LWS(win$LWS) {
  const patchedWindow$LWS = {};

  for (let i$LWS = 0, {
    length: length$LWS
  } = ALLOW_LIST_RAW$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ALLOW_LIST_RAW$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, key$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        value: originalValue$LWS
      } = safeDesc$LWS;

      if (typeof originalValue$LWS === 'function') {
        const bound$LWS = FunctionBind$LWS(originalValue$LWS, win$LWS);
        const unsafeNameDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalValue$LWS, 'name');

        if (unsafeNameDesc$LWS) {
          ReflectDefineProperty$LWS(bound$LWS, 'name', toSafeDescriptor$LWS(unsafeNameDesc$LWS));
        }

        unsafeDesc$LWS.value = bound$LWS;
      } else {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;
        let overwrittenValue$LWS = DEFAULT_OVERWRITTEN_VALUE$LWS;

        if (typeof getter$LWS === 'function') {
          safeDesc$LWS.get = function get$LWS() {
            return overwrittenValue$LWS === DEFAULT_OVERWRITTEN_VALUE$LWS ? ReflectApply$LWS(getter$LWS, win$LWS, []) : overwrittenValue$LWS;
          };
        }

        if (typeof setter$LWS === 'function') {
          safeDesc$LWS.set = function set$LWS(value$LWS) {
            overwrittenValue$LWS = value$LWS;
          };
        }
      }

      ReflectDefineProperty$LWS(patchedWindow$LWS, key$LWS, safeDesc$LWS);
    }
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = ALLOW_LIST_PATCHED$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ALLOW_LIST_PATCHED$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, key$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        get: getter$LWS,
        set: setter$LWS
      } = safeDesc$LWS;
      let overwrittenValue$LWS = DEFAULT_OVERWRITTEN_VALUE$LWS;

      if (typeof getter$LWS === 'function') {
        safeDesc$LWS.get = function get$LWS() {
          if (overwrittenValue$LWS === DEFAULT_OVERWRITTEN_VALUE$LWS) {
            return getPatchedWindow$LWS(ReflectApply$LWS(getter$LWS, win$LWS, []));
          }

          return overwrittenValue$LWS;
        };
      }

      if (typeof setter$LWS === 'function') {
        safeDesc$LWS.set = function set$LWS(value$LWS) {
          overwrittenValue$LWS = value$LWS;
        };
      }

      ReflectDefineProperty$LWS(patchedWindow$LWS, key$LWS, safeDesc$LWS);
    }
  }

  const unsafePostMessageDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, 'postMessage');

  if (unsafePostMessageDesc$LWS) {
    const safeDesc$LWS = toSafeDescriptor$LWS(unsafePostMessageDesc$LWS);
    safeDesc$LWS.value = getPatchedPostMessage$LWS(win$LWS);
    ReflectDefineProperty$LWS(patchedWindow$LWS, 'postMessage', safeDesc$LWS);
  }

  return patchedWindow$LWS;
}

function getPatchedPostMessage$LWS(win$LWS) {
  const {
    postMessage: originalPostMessage$LWS
  } = win$LWS;
  return function postMessage$LWS(...args$LWS) {
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalPostMessage$LWS, win$LWS, args$LWS);
  };
} // istanbul ignore next


function getPatchedWindow$LWS(win$LWS) {
  let patchedContentWindow$LWS = null;

  if (win$LWS) {
    patchedContentWindow$LWS = WeakMapGet$LWS(rawToPatchedWindowMap$LWS, win$LWS);

    if (patchedContentWindow$LWS === undefined) {
      patchedContentWindow$LWS = createPatchedWindow$LWS(win$LWS);
      WeakMapSet$LWS(rawToPatchedWindowMap$LWS, win$LWS, patchedContentWindow$LWS);
    }
  }

  return patchedContentWindow$LWS;
}

function isWindow$LWS(value$LWS) {
  // slower check that must certainly detect a window object
  try {
    // window.self getter only works for a window object, otherwise it throws,
    // additionally, this works fine for a detached window as well, which is
    // important since it will guarantee that this check works also for iframes
    // that are disconnected, and could be connected later on, that should not
    // bypass this check. This check is is also equivalent to window.frames, and
    // here is the very simple spec for this getter:
    // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
    WindowSelfGetter$LWS(value$LWS);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}

  return false;
}

function isWindowLike$LWS(value$LWS) {
  // fast check to narrow down when to do the slow check for window objects
  // window.top is unforgeable, this means this check should be safe from
  // user-intervention to try to bypass this check.
  return ObjectHasOwnProperty$LWS(value$LWS, 'top');
}

function WindowClearInterval$LWS(win$LWS, intervalID$LWS) {
  return ReflectApply$LWS(WindowStaticClearInterval$LWS, win$LWS, [intervalID$LWS]);
}

function WindowLengthGetter$LWS(win$LWS) {
  return ReflectApply$LWS(WindowStaticLengthGetter$LWS, win$LWS, []);
}

function WindowSelfGetter$LWS(win$LWS) {
  return ReflectApply$LWS(WindowStaticSelfGetter$LWS, win$LWS, []);
}

function WindowSetInterval$LWS(win$LWS, ...args$LWS) {
  return ReflectApply$LWS(WindowStaticSetInterval$LWS, win$LWS, args$LWS);
} // This has to be done 1-by-1 because putting a full file ignore in this file will result in
// dist/index.js containing the directive and subsequently being ignored.
// istanbul ignore next


const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials'); // istanbul ignore next

const {
  open: XhrProtoOpen$LWS
} = XhrProto$LWS; // istanbul ignore next

function XhrOpen$LWS(xhr$LWS, requestMethod$LWS, url$LWS, async$LWS = true) {
  return ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, [requestMethod$LWS, url$LWS, async$LWS]);
} // istanbul ignore next


function XhrResponseTextGetter$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrSend$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrStatusGetter$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrWithCredentialsSetter$LWS(xhr$LWS, bool$LWS) {
  ReflectApply$LWS(XhrProtoWithCredentialsSetter$LWS, xhr$LWS, [bool$LWS]);
}

export { AttrNameGetter$LWS as AttrNameGetter, AttrNamespaceURIGetter$LWS as AttrNamespaceURIGetter, AttrOwnerElementGetter$LWS as AttrOwnerElementGetter, AttrValueGetter$LWS as AttrValueGetter, AttrValueSetter$LWS as AttrValueSetter, BlobCtor$LWS as BlobCtor, BlobSizeGetter$LWS as BlobSizeGetter, BlobSlice$LWS as BlobSlice, BlobTypeGetter$LWS as BlobTypeGetter, DOMImplementationCreateDocument$LWS as DOMImplementationCreateDocument, DOMTokenListValueGetter$LWS as DOMTokenListValueGetter, DocumentBodyGetter$LWS as DocumentBodyGetter, DocumentCookieGetter$LWS as DocumentCookieGetter, DocumentCookieSetter$LWS as DocumentCookieSetter, DocumentCreateComment$LWS as DocumentCreateComment, DocumentCreateElement$LWS as DocumentCreateElement, DocumentCreateElementNS$LWS as DocumentCreateElementNS, DocumentDocumentElementGetter$LWS as DocumentDocumentElementGetter, DocumentFragmentGetElementById$LWS as DocumentFragmentGetElementById, DocumentFragmentQuerySelector$LWS as DocumentFragmentQuerySelector, DocumentGetElementById$LWS as DocumentGetElementById, DocumentHeadGetter$LWS as DocumentHeadGetter, DocumentImplementation$LWS as DocumentImplementation, ElementClosest$LWS as ElementClosest, ElementGetAttribute$LWS as ElementGetAttribute, ElementGetAttributeNode$LWS as ElementGetAttributeNode, ElementGetAttributeNodeNS$LWS as ElementGetAttributeNodeNS, ElementGetNamespaceURI$LWS as ElementGetNamespaceURI, ElementHasAttribute$LWS as ElementHasAttribute, ElementInnerHTMLGetter$LWS as ElementInnerHTMLGetter, ElementInnerHTMLSetter$LWS as ElementInnerHTMLSetter, ElementOuterHTMLGetter$LWS as ElementOuterHTMLGetter, ElementProtoSetAttribute$LWS as ElementProtoSetAttribute, ElementProtoSetAttributeNS$LWS as ElementProtoSetAttributeNS, ElementQuerySelector$LWS as ElementQuerySelector, ElementRemoveAttributeNode$LWS as ElementRemoveAttributeNode, ElementSetAttribute$LWS as ElementSetAttribute, ElementSetAttributeNS$LWS as ElementSetAttributeNS, EventCurrentTargetGetter$LWS as EventCurrentTargetGetter, EventTargetAddEventListener$LWS as EventTargetAddEventListener, HTMLAnchorElementHostnameGetter$LWS as HTMLAnchorElementHostnameGetter, HTMLAnchorElementHrefGetter$LWS as HTMLAnchorElementHrefGetter, HTMLAnchorElementHrefSetter$LWS as HTMLAnchorElementHrefSetter, HTMLAnchorElementPathnameGetter$LWS as HTMLAnchorElementPathnameGetter, HTMLAnchorElementProtocolGetter$LWS as HTMLAnchorElementProtocolGetter, HTMLElementDatasetGetter$LWS as HTMLElementDatasetGetter, HTMLIFrameElementSrcSetter$LWS as HTMLIFrameElementSrcSetter, HTMLScriptElementProtoSrcGetter$LWS as HTMLScriptElementProtoSrcGetter, HTMLScriptElementProtoSrcSetter$LWS as HTMLScriptElementProtoSrcSetter, HTMLTemplateElementContentGetter$LWS as HTMLTemplateElementContentGetter, NAMESPACE_DEFAULT$LWS as NAMESPACE_DEFAULT, NAMESPACE_SVG$LWS as NAMESPACE_SVG, NAMESPACE_XHTML$LWS as NAMESPACE_XHTML, NAMESPACE_XLINK$LWS as NAMESPACE_XLINK, NodeAppendChild$LWS as NodeAppendChild, NodeChildNodesGetter$LWS as NodeChildNodesGetter, NodeClone$LWS as NodeClone, NodeFirstChildGetter$LWS as NodeFirstChildGetter, NodeIsEqualNode$LWS as NodeIsEqualNode, NodeNameGetter$LWS as NodeNameGetter, NodeOwnerDocumentGetter$LWS as NodeOwnerDocumentGetter, RangeProtoCreateContextualFragment$LWS as RangeProtoCreateContextualFragment, RequestURLGetter$LWS as RequestURLGetter, SVGElementDatasetGetter$LWS as SVGElementDatasetGetter, StorageProtoGetItem$LWS as StorageProtoGetItem, StorageProtoKey$LWS as StorageProtoKey, StorageProtoRemoveItem$LWS as StorageProtoRemoveItem, StorageProtoSetItem$LWS as StorageProtoSetItem, URLCreateObjectURL$LWS as URLCreateObjectURL, URLRevokeObjectURL$LWS as URLRevokeObjectURL, WindowClearInterval$LWS as WindowClearInterval, WindowDecodeURIComponent$LWS as WindowDecodeURIComponent, WindowEncodeURIComponent$LWS as WindowEncodeURIComponent, WindowLengthGetter$LWS as WindowLengthGetter, WindowSelfGetter$LWS as WindowSelfGetter, WindowSetInterval$LWS as WindowSetInterval, XhrCtor$LWS as XhrCtor, XhrOpen$LWS as XhrOpen, XhrResponseTextGetter$LWS as XhrResponseTextGetter, XhrSend$LWS as XhrSend, XhrStatusGetter$LWS as XhrStatusGetter, XhrWithCredentialsSetter$LWS as XhrWithCredentialsSetter, getPatchedPostMessage$LWS as getPatchedPostMessage, getPatchedWindow$LWS as getPatchedWindow, getValidator$LWS as getValidator, isWindow$LWS as isWindow, isWindowLike$LWS as isWindowLike, nsCookieKey$LWS as nsCookieKey, nsCookieRootKey$LWS as nsCookieRootKey, partialStructuredClone$LWS as partialStructuredClone, transformUncompiledSource$LWS as transformUncompiledSource };
/*! version: 0.15.16 */
