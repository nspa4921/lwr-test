/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { ArrayConcat as ArrayConcat$LWS, ArrayFilter as ArrayFilter$LWS, ArrayIncludes as ArrayIncludes$LWS, WeakMapCtor as WeakMapCtor$LWS, WeakMapGet as WeakMapGet$LWS, MapForEach as MapForEach$LWS, WeakMapSet as WeakMapSet$LWS, MapCtor as MapCtor$LWS, SetCtor as SetCtor$LWS, StringStartsWith as StringStartsWith$LWS, SetHas as SetHas$LWS, SetAdd as SetAdd$LWS, SetDelete as SetDelete$LWS, StringSplit as StringSplit$LWS, StringReplace as StringReplace$LWS, StringToLowerCase as StringToLowerCase$LWS } from '@locker/shared';
import { DocumentCreateElement as DocumentCreateElement$LWS, NodeNameGetter as NodeNameGetter$LWS, DocumentGetElementById as DocumentGetElementById$LWS, WindowSetInterval as WindowSetInterval$LWS, XhrCtor as XhrCtor$LWS, EventTargetAddEventListener as EventTargetAddEventListener$LWS, XhrStatusGetter as XhrStatusGetter$LWS, XhrResponseTextGetter as XhrResponseTextGetter$LWS, DocumentFragmentGetElementById as DocumentFragmentGetElementById$LWS, ElementSetAttribute as ElementSetAttribute$LWS, NodeAppendChild as NodeAppendChild$LWS, XhrOpen as XhrOpen$LWS, XhrSend as XhrSend$LWS, HTMLAnchorElementHrefSetter as HTMLAnchorElementHrefSetter$LWS, HTMLAnchorElementHrefGetter as HTMLAnchorElementHrefGetter$LWS, HTMLAnchorElementProtocolGetter as HTMLAnchorElementProtocolGetter$LWS, ElementQuerySelector as ElementQuerySelector$LWS, ElementInnerHTMLSetter as ElementInnerHTMLSetter$LWS, HTMLTemplateElementContentGetter as HTMLTemplateElementContentGetter$LWS, ElementInnerHTMLGetter as ElementInnerHTMLGetter$LWS, ElementOuterHTMLGetter as ElementOuterHTMLGetter$LWS, DocumentDocumentElementGetter as DocumentDocumentElementGetter$LWS, DOMImplementationCreateDocument as DOMImplementationCreateDocument$LWS, DocumentImplementation as DocumentImplementation$LWS, NAMESPACE_XHTML as NAMESPACE_XHTML$LWS, NodeOwnerDocumentGetter as NodeOwnerDocumentGetter$LWS, DocumentCreateComment as DocumentCreateComment$LWS, DocumentCreateElementNS as DocumentCreateElementNS$LWS, NAMESPACE_SVG as NAMESPACE_SVG$LWS, ElementClosest as ElementClosest$LWS, NodeClone as NodeClone$LWS, NodeFirstChildGetter as NodeFirstChildGetter$LWS, WindowClearInterval as WindowClearInterval$LWS, DocumentBodyGetter as DocumentBodyGetter$LWS } from '@locker/shared-dom';
import createDOMPurify$LWS from 'dompurify';
const ariaAttributes$LWS = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-readonly', 'aria-dropeffect', 'aria-expanded', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-disabled', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'role', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allTags$LWS = ArrayConcat$LWS(svgTags$LWS, htmlTags$LWS); // generic, sanitizer attempts in place sanitization and returns node

const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, '#document-fragment'),
  IN_PLACE: true
}; // use only svg tags, sanitizer returns a document fragment

const NODE_SVG$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: svgTags$LWS,
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false
}; // generic, sanitizer returns string

const STRING_ALL$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: allTags$LWS
}; // use only tags allowed for blob and file

const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: ArrayFilter$LWS(allTags$LWS, t$LWS => !ArrayIncludes$LWS(['iframe'], t$LWS)),
  SANITIZE_DOM: false
};
var config$LWS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NODE_ALL_IN_PLACE: NODE_ALL_IN_PLACE$LWS,
  NODE_SVG: NODE_SVG$LWS,
  STRING_ALL: STRING_ALL$LWS,
  STRING_BLOB_HTML: STRING_BLOB_HTML$LWS
});
const instances$LWS = new WeakMapCtor$LWS();

function sanitizer$LWS(config$LWS, hooks$LWS) {
  let dompurify$LWS = WeakMapGet$LWS(instances$LWS, config$LWS);

  if (dompurify$LWS) {
    return dompurify$LWS;
  }

  dompurify$LWS = createDOMPurify$LWS();
  dompurify$LWS.setConfig(config$LWS);

  if (hooks$LWS) {
    MapForEach$LWS(hooks$LWS, (cb$LWS, hookName$LWS) => {
      dompurify$LWS.addHook(hookName$LWS, cb$LWS);
    });
  }

  WeakMapSet$LWS(instances$LWS, config$LWS, dompurify$LWS);
  return dompurify$LWS;
}

const ATTRIBUTES$LWS = ['href', 'xlink:href'];
const SANITIZER_HOOKS$LWS = new MapCtor$LWS([['uponSanitizeAttribute', sanitizeHrefAttributeHook$LWS], ['uponSanitizeElement', allowCustomTagHook$LWS]]);
const URL_SCHEMES$LWS = ['http:', 'https:'];
const {
  document: document$LWS
} = window;
const htmlTemplate$LWS = DocumentCreateElement$LWS(document$LWS, 'template');
const normalizerAnchor$LWS = DocumentCreateElement$LWS(document$LWS, 'a'); // Queue for managing pending xhr requests.

const queue$LWS = new SetCtor$LWS(); // The regexp is based on the WHATWG spec:
// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
// However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.

const customTagRegExp$LWS = /^[a-z]([-_.\w])*-([-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF])*/; // A regexp to find all non lowercase alphanumeric.

const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;

function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (SetHas$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl)) {
    const checkFn$LWS = () => {
      if (!SetHas$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(window, interval$LWS);
      }
    }; // Wait for request to finish, then update content.


    const interval$LWS = WindowSetInterval$LWS(window, checkFn$LWS, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}

function createUrlContainer$LWS(url$LWS) {
  const container$LWS = DocumentCreateElement$LWS(document$LWS, 'div');
  ElementSetAttribute$LWS(container$LWS, 'style', 'display:none');
  ElementSetAttribute$LWS(container$LWS, 'id', url$LWS);
  const body$LWS = DocumentBodyGetter$LWS(document$LWS);
  NodeAppendChild$LWS(body$LWS, container$LWS);
  return container$LWS;
}

function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedUrl); // Put the URL we're fetching in a queue.

  SetAdd$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl); // Initiate an XHR to fetch the resource.

  const xhr$LWS = new XhrCtor$LWS();
  EventTargetAddEventListener$LWS(xhr$LWS, 'load', () => {
    const status$LWS = XhrStatusGetter$LWS(xhr$LWS); // istanbul ignore next: the following is well tested via integration-karma

    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(XhrResponseTextGetter$LWS(xhr$LWS)); // Look for the container again in case other requests have finished
      // earlier for the same URL.

      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = DocumentFragmentGetElementById$LWS(fragment$LWS, normalizedHref$LWS.requestedFragment);

        if (el$LWS) {
          ElementSetAttribute$LWS(el$LWS, 'id', normalizedHref$LWS.normalizedFragment);
        }
      }

      NodeAppendChild$LWS(container$LWS, fragment$LWS);
      SetDelete$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl);
    }
  });
  XhrOpen$LWS(xhr$LWS, 'GET', normalizedHref$LWS.requestedUrl);
  XhrSend$LWS(xhr$LWS);
}

function parseHref$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, url$LWS);
  const href$LWS = HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS);
  const protocol$LWS = HTMLAnchorElementProtocolGetter$LWS(normalizerAnchor$LWS);
  const {
    0: requestedUrl$LWS,
    1: requestedFragment$LWS
  } = StringSplit$LWS(href$LWS, '#');
  const normalizedUrl$LWS = StringReplace$LWS(StringToLowerCase$LWS(requestedUrl$LWS), urlReplacerRegExp$LWS, '');
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedUrl$LWS}_${StringReplace$LWS(requestedFragment$LWS, urlReplacerRegExp$LWS, '')}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedUrl: normalizedUrl$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedUrl: requestedUrl$LWS
  };
}

function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ElementQuerySelector$LWS(container$LWS, `#${normalizedFragment$LWS}`);

  if (!el$LWS) {
    try {
      el$LWS = ElementQuerySelector$LWS(container$LWS, `#${requestedFragment$LWS}`);
      ElementSetAttribute$LWS(el$LWS, 'id', normalizedFragment$LWS);
    } catch (_unused$LWS) {// Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers may
      // have the same ids for svg elements.
    }
  }
}

function blobSanitizer$LWS() {
  return sanitizer$LWS(STRING_BLOB_HTML$LWS, SANITIZER_HOOKS$LWS);
}

function svgSanitizer$LWS() {
  return sanitizer$LWS(NODE_SVG$LWS, SANITIZER_HOOKS$LWS);
}

function sanitize$LWS(dirty$LWS) {
  ElementInnerHTMLSetter$LWS(htmlTemplate$LWS, dirty$LWS);
  const content$LWS = HTMLTemplateElementContentGetter$LWS(htmlTemplate$LWS);
  const sanitizer$1$LWS = sanitizer$LWS(NODE_ALL_IN_PLACE$LWS, SANITIZER_HOOKS$LWS);
  sanitizer$1$LWS.sanitize(content$LWS);
  return ElementInnerHTMLGetter$LWS(htmlTemplate$LWS);
}

function sanitizeDocument$LWS(doc$LWS) {
  const content$LWS = ElementOuterHTMLGetter$LWS(DocumentDocumentElementGetter$LWS(doc$LWS));
  const contentSanitized$LWS = sanitize$LWS(content$LWS);
  const newDoc$LWS = DOMImplementationCreateDocument$LWS(DocumentImplementation$LWS(doc$LWS), NAMESPACE_XHTML$LWS, 'html');
  ElementInnerHTMLSetter$LWS(DocumentDocumentElementGetter$LWS(newDoc$LWS), contentSanitized$LWS);
  return newDoc$LWS;
} // Sanitize a URL representing a SVG href attribute value.


function sanitizeHrefAttributeHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;
  const nodeName$LWS = NodeNameGetter$LWS(node$LWS);

  if (attrValue$LWS && nodeName$LWS === 'USE' && ArrayIncludes$LWS(ATTRIBUTES$LWS, attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }

  return data$LWS;
}

function sanitizeSvgHref$LWS(url$LWS) {
  if (StringStartsWith$LWS(url$LWS, '#')) {
    return url$LWS;
  }

  const normalizedHref$LWS = parseHref$LWS(url$LWS); // Sanitize only for supported URL_SCHEMES.

  if (ArrayIncludes$LWS(URL_SCHEMES$LWS, normalizedHref$LWS.protocol)) {
    const container$LWS = DocumentGetElementById$LWS(document$LWS, normalizedHref$LWS.normalizedUrl); // Have we sanitized this URL already?

    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    } // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.


    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedUrl}`;
  }

  return url$LWS;
}

function createSvgContainer$LWS(ownerDoc$LWS) {
  return DocumentCreateElementNS$LWS(ownerDoc$LWS, NAMESPACE_SVG$LWS, 'svg');
}

function sanitizeSvgInnerHtml$LWS(stringOrSvg$LWS, dirty$LWS = '') {
  let container$LWS;
  const ownerDoc$LWS = typeof stringOrSvg$LWS === 'string' ? document$LWS : NodeOwnerDocumentGetter$LWS(stringOrSvg$LWS);
  const comment$LWS = DocumentCreateComment$LWS(ownerDoc$LWS, '');

  if (typeof stringOrSvg$LWS === 'string') {
    dirty$LWS = stringOrSvg$LWS;
    container$LWS = createSvgContainer$LWS(ownerDoc$LWS);
  } else {
    const closestSvg$LWS = ElementClosest$LWS(stringOrSvg$LWS, 'svg');
    container$LWS = closestSvg$LWS ? NodeClone$LWS(closestSvg$LWS, false) : createSvgContainer$LWS(ownerDoc$LWS);
  }

  NodeAppendChild$LWS(container$LWS, comment$LWS);
  const outerHTML$LWS = ElementOuterHTMLGetter$LWS(container$LWS);
  const replacedOuterHTML$LWS = StringReplace$LWS(outerHTML$LWS, '<!---->', dirty$LWS);
  const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(replacedOuterHTML$LWS);
  const firstChild$LWS = NodeFirstChildGetter$LWS(fragment$LWS);
  return ElementInnerHTMLGetter$LWS(firstChild$LWS);
}

function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const sanitizer$LWS = svgSanitizer$LWS();
  return sanitizer$LWS.sanitize(dirty$LWS);
}

function allowCustomTagHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    allowedTags: allowedTags$LWS,
    tagName: tagName$LWS
  } = data$LWS;

  if (!allowedTags$LWS[tagName$LWS] && customTagRegExp$LWS.test(tagName$LWS)) {
    allowedTags$LWS[tagName$LWS] = true;
  }
}

export { config$LWS as CONFIG, allowCustomTagHook$LWS as allowCustomTagHook, blobSanitizer$LWS as blobSanitizer, sanitize$LWS as sanitize, sanitizeDocument$LWS as sanitizeDocument, sanitizeHrefAttributeHook$LWS as sanitizeHrefAttributeHook, sanitizeSvgHref$LWS as sanitizeSvgHref, sanitizeSvgInnerHtml$LWS as sanitizeSvgInnerHtml, sanitizeSvgTextReturnDOM$LWS as sanitizeSvgTextReturnDOM, sanitizer$LWS as sanitizer, svgSanitizer$LWS as svgSanitizer };
/*! version: 0.15.16 */
