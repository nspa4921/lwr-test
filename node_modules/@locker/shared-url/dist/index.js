/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { RegExpTest as RegExpTest$LWS, StringStartsWith as StringStartsWith$LWS, StringToLowerCase as StringToLowerCase$LWS, ArraySome as ArraySome$LWS, StringIncludes as StringIncludes$LWS, ArrayIncludes as ArrayIncludes$LWS, StringReplace as StringReplace$LWS } from '@locker/shared';
import { DocumentCreateElement as DocumentCreateElement$LWS, HTMLAnchorElementHrefSetter as HTMLAnchorElementHrefSetter$LWS, HTMLAnchorElementProtocolGetter as HTMLAnchorElementProtocolGetter$LWS, HTMLAnchorElementHrefGetter as HTMLAnchorElementHrefGetter$LWS, HTMLAnchorElementHostnameGetter as HTMLAnchorElementHostnameGetter$LWS, WindowDecodeURIComponent as WindowDecodeURIComponent$LWS, HTMLAnchorElementPathnameGetter as HTMLAnchorElementPathnameGetter$LWS } from '@locker/shared-dom'; // Allow only alphanumeric, '-', '+', and '.' characters.

const REGEX_VALID_MIME_TYPE$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;
const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar'];

function isMIMETypeAllowed$LWS(type$LWS) {
  // avoid MIME types which try to escape using special characters
  // Reason: W-4896359
  if (RegExpTest$LWS(REGEX_VALID_MIME_TYPE$LWS, type$LWS)) {
    for (let i$LWS = 0, {
      length: length$LWS
    } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (StringStartsWith$LWS(type$LWS, ALLOWED_MIME_TYPES$LWS[i$LWS])) {
        return true;
      }
    }
  }

  return false;
}

const DEFAULT_URL_SCHEMES$LWS = ['http:', 'https:'];
const DISALLOWED_ENDPOINTS$LWS = ['/aura', '/webruntime'];
const REMOVE_URL_CHARS_REG_EXP$LWS = /[\u2029\u2028\n\r\t]/g;
const normalizerAnchor$LWS = DocumentCreateElement$LWS(document, 'a');
const TRUSTED_DOMAINS$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/; // @TODO W-7302311 Make paths and domains configurable

function isInvalidURL$LWS(parsedURL$LWS) {
  const pathname$LWS = StringToLowerCase$LWS(parsedURL$LWS.pathname);
  return ArraySome$LWS(DISALLOWED_ENDPOINTS$LWS, dep$LWS => StringIncludes$LWS(pathname$LWS, dep$LWS));
}

function isValidURLScheme$LWS(url$LWS, schemes$LWS = DEFAULT_URL_SCHEMES$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, url$LWS);
  return ArrayIncludes$LWS(schemes$LWS, HTMLAnchorElementProtocolGetter$LWS(normalizerAnchor$LWS));
}

function parseURL$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, sanitizeURLString$LWS(url$LWS));
  return {
    normalizedURL: HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS),
    hostname: HTMLAnchorElementHostnameGetter$LWS(normalizerAnchor$LWS),
    pathname: WindowDecodeURIComponent$LWS(HTMLAnchorElementPathnameGetter$LWS(normalizerAnchor$LWS))
  };
}

function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : StringReplace$LWS(urlString$LWS, REMOVE_URL_CHARS_REG_EXP$LWS, '');
}

function sanitizeURLForElement$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, url$LWS);
  return sanitizeURLString$LWS(HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS));
}

export { TRUSTED_DOMAINS$LWS as TRUSTED_DOMAINS, isInvalidURL$LWS as isInvalidURL, isMIMETypeAllowed$LWS as isMIMETypeAllowed, isValidURLScheme$LWS as isValidURLScheme, parseURL$LWS as parseURL, sanitizeURLForElement$LWS as sanitizeURLForElement, sanitizeURLString$LWS as sanitizeURLString };
/*! version: 0.15.16 */
