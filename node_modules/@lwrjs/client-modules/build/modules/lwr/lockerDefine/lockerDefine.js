/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  has: ReflectHas$LWS,
  get: ReflectGet$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  ownKeys: ReflectOwnKeys$LWS
} = Reflect;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  filter: ArrayProtoFilter$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  pop: ArrayProtoPop$LWS,
  shift: ArrayProtoShift$LWS,
  some: ArrayProtoSome$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
const {
  push: ArrayProtoPush$LWS,
  slice: ArrayProtoSlice$LWS
} = ArrayProto$LWS;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
  const {
    length: length$LWS
  } = args$LWS;

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];
    ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, ArrayIsArray$LWS(value$LWS) ? value$LWS : [value$LWS]);
  }

  return result$LWS;
}

function ArrayFilter$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoFilter$LWS, array$LWS, [iteratee$LWS]);
}

function ArrayIncludes$LWS(array$LWS, value$LWS) {
  return ReflectApply$LWS(ArrayProtoIncludes$LWS, array$LWS, [value$LWS]);
}

function ArrayIndexOf$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoIndexOf$LWS, array$LWS, args$LWS);
}

function ArrayJoin$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoJoin$LWS, array$LWS, args$LWS);
}

function ArrayPop$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoPop$LWS, array$LWS, []);
}

function ArrayShift$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoShift$LWS, array$LWS, []);
}

function ArraySlice$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, args$LWS);
}

function ArraySome$LWS(array$LWS, iteratee$LWS) {
  return ReflectApply$LWS(ArrayProtoSome$LWS, array$LWS, [iteratee$LWS]);
}

function ArraySort$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSort$LWS, array$LWS, []);
}

function ArrayUnshift$LWS(array$LWS, ...args$LWS) {
  return ReflectApply$LWS(ArrayProtoUnshift$LWS, array$LWS, args$LWS);
}

const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  freeze: ObjectFreeze$LWS,
  getOwnPropertyNames: ObjectGetOwnPropertyNames$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupGetter__: ObjectProto__lookupGetter__$LWS,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupSetter__: ObjectProto__lookupSetter__$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

function ObjectHasOwnProperty$LWS(object$LWS, key$LWS) {
  return object$LWS !== null && object$LWS !== undefined && ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupGetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return ReflectApply$LWS(ObjectProto__lookupSetter__$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  if (object$LWS === null || object$LWS === undefined || !ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS])) {
    return undefined;
  }

  return object$LWS[key$LWS];
}

function ObjectToString$LWS(object$LWS) {
  return ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength');

function isArrayBuffer$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
    ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  return false;
} // https://caniuse.com/bigint


const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
const isBigIntObject$LWS = SUPPORTS_BIG_INT$LWS ? function isBigIntObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }

  return false;
} : function isBigIntObject$LWS(_value$LWS) {
  return false;
};
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;

function isBooleanObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.3.3 Properties of the Boolean Prototype Object
      // https://tc39.es/ecma262/#thisbooleanvalue
      // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
      //     a. Let b be value.[[BooleanData]].
      //     b. Assert: Type(b) is Boolean.
      ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused3$LWS) {}
  }

  return false;
}

const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  now: DateNow$LWS
} = DateCtor$LWS;

function isDate$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.4.4 Properties of the Date Prototype Object
      // https://tc39.es/ecma262/#thistimevalue
      // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
      //     a. Return value.[[DateValue]].
      // Step 2: Throw a TypeError exception.
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
  }

  return false;
}

const {
  bind: FunctionProtoBind$LWS
} = Function.prototype;

const FunctionBind$LWS = (func$LWS, thisArg$LWS) => ReflectApply$LWS(FunctionProtoBind$LWS, func$LWS, [thisArg$LWS]);

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  entries: MapProtoEntries$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');

function isMap$LWS(value$LWS) {
  try {
    // Section 24.1.3.10 get Map.prototype.size
    // https://tc39.es/ecma262/#sec-get-map.prototype.size
    // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
    ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused5$LWS) {}

  return false;
}

function MapClear$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoClear$LWS, map$LWS, []);
}

function MapEntries$LWS(map$LWS) {
  return ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []);
}

function MapForEach$LWS(map$LWS, iteratee$LWS) {
  return ReflectApply$LWS(MapProtoForEach$LWS, map$LWS, [iteratee$LWS]);
}

function MapGet$LWS(map$LWS, key$LWS) {
  return ReflectApply$LWS(MapProtoGet$LWS, map$LWS, [key$LWS]);
}

function MapSet$LWS(map$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(MapProtoSet$LWS, map$LWS, [key$LWS, value$LWS]);
}

const NumberCtor$LWS = Number;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberCtor$LWS.prototype;
const {
  isFinite: NumberIsFinite$LWS
} = NumberCtor$LWS;

function isNumberObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 21.1.3 Properties of the Number Prototype Object
      // https://tc39.es/ecma262/#thisnumbervalue
      // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
      //     a. Let n be value.[[NumberData]].
      //     b. Assert: Type(n) is Number.
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused6$LWS) {}
  }

  return false;
}

const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  charCodeAt: StringProtoCharCodeAt$LWS,
  includes: StringProtoIncludes$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (!length$LWS) {
    return string$LWS;
  }

  const upper$LWS = StringToUpperCase$LWS(string$LWS[0]);
  return length$LWS === 1 ? upper$LWS : upper$LWS + StringSlice$LWS(string$LWS, 1);
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused7$LWS) {}
  }

  return false;
}

function isStringObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 22.1.3 Properties of the String Prototype Object
      // https://tc39.es/ecma262/#thisstringvalue
      // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
      //     a. Let s be value.[[StringData]].
      //     b. Assert: Type(s) is String.
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
  }

  return false;
}

function StringCharCodeAt$LWS(string$LWS, index$LWS) {
  return ReflectApply$LWS(StringProtoCharCodeAt$LWS, string$LWS, [index$LWS]);
}

function StringIncludes$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoIncludes$LWS, string$LWS, args$LWS);
}

function StringMatch$LWS(string$LWS, regexp$LWS) {
  return ReflectApply$LWS(StringProtoMatch$LWS, string$LWS, [regexp$LWS]);
}

function StringReplace$LWS(string$LWS, pattern$LWS, replacement$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [pattern$LWS, replacement$LWS]);
}

function StringSlice$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, args$LWS);
}

function StringSplit$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoSplit$LWS, string$LWS, args$LWS);
}

function StringStartsWith$LWS(string$LWS, ...args$LWS) {
  return ReflectApply$LWS(StringProtoStartsWith$LWS, string$LWS, args$LWS);
}

function StringToLowerCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToLowerCase$LWS, string$LWS, []);
}

function StringToUpperCase$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS, []);
}

function toString$LWS(value$LWS) {
  try {
    // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value
    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused9$LWS) {}

  return '';
}

function toStringIfNotNullOrUndefined$LWS(value$LWS) {
  return value$LWS === null || value$LWS === undefined ? value$LWS : toString$LWS(value$LWS);
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return StringReplace$LWS(string$LWS, specialCharRegExp$LWS, '\\$&');
}

function isRegExp$LWS(value$LWS) {
  try {
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (value$LWS !== RegExpProto$LWS) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return true;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {}

  return false;
}

function RegExpTest$LWS(regexp$LWS, content$LWS) {
  return ReflectApply$LWS(RegExpProtoTest$LWS, regexp$LWS, [toString$LWS(content$LWS)]);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  add: SetProtoAdd$LWS,
  delete: SetProtoDelete$LWS,
  has: SetProtoHas$LWS,
  values: SetProtoValue$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');

function isSet$LWS(value$LWS) {
  try {
    // Section 24.2.3.9 get Set.prototype.size
    // https://tc39.es/ecma262/#sec-get-set.prototype.size
    // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
    ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused11$LWS) {}

  return false;
}

function SetAdd$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoAdd$LWS, set$LWS, [value$LWS]);
}

function SetDelete$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoDelete$LWS, set$LWS, [value$LWS]);
}

function SetHas$LWS(set$LWS, value$LWS) {
  return ReflectApply$LWS(SetProtoHas$LWS, set$LWS, [value$LWS]);
}

function SetValues$LWS(set$LWS) {
  return ReflectApply$LWS(SetProtoValue$LWS, set$LWS, []);
}

const SymbolCtor$LWS = Symbol;
const {
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS
} = SymbolCtor$LWS;

function isSymbolObject$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 20.4.3 Properties of the Symbol Prototype Object
      // https://tc39.es/ecma262/#thissymbolvalue
      // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
      //     a. Let s be value.[[SymbolData]].
      //     b. Assert: Type(s) is Symbol.
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
  }

  return false;
}

const WeakMapCtor$LWS = WeakMap;
const {
  get: WeakMapProtoGet$LWS,
  has: WeakMapProtoHas$LWS,
  set: WeakMapProtoSet$LWS
} = WeakMapCtor$LWS.prototype;

function isWeakMap$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.3.3.4 WeakMap.prototype.has ( key )
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // Step 2: Perform ? RequireInternalSlot(M, [[WeakMapData]]).
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  return false;
}

function WeakMapGet$LWS(weakMap$LWS, key$LWS) {
  return ReflectApply$LWS(WeakMapProtoGet$LWS, weakMap$LWS, [key$LWS]);
}

function WeakMapSet$LWS(weakMap$LWS, key$LWS, value$LWS) {
  return ReflectApply$LWS(WeakMapProtoSet$LWS, weakMap$LWS, [key$LWS, value$LWS]);
}

const {
  has: WeakSetProtoHas$LWS
} = WeakSet.prototype;

function isWeakSet$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      // Section 24.4.3.4 WeakSet.prototype.has ( value )
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      // Step 2: 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
  }

  return false;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol;

function getBrandByTrailAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  if (isDate$LWS(value$LWS)) {
    return TO_STRING_BRAND_DATE$LWS;
  }

  if (isMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_MAP$LWS;
  }

  if (isRegExp$LWS(value$LWS)) {
    return TO_STRING_BRAND_REG_EXP$LWS;
  }

  if (isSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_SET$LWS;
  }

  if (isWeakMap$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_MAP$LWS;
  }

  if (isWeakSet$LWS(value$LWS)) {
    return TO_STRING_BRAND_WEAK_SET$LWS;
  }

  if (isBigIntObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BIG_INT$LWS;
  }

  if (isBooleanObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_BOOLEAN$LWS;
  }

  if (isNumberObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_NUMBER$LWS;
  }

  if (isStringObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_STRING$LWS;
  }

  if (isSymbolObject$LWS(value$LWS)) {
    return TO_STRING_BRAND_SYMBOL$LWS;
  } // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return ReflectHas$LWS(value$LWS, TO_STRING_TAG_SYMBOL$LWS) ? getBrandByTrailAndError$LWS(value$LWS) : ObjectToString$LWS(value$LWS);
}

const getTimestamp$LWS = typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : FunctionBind$LWS(performance.now, performance);

function toSafeDescriptor$LWS(desc$LWS) {
  ReflectSetPrototypeOf$LWS(desc$LWS, null);
  return desc$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}

const ProxyCtor$LWS = Proxy;
const ProxyRevocable$LWS = Proxy.revocable;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}

function maskDistortion$LWS(distortedFunc$LWS, rawFunc$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(rawFunc$LWS, ObjectFreeze$LWS({
    apply(_target$LWS, thisArg$LWS, args$LWS) {
      if (thisArg$LWS === proxy$LWS) {
        thisArg$LWS = distortedFunc$LWS;
      }

      return ReflectApply$LWS(distortedFunc$LWS, thisArg$LWS, args$LWS);
    },

    construct(_target$LWS, args$LWS, newTarget$LWS) {
      if (newTarget$LWS === proxy$LWS) {
        newTarget$LWS = distortedFunc$LWS;
      }

      return ReflectConstruct$LWS(distortedFunc$LWS, args$LWS, newTarget$LWS);
    }

  }));
  return proxy$LWS;
}

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_LIVE_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerLiveValue'); // This is used by packages/locker-core-engine/src/LockerFilter.js

function isLiveObject$LWS(value$LWS) {
  if (value$LWS === null || value$LWS === undefined || value$LWS === ObjectProto$LWS || !(typeof value$LWS === 'object' || typeof value$LWS === 'function')) {
    return false;
  } // Based on the isTargetLive() function of
  // salesforce/near-membrane/packages/near-membrane-base/src/membrane.ts.


  if (typeof value$LWS === 'object') {
    const {
      constructor: constructor$LWS
    } = value$LWS;

    if (constructor$LWS === ObjectCtor$LWS) {
      // If the constructor, own or inherited, points to `Object`
      // then `value` is not likely a prototype object.
      return true;
    }

    let result$LWS = false;

    if (ReflectGetPrototypeOf$LWS(value$LWS) === null) {
      // Ensure `value` is not an `Object.prototype` from an iframe.
      result$LWS = typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== value$LWS;
    }

    if (!result$LWS) {
      result$LWS = ArrayIsArray$LWS(value$LWS) || ArrayBufferIsView$LWS(value$LWS) || isArrayBuffer$LWS(value$LWS) || isRegExp$LWS(value$LWS);
    }

    if (result$LWS) {
      return result$LWS;
    }
  }

  return ObjectHasOwnProperty$LWS(value$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS);
}

function markLiveObject$LWS(target$LWS) {
  ReflectDefineProperty$LWS(target$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS, {
    __proto__: null,
    value: undefined
  });
  return target$LWS;
}

function toLiveValue$LWS(value$LWS) {
  if (isObjectLike$LWS(value$LWS)) {
    return isLiveObject$LWS(value$LWS) ? value$LWS : markLiveObject$LWS(value$LWS);
  }

  return value$LWS;
}

const MathMin$LWS = Math.min;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  return isObjectLike$LWS(value$LWS) && !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
}

const {
  then: PromiseProtoThen$LWS
} = Promise.prototype;
const PromiseReject$LWS = Promise.reject.bind(Promise);

function PromiseThen$LWS(promise$LWS, ...args$LWS) {
  return ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, args$LWS);
}
/*! version: 0.15.16 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS(Attr.prototype, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Attr.prototype, 'value');

function AttrNameGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
}

function AttrNamespaceURIGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
}

function AttrOwnerElementGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, []);
}

function AttrValueGetter$LWS(attr$LWS) {
  return ReflectApply$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
}

function AttrValueSetter$LWS(attr$LWS, value$LWS) {
  ReflectApply$LWS(AttrProtoValueSetter$LWS, attr$LWS, [value$LWS]);
}

const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Document.prototype, 'cookie');
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = Document.prototype;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'body');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS(Document.prototype, 'implementation');

function DocumentBodyGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, []);
}

function DocumentCookieGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoCookieGetter$LWS, doc$LWS, []);
}

function DocumentCookieSetter$LWS(doc$LWS, newCookie$LWS) {
  ReflectApply$LWS(DocumentProtoCookieSetter$LWS, doc$LWS, [newCookie$LWS]);
}

function DocumentImplementation$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
}

function DocumentCreateComment$LWS(doc$LWS, data$LWS = '') {
  return ReflectApply$LWS(DocumentProtoCreateComment$LWS, doc$LWS, [data$LWS]);
}

function DocumentCreateElement$LWS(doc$LWS, ...args$LWS) {
  return ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, args$LWS);
}

function DocumentCreateElementNS$LWS(doc$LWS, ...args$LWS) {
  return ReflectApply$LWS(DocumentProtoCreateElementNS$LWS, doc$LWS, args$LWS);
}

function DocumentDocumentElementGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, doc$LWS, []);
}

function DocumentGetElementById$LWS(doc$LWS, id$LWS) {
  return ReflectApply$LWS(DocumentProtoGetElementById$LWS, doc$LWS, [id$LWS]);
}

function DocumentHeadGetter$LWS(doc$LWS) {
  return ReflectApply$LWS(DocumentProtoHeadGetter$LWS, doc$LWS, []);
}

function nsCookieRootKey$LWS(ns$LWS) {
  return `LSKey-${ns$LWS}$`;
}

function nsCookieKey$LWS(key$LWS, ns$LWS) {
  return `${nsCookieRootKey$LWS(ns$LWS)}${key$LWS}`;
}

const {
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = Element.prototype;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS
} = Element.prototype;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Element.prototype, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(Element.prototype, 'outerHTML');
const ElementProtoGetNamespaceURI$LWS = ObjectLookupOwnGetter$LWS(Element.prototype, 'namespaceURI');

function ElementClosest$LWS(el$LWS, selectors$LWS) {
  return ReflectApply$LWS(ElementProtoClosest$LWS, el$LWS, [selectors$LWS]);
}

function ElementInnerHTMLGetter$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, el$LWS, []);
}

function ElementInnerHTMLSetter$LWS(el$LWS, html$LWS) {
  ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, el$LWS, [html$LWS]);
}

function ElementOuterHTMLGetter$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoOuterHTMLGetter$LWS, el$LWS, []);
}

function ElementQuerySelector$LWS(el$LWS, selectors$LWS) {
  return ReflectApply$LWS(ElementProtoQuerySelector$LWS, el$LWS, [selectors$LWS]);
}

function ElementGetAttribute$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
}

function ElementGetAttributeNode$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttributeNode$LWS, el$LWS, [attrName$LWS]);
}

function ElementGetAttributeNodeNS$LWS(el$LWS, namespace$LWS, nodeName$LWS) {
  return ReflectApply$LWS(ElementProtoGetAttributeNodeNS$LWS, el$LWS, [namespace$LWS, nodeName$LWS]);
}

function ElementHasAttribute$LWS(el$LWS, attrName$LWS) {
  return ReflectApply$LWS(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS]);
}

function ElementSetAttribute$LWS(el$LWS, name$LWS, value$LWS) {
  return ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, [name$LWS, value$LWS]);
}

function ElementSetAttributeNS$LWS(el$LWS, namespace$LWS, name$LWS, value$LWS) {
  return ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, el$LWS, [namespace$LWS, name$LWS, value$LWS]);
}

function ElementRemoveAttributeNode$LWS(el$LWS, attrNode$LWS) {
  return ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, el$LWS, [attrNode$LWS]);
}

function ElementGetNamespaceURI$LWS(el$LWS) {
  return ReflectApply$LWS(ElementProtoGetNamespaceURI$LWS, el$LWS, []);
}

const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLTemplateElement.prototype, 'content');

function HTMLTemplateElementContentGetter$LWS(template$LWS) {
  return ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, template$LWS, []);
}

const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'firstChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'ownerDocument');

function NodeAppendChild$LWS(node$LWS, childNode$LWS) {
  return ReflectApply$LWS(NodeProtoAppendChild$LWS, node$LWS, [childNode$LWS]);
}

function NodeChildNodesGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, node$LWS, []);
}

function NodeClone$LWS(node$LWS, deep$LWS = false) {
  return ReflectApply$LWS(NodeProtoCloneNode$LWS, node$LWS, [deep$LWS]);
}

function NodeFirstChildGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoFirstChildGetter$LWS, node$LWS, []);
}

function NodeIsEqualNode$LWS(node$LWS, otherNode$LWS) {
  return ReflectApply$LWS(NodeProtoIsEqualNode$LWS, node$LWS, [otherNode$LWS]);
}

function NodeNameGetter$LWS(node$LWS) {
  // Normalize nodeName to upper case.
  // See https://johnresig.com/blog/nodename-case-sensitivity/.
  return StringToUpperCase$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []));
}

function NodeOwnerDocumentGetter$LWS(node$LWS) {
  return ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, node$LWS, []);
}

const globalObjectToValidatorMap$LWS = new WeakMapCtor$LWS();
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExp(`\\b${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}\\b`);
const webpackRequireNameRegExp$LWS = new RegExp(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExp(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? HTMLTemplateElementContentGetter$LWS(leftRoot$LWS) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? HTMLTemplateElementContentGetter$LWS(rightRoot$LWS) : rightRoot$LWS;

  if (NodeIsEqualNode$LWS(leftRootNode$LWS, rightRootNode$LWS)) {
    const leftChildNodes$LWS = NodeChildNodesGetter$LWS(leftRootNode$LWS);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = NodeChildNodesGetter$LWS(rightRootNode$LWS);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class Validator$LWS {
  constructor(globalObject$LWS) {
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ElementInnerHTMLSetter$LWS(this._templates.left, leftString$LWS);
      ElementInnerHTMLSetter$LWS(this._templates.right, rightString$LWS);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === DocumentHeadGetter$LWS(this._document) || element$LWS === DocumentBodyGetter$LWS(this._document) || element$LWS === DocumentDocumentElementGetter$LWS(this._document);

    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isMediaSourceObject = object$LWS => // MediaSource may not be defined in some browsers
    this._constructors.MediaSource && object$LWS instanceof this._constructors.MediaSource;

    const {
      document: document$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    } = globalObject$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: DocumentCreateElement$LWS(this._document, 'template'),
      right: DocumentCreateElement$LWS(this._document, 'template')
    };
  }

}

function getValidator$LWS(globalObject$LWS) {
  let validator$LWS = WeakMapGet$LWS(globalObjectToValidatorMap$LWS, globalObject$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(globalObject$LWS);
    WeakMapSet$LWS(globalObjectToValidatorMap$LWS, globalObject$LWS, validator$LWS);
  }

  return validator$LWS;
}

function transformUncompiledSource$LWS(source$LWS) {
  // To avoid conflicts with anyone else using SANDBOX_EVAL_CONTEXT_NAME,
  // we sniff the source code to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (RegExpTest$LWS(sandboxEvalContextNameRegExp$LWS, source$LWS)) {
    return source$LWS;
  }

  const destructuredBlueHelpers$LWS = []; // Input `source` is uncompiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  let locationTransformed$LWS = false;
  source$LWS = StringReplace$LWS(source$LWS, // RegExp.prototype[Symbol.replace] resets the lastIndex of global
  // regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  RegExpTest$LWS(webpackRequireNameRegExp$LWS, source$LWS) ? locationReferencesWithWebPackRegExp$LWS : locationReferencesRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
    locationTransformed$LWS = true;
    return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
  });

  if (locationTransformed$LWS) {
    destructuredBlueHelpers$LWS[destructuredBlueHelpers$LWS.length] = UNCOMPILED_LOCATION_NAME$LWS;
  }

  if (destructuredBlueHelpers$LWS.length) {
    source$LWS = `const {
            ${ArrayJoin$LWS(destructuredBlueHelpers$LWS, ',')}} = ${SANDBOX_EVAL_CONTEXT_NAME$LWS};${source$LWS}`;
  }

  return source$LWS;
}

const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(Blob.prototype, 'size');
const {
  slice: BlobProtoSlice$LWS
} = Blob.prototype;
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS(Blob.prototype, 'type');
const BlobCtor$LWS = Blob;

function BlobSizeGetter$LWS(blob$LWS) {
  return ReflectApply$LWS(BlobProtoSizeGetter$LWS, blob$LWS, []);
}

function BlobSlice$LWS(blob$LWS, ...args$LWS) {
  return ReflectApply$LWS(BlobProtoSlice$LWS, blob$LWS, args$LWS);
}

function BlobTypeGetter$LWS(blob$LWS) {
  return StringToLowerCase$LWS(ReflectApply$LWS(BlobProtoTypeGetter$LWS, blob$LWS, []));
}

const SEEN_OBJECTS_MAP$LWS = new MapCtor$LWS();

function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = MapEntries$LWS(map$LWS); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      MapSet$LWS(clone$LWS, subCloneKey$LWS, subCloneValue$LWS);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneSerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = SetValues$LWS(set$LWS); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      SetAdd$LWS(clone$LWS, subCloneValue$LWS);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ArrayShift$LWS(queue$LWS); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = MapGet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = getBrand$LWS(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS(originalValue$LWS);

          if (proto$LWS === ObjectProto$LWS || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = new ArrayCtor$LWS(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      if (!isNearMembrane$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        MapSet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN$LWS: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER$LWS: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT$LWS: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING$LWS:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    MapSet$LWS(SEEN_OBJECTS_MAP$LWS, originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  MapClear$LWS(SEEN_OBJECTS_MAP$LWS);
  return result$LWS;
}

const {
  getElementById: DocumentFragmentProtoGetElementById$LWS,
  querySelector: DocumentFragmentProtoQuerySelector$LWS
} = DocumentFragment.prototype;

function DocumentFragmentGetElementById$LWS(fragment$LWS, id$LWS) {
  return ReflectApply$LWS(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [id$LWS]);
}

function DocumentFragmentQuerySelector$LWS(doc$LWS, value$LWS) {
  return ReflectApply$LWS(DocumentFragmentProtoQuerySelector$LWS, doc$LWS, [value$LWS]);
}

const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;

function DOMImplementationCreateDocument$LWS(domImplementation$LWS, ...args$LWS) {
  return ReflectApply$LWS(DOMImplementationProtoCreateDocument$LWS, domImplementation$LWS, args$LWS);
}

const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenList.prototype, 'value');

function DOMTokenListValueGetter$LWS(tokenList$LWS) {
  return ReflectApply$LWS(DOMTokenListProtoValueGetter$LWS, tokenList$LWS, []);
}

const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS(Event.prototype, 'currentTarget');

function EventCurrentTargetGetter$LWS(event$LWS) {
  return ReflectApply$LWS(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
}

const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;

function EventTargetAddEventListener$LWS(target$LWS, ...args$LWS) {
  return ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, target$LWS, args$LWS);
}

const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'protocol');

function HTMLAnchorElementHostnameGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementHrefGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementHrefSetter$LWS(anchor$LWS, href$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, anchor$LWS, [href$LWS]);
}

function HTMLAnchorElementPathnameGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoPathnameGetter$LWS, anchor$LWS, []);
}

function HTMLAnchorElementProtocolGetter$LWS(anchor$LWS) {
  return ReflectApply$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, anchor$LWS, []);
}

const HTMLElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'dataset');

function HTMLElementDatasetGetter$LWS(el$LWS) {
  return ReflectApply$LWS(HTMLElementProtoDatasetGetter$LWS, el$LWS, []);
}

const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement.prototype, 'src');

function HTMLIFrameElementSrcSetter$LWS(iframe$LWS, src$LWS) {
  ReflectApply$LWS(HTMLIFrameElementProtoSrcSetter$LWS, iframe$LWS, [src$LWS]);
}

ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS(Request.prototype, 'url'); // This has to be done 1-by-1 because putting a full file ignore in this file will result in
// dist/index.js containing the directive and subsequently being ignored.
// istanbul ignore next

function RequestURLGetter$LWS(request$LWS) {
  return ReflectApply$LWS(RequestProtoURLGetter$LWS, request$LWS, []);
}

const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement.prototype, 'dataset');

function SVGElementDatasetGetter$LWS(svg$LWS) {
  return ReflectApply$LWS(SVGElementProtoDatasetGetter$LWS, svg$LWS, []);
}

const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL;
const ALLOW_LIST_PATCHED$LWS = ['opener', 'parent'];
const ALLOW_LIST_RAW$LWS = ['close', 'closed', 'focus'];
const DEFAULT_OVERWRITTEN_VALUE$LWS = {};
const rawToPatchedWindowMap$LWS = new WeakMapCtor$LWS(); // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowStaticClearInterval$LWS,
  setInterval: WindowStaticSetInterval$LWS
} = window;
const WindowStaticLengthGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'length');
const WindowStaticSelfGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'self');
const {
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS
} = window; // istanbul ignore next

function createPatchedWindow$LWS(win$LWS) {
  const patchedWindow$LWS = {};

  for (let i$LWS = 0, {
    length: length$LWS
  } = ALLOW_LIST_RAW$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ALLOW_LIST_RAW$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, key$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        value: originalValue$LWS
      } = safeDesc$LWS;

      if (typeof originalValue$LWS === 'function') {
        const bound$LWS = FunctionBind$LWS(originalValue$LWS, win$LWS);
        const unsafeNameDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalValue$LWS, 'name');

        if (unsafeNameDesc$LWS) {
          ReflectDefineProperty$LWS(bound$LWS, 'name', toSafeDescriptor$LWS(unsafeNameDesc$LWS));
        }

        unsafeDesc$LWS.value = bound$LWS;
      } else {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;
        let overwrittenValue$LWS = DEFAULT_OVERWRITTEN_VALUE$LWS;

        if (typeof getter$LWS === 'function') {
          safeDesc$LWS.get = function get$LWS() {
            return overwrittenValue$LWS === DEFAULT_OVERWRITTEN_VALUE$LWS ? ReflectApply$LWS(getter$LWS, win$LWS, []) : overwrittenValue$LWS;
          };
        }

        if (typeof setter$LWS === 'function') {
          safeDesc$LWS.set = function set$LWS(value$LWS) {
            overwrittenValue$LWS = value$LWS;
          };
        }
      }

      ReflectDefineProperty$LWS(patchedWindow$LWS, key$LWS, safeDesc$LWS);
    }
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = ALLOW_LIST_PATCHED$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ALLOW_LIST_PATCHED$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, key$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        get: getter$LWS,
        set: setter$LWS
      } = safeDesc$LWS;
      let overwrittenValue$LWS = DEFAULT_OVERWRITTEN_VALUE$LWS;

      if (typeof getter$LWS === 'function') {
        safeDesc$LWS.get = function get$LWS() {
          if (overwrittenValue$LWS === DEFAULT_OVERWRITTEN_VALUE$LWS) {
            return getPatchedWindow$LWS(ReflectApply$LWS(getter$LWS, win$LWS, []));
          }

          return overwrittenValue$LWS;
        };
      }

      if (typeof setter$LWS === 'function') {
        safeDesc$LWS.set = function set$LWS(value$LWS) {
          overwrittenValue$LWS = value$LWS;
        };
      }

      ReflectDefineProperty$LWS(patchedWindow$LWS, key$LWS, safeDesc$LWS);
    }
  }

  const unsafePostMessageDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(win$LWS, 'postMessage');

  if (unsafePostMessageDesc$LWS) {
    const safeDesc$LWS = toSafeDescriptor$LWS(unsafePostMessageDesc$LWS);
    safeDesc$LWS.value = getPatchedPostMessage$LWS(win$LWS);
    ReflectDefineProperty$LWS(patchedWindow$LWS, 'postMessage', safeDesc$LWS);
  }

  return patchedWindow$LWS;
}

function getPatchedPostMessage$LWS(win$LWS) {
  const {
    postMessage: originalPostMessage$LWS
  } = win$LWS;
  return function postMessage$LWS(...args$LWS) {
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalPostMessage$LWS, win$LWS, args$LWS);
  };
} // istanbul ignore next


function getPatchedWindow$LWS(win$LWS) {
  let patchedContentWindow$LWS = null;

  if (win$LWS) {
    patchedContentWindow$LWS = WeakMapGet$LWS(rawToPatchedWindowMap$LWS, win$LWS);

    if (patchedContentWindow$LWS === undefined) {
      patchedContentWindow$LWS = createPatchedWindow$LWS(win$LWS);
      WeakMapSet$LWS(rawToPatchedWindowMap$LWS, win$LWS, patchedContentWindow$LWS);
    }
  }

  return patchedContentWindow$LWS;
}

function isWindow$LWS(value$LWS) {
  // slower check that must certainly detect a window object
  try {
    // window.self getter only works for a window object, otherwise it throws,
    // additionally, this works fine for a detached window as well, which is
    // important since it will guarantee that this check works also for iframes
    // that are disconnected, and could be connected later on, that should not
    // bypass this check. This check is is also equivalent to window.frames, and
    // here is the very simple spec for this getter:
    // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
    WindowSelfGetter$LWS(value$LWS);
    return true; // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}

  return false;
}

function isWindowLike$LWS(value$LWS) {
  // fast check to narrow down when to do the slow check for window objects
  // window.top is unforgeable, this means this check should be safe from
  // user-intervention to try to bypass this check.
  return ObjectHasOwnProperty$LWS(value$LWS, 'top');
}

function WindowClearInterval$LWS(win$LWS, intervalID$LWS) {
  return ReflectApply$LWS(WindowStaticClearInterval$LWS, win$LWS, [intervalID$LWS]);
}

function WindowLengthGetter$LWS(win$LWS) {
  return ReflectApply$LWS(WindowStaticLengthGetter$LWS, win$LWS, []);
}

function WindowSelfGetter$LWS(win$LWS) {
  return ReflectApply$LWS(WindowStaticSelfGetter$LWS, win$LWS, []);
}

function WindowSetInterval$LWS(win$LWS, ...args$LWS) {
  return ReflectApply$LWS(WindowStaticSetInterval$LWS, win$LWS, args$LWS);
} // This has to be done 1-by-1 because putting a full file ignore in this file will result in
// dist/index.js containing the directive and subsequently being ignored.
// istanbul ignore next


const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials'); // istanbul ignore next

const {
  open: XhrProtoOpen$LWS
} = XhrProto$LWS; // istanbul ignore next

function XhrOpen$LWS(xhr$LWS, requestMethod$LWS, url$LWS, async$LWS = true) {
  return ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, [requestMethod$LWS, url$LWS, async$LWS]);
} // istanbul ignore next


function XhrResponseTextGetter$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrSend$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrStatusGetter$LWS(xhr$LWS) {
  return ReflectApply$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []);
} // istanbul ignore next


function XhrWithCredentialsSetter$LWS(xhr$LWS, bool$LWS) {
  ReflectApply$LWS(XhrProtoWithCredentialsSetter$LWS, xhr$LWS, [bool$LWS]);
}
/*! version: 0.15.16 */

/*! @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);

var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

var text = freeze(['#text']);

var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.3.6';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Parsing of strict XHTML documents */
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc = void 0;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
      return x;
    } : stringToLowerCase;

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erronously deleted from
      // HTML namespace.
      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = transformCaseFunc(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Mitigate a problem with templates inside select */
    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }

      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
      content = stringReplace(content, ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */
  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName.indexOf('-') > 0;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = stringTrim(attr.value);
      lcName = transformCaseFunc(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
        value = stringReplace(value, ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const ariaAttributes$LWS = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-readonly', 'aria-dropeffect', 'aria-expanded', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-disabled', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'role', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allTags$LWS = ArrayConcat$LWS(svgTags$LWS, htmlTags$LWS); // generic, sanitizer attempts in place sanitization and returns node

const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, '#document-fragment'),
  IN_PLACE: true
}; // use only svg tags, sanitizer returns a document fragment

const NODE_SVG$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: svgTags$LWS,
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false
}; // generic, sanitizer returns string

const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: ariaAttributes$LWS,
  ALLOWED_TAGS: ArrayFilter$LWS(allTags$LWS, t$LWS => !ArrayIncludes$LWS(['iframe'], t$LWS)),
  SANITIZE_DOM: false
};
const instances$LWS = new WeakMapCtor$LWS();

function sanitizer$LWS(config$LWS, hooks$LWS) {
  let dompurify$LWS = WeakMapGet$LWS(instances$LWS, config$LWS);

  if (dompurify$LWS) {
    return dompurify$LWS;
  }

  dompurify$LWS = purify();
  dompurify$LWS.setConfig(config$LWS);

  if (hooks$LWS) {
    MapForEach$LWS(hooks$LWS, (cb$LWS, hookName$LWS) => {
      dompurify$LWS.addHook(hookName$LWS, cb$LWS);
    });
  }

  WeakMapSet$LWS(instances$LWS, config$LWS, dompurify$LWS);
  return dompurify$LWS;
}

const ATTRIBUTES$LWS = ['href', 'xlink:href'];
const SANITIZER_HOOKS$LWS = new MapCtor$LWS([['uponSanitizeAttribute', sanitizeHrefAttributeHook$LWS], ['uponSanitizeElement', allowCustomTagHook$LWS]]);
const URL_SCHEMES$LWS = ['http:', 'https:'];
const {
  document: document$LWS
} = window;
const htmlTemplate$LWS = DocumentCreateElement$LWS(document$LWS, 'template');
const normalizerAnchor$LWS$1 = DocumentCreateElement$LWS(document$LWS, 'a'); // Queue for managing pending xhr requests.

const queue$LWS = new SetCtor$LWS(); // The regexp is based on the WHATWG spec:
// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
// However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.

const customTagRegExp$LWS = /^[a-z]([-_.\w])*-([-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF])*/; // A regexp to find all non lowercase alphanumeric.

const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;

function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (SetHas$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl)) {
    const checkFn$LWS = () => {
      if (!SetHas$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(window, interval$LWS);
      }
    }; // Wait for request to finish, then update content.


    const interval$LWS = WindowSetInterval$LWS(window, checkFn$LWS, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}

function createUrlContainer$LWS(url$LWS) {
  const container$LWS = DocumentCreateElement$LWS(document$LWS, 'div');
  ElementSetAttribute$LWS(container$LWS, 'style', 'display:none');
  ElementSetAttribute$LWS(container$LWS, 'id', url$LWS);
  const body$LWS = DocumentBodyGetter$LWS(document$LWS);
  NodeAppendChild$LWS(body$LWS, container$LWS);
  return container$LWS;
}

function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedUrl); // Put the URL we're fetching in a queue.

  SetAdd$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl); // Initiate an XHR to fetch the resource.

  const xhr$LWS = new XhrCtor$LWS();
  EventTargetAddEventListener$LWS(xhr$LWS, 'load', () => {
    const status$LWS = XhrStatusGetter$LWS(xhr$LWS); // istanbul ignore next: the following is well tested via integration-karma

    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(XhrResponseTextGetter$LWS(xhr$LWS)); // Look for the container again in case other requests have finished
      // earlier for the same URL.

      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = DocumentFragmentGetElementById$LWS(fragment$LWS, normalizedHref$LWS.requestedFragment);

        if (el$LWS) {
          ElementSetAttribute$LWS(el$LWS, 'id', normalizedHref$LWS.normalizedFragment);
        }
      }

      NodeAppendChild$LWS(container$LWS, fragment$LWS);
      SetDelete$LWS(queue$LWS, normalizedHref$LWS.normalizedUrl);
    }
  });
  XhrOpen$LWS(xhr$LWS, 'GET', normalizedHref$LWS.requestedUrl);
  XhrSend$LWS(xhr$LWS);
}

function parseHref$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS$1, url$LWS);
  const href$LWS = HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS$1);
  const protocol$LWS = HTMLAnchorElementProtocolGetter$LWS(normalizerAnchor$LWS$1);
  const {
    0: requestedUrl$LWS,
    1: requestedFragment$LWS
  } = StringSplit$LWS(href$LWS, '#');
  const normalizedUrl$LWS = StringReplace$LWS(StringToLowerCase$LWS(requestedUrl$LWS), urlReplacerRegExp$LWS, '');
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedUrl$LWS}_${StringReplace$LWS(requestedFragment$LWS, urlReplacerRegExp$LWS, '')}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedUrl: normalizedUrl$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedUrl: requestedUrl$LWS
  };
}

function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ElementQuerySelector$LWS(container$LWS, `#${normalizedFragment$LWS}`);

  if (!el$LWS) {
    try {
      el$LWS = ElementQuerySelector$LWS(container$LWS, `#${requestedFragment$LWS}`);
      ElementSetAttribute$LWS(el$LWS, 'id', normalizedFragment$LWS);
    } catch (_unused$LWS) {// Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers may
      // have the same ids for svg elements.
    }
  }
}

function blobSanitizer$LWS() {
  return sanitizer$LWS(STRING_BLOB_HTML$LWS, SANITIZER_HOOKS$LWS);
}

function svgSanitizer$LWS() {
  return sanitizer$LWS(NODE_SVG$LWS, SANITIZER_HOOKS$LWS);
}

function sanitize$LWS(dirty$LWS) {
  ElementInnerHTMLSetter$LWS(htmlTemplate$LWS, dirty$LWS);
  const content$LWS = HTMLTemplateElementContentGetter$LWS(htmlTemplate$LWS);
  const sanitizer$1$LWS = sanitizer$LWS(NODE_ALL_IN_PLACE$LWS, SANITIZER_HOOKS$LWS);
  sanitizer$1$LWS.sanitize(content$LWS);
  return ElementInnerHTMLGetter$LWS(htmlTemplate$LWS);
}

function sanitizeDocument$LWS(doc$LWS) {
  const content$LWS = ElementOuterHTMLGetter$LWS(DocumentDocumentElementGetter$LWS(doc$LWS));
  const contentSanitized$LWS = sanitize$LWS(content$LWS);
  const newDoc$LWS = DOMImplementationCreateDocument$LWS(DocumentImplementation$LWS(doc$LWS), NAMESPACE_XHTML$LWS, 'html');
  ElementInnerHTMLSetter$LWS(DocumentDocumentElementGetter$LWS(newDoc$LWS), contentSanitized$LWS);
  return newDoc$LWS;
} // Sanitize a URL representing a SVG href attribute value.


function sanitizeHrefAttributeHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;
  const nodeName$LWS = NodeNameGetter$LWS(node$LWS);

  if (attrValue$LWS && nodeName$LWS === 'USE' && ArrayIncludes$LWS(ATTRIBUTES$LWS, attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }

  return data$LWS;
}

function sanitizeSvgHref$LWS(url$LWS) {
  if (StringStartsWith$LWS(url$LWS, '#')) {
    return url$LWS;
  }

  const normalizedHref$LWS = parseHref$LWS(url$LWS); // Sanitize only for supported URL_SCHEMES.

  if (ArrayIncludes$LWS(URL_SCHEMES$LWS, normalizedHref$LWS.protocol)) {
    const container$LWS = DocumentGetElementById$LWS(document$LWS, normalizedHref$LWS.normalizedUrl); // Have we sanitized this URL already?

    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    } // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.


    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedUrl}`;
  }

  return url$LWS;
}

function createSvgContainer$LWS(ownerDoc$LWS) {
  return DocumentCreateElementNS$LWS(ownerDoc$LWS, NAMESPACE_SVG$LWS, 'svg');
}

function sanitizeSvgInnerHtml$LWS(stringOrSvg$LWS, dirty$LWS = '') {
  let container$LWS;
  const ownerDoc$LWS = typeof stringOrSvg$LWS === 'string' ? document$LWS : NodeOwnerDocumentGetter$LWS(stringOrSvg$LWS);
  const comment$LWS = DocumentCreateComment$LWS(ownerDoc$LWS, '');

  if (typeof stringOrSvg$LWS === 'string') {
    dirty$LWS = stringOrSvg$LWS;
    container$LWS = createSvgContainer$LWS(ownerDoc$LWS);
  } else {
    const closestSvg$LWS = ElementClosest$LWS(stringOrSvg$LWS, 'svg');
    container$LWS = closestSvg$LWS ? NodeClone$LWS(closestSvg$LWS, false) : createSvgContainer$LWS(ownerDoc$LWS);
  }

  NodeAppendChild$LWS(container$LWS, comment$LWS);
  const outerHTML$LWS = ElementOuterHTMLGetter$LWS(container$LWS);
  const replacedOuterHTML$LWS = StringReplace$LWS(outerHTML$LWS, '<!---->', dirty$LWS);
  const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(replacedOuterHTML$LWS);
  const firstChild$LWS = NodeFirstChildGetter$LWS(fragment$LWS);
  return ElementInnerHTMLGetter$LWS(firstChild$LWS);
}

function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const sanitizer$LWS = svgSanitizer$LWS();
  return sanitizer$LWS.sanitize(dirty$LWS);
}

function allowCustomTagHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    allowedTags: allowedTags$LWS,
    tagName: tagName$LWS
  } = data$LWS;

  if (!allowedTags$LWS[tagName$LWS] && customTagRegExp$LWS.test(tagName$LWS)) {
    allowedTags$LWS[tagName$LWS] = true;
  }
}
/*! version: 0.15.16 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */

const REGEX_VALID_MIME_TYPE$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;
const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar'];

function isMIMETypeAllowed$LWS(type$LWS) {
  // avoid MIME types which try to escape using special characters
  // Reason: W-4896359
  if (RegExpTest$LWS(REGEX_VALID_MIME_TYPE$LWS, type$LWS)) {
    for (let i$LWS = 0, {
      length: length$LWS
    } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (StringStartsWith$LWS(type$LWS, ALLOWED_MIME_TYPES$LWS[i$LWS])) {
        return true;
      }
    }
  }

  return false;
}

const DEFAULT_URL_SCHEMES$LWS = ['http:', 'https:'];
const DISALLOWED_ENDPOINTS$LWS = ['/aura', '/webruntime'];
const REMOVE_URL_CHARS_REG_EXP$LWS = /[\u2029\u2028\n\r\t]/g;
const normalizerAnchor$LWS = DocumentCreateElement$LWS(document, 'a');
const TRUSTED_DOMAINS$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/; // @TODO W-7302311 Make paths and domains configurable

function isInvalidURL$LWS(parsedURL$LWS) {
  const pathname$LWS = StringToLowerCase$LWS(parsedURL$LWS.pathname);
  return ArraySome$LWS(DISALLOWED_ENDPOINTS$LWS, dep$LWS => StringIncludes$LWS(pathname$LWS, dep$LWS));
}

function isValidURLScheme$LWS(url$LWS, schemes$LWS = DEFAULT_URL_SCHEMES$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, url$LWS);
  return ArrayIncludes$LWS(schemes$LWS, HTMLAnchorElementProtocolGetter$LWS(normalizerAnchor$LWS));
}

function parseURL$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, sanitizeURLString$LWS(url$LWS));
  return {
    normalizedURL: HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS),
    hostname: HTMLAnchorElementHostnameGetter$LWS(normalizerAnchor$LWS),
    pathname: WindowDecodeURIComponent$LWS(HTMLAnchorElementPathnameGetter$LWS(normalizerAnchor$LWS))
  };
}

function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : StringReplace$LWS(urlString$LWS, REMOVE_URL_CHARS_REG_EXP$LWS, '');
}

function sanitizeURLForElement$LWS(url$LWS) {
  HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, url$LWS);
  return sanitizeURLString$LWS(HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS));
}
/*! version: 0.15.16 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const CustomElementRegistryBlockedProperties$LWS = ['define'];
/**
 * this registry is going to be used by Attr, NameNodeMap, setAttribute* distortions
 */

const distortionsBySandboxKeyRegistry$LWS = {
  __proto__: null
}; // An array of factories traversed when we create a new sandbox. The result of
// parsing this registry will be a new registry with initialized distortions.

const factories$LWS = [];

function storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  const {
    [attributeName$LWS]: byAttributeNamespaceRegistry$LWS = {
      __proto__: null
    }
  } = registry$LWS;
  const {
    [attributeNamespace$LWS]: byElementCtor$LWS = new MapCtor$LWS()
  } = byAttributeNamespaceRegistry$LWS;
  MapSet$LWS(byElementCtor$LWS, ElementCtor$LWS, distortion$LWS);
  byAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = byElementCtor$LWS;
  registry$LWS[attributeName$LWS] = byAttributeNamespaceRegistry$LWS;
}

function getAttributeDistortion$LWS(element$LWS, key$LWS, attributeName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    [key$LWS]: registry$LWS
  } = distortionsBySandboxKeyRegistry$LWS;
  attributeName$LWS = StringToLowerCase$LWS(attributeName$LWS);
  const byAttributeNamespaceRegistry$LWS = registry$LWS[attributeName$LWS];

  if (!byAttributeNamespaceRegistry$LWS) {
    return undefined;
  }

  const {
    [attributeNamespace$LWS]: byElementCtor$LWS
  } = byAttributeNamespaceRegistry$LWS;

  if (!byElementCtor$LWS) {
    return undefined;
  }

  const mapIterator$LWS = MapEntries$LWS(byElementCtor$LWS); // using a restricted syntax to avoid accessing .next on iterator
  // eslint-disable-next-line no-restricted-syntax

  for (const entry$LWS of mapIterator$LWS) {
    const Ctor$LWS = entry$LWS[0];
    const distortion$LWS = entry$LWS[1]; // element can inherit from Ctor but Ctor
    // may not be the first entry in the proto chain
    // thus element.prototype checks are not sufficient

    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function makeElementDistortionsForSandboxKey$LWS(key$LWS) {
  // This registry is created per sandbox.
  const registry$LWS = {
    __proto__: null
  };
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(registry$LWS);

    if (entry$LWS) {
      entries$LWS[entriesOffset$LWS++] = entry$LWS;
    }
  }

  distortionsBySandboxKeyRegistry$LWS[key$LWS] = registry$LWS;
  return entries$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}

function registerElementSetDistortion$LWS(ElementCtor$LWS, options$LWS) {
  factories$LWS[factories$LWS.length] = registry$LWS => {
    const {
      attributeNamespace: attributeNamespace$LWS,
      distortion: distortion$LWS
    } = options$LWS;
    const attributeName$LWS = StringToLowerCase$LWS(options$LWS.attributeName);
    storeDistortionInRegistry$LWS(registry$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS);
    return null;
  };
}

function distortionAttrValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');

  function value$LWS(val$LWS) {
    const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

    if (ownerElement$LWS) {
      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [val$LWS]);
        return;
      }
    }

    ReflectApply$LWS(originalAttrValueSetter$LWS, this, [val$LWS]);
  }

  return [originalAttrValueSetter$LWS, value$LWS];
}

function distortionAuraUtilGlobalEval$LWS(globalObject$LWS, options$LWS) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;

  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval;

  if (typeof originalGlobalEval$LWS !== 'function') {
    return null;
  }

  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS; // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.

  const globalEval$LWS = function globalEval$LWS(src$LWS, descriptor$LWS, type$LWS) {
    let compiled$LWS = `(function s(){return(${src$LWS})})()`;

    if (typeof descriptor$LWS === 'string') {
      const name$LWS = ArrayPop$LWS(StringSplit$LWS(descriptor$LWS, '://'));
      compiled$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${StringReplace$LWS(name$LWS, '.', '/')}` : `/components/${StringReplace$LWS(name$LWS, ':', '/')}.js`);
    }

    return evaluator$LWS(key$LWS, compiled$LWS);
  };

  return [originalGlobalEval$LWS, globalEval$LWS];
}

function nsCacheRootKey$LWS(ns$LWS) {
  return `LSKey-${ns$LWS}$`;
}

function nsCacheKey$LWS(key$LWS, ns$LWS) {
  return `${nsCacheRootKey$LWS(ns$LWS)}${key$LWS}`;
}

function prefixCacheName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.cacheName = nsCacheKey$LWS(clonedDetails$LWS.cacheName, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = nsCacheKey$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCacheName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = nsCacheRootKey$LWS(key$LWS); // First check that this Cache object belongs to this sandbox,
  // if not then return null.

  if (!StringStartsWith$LWS(name$LWS, rootKey$LWS)) {
    return null;
  }

  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  return StringSlice$LWS(name$LWS, rootKeyLength$LWS);
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageDelete$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const patchedDelete$LWS = function patchedDelete$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, patchedDelete$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageHas$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy2$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const has$LWS = function has$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalHas$LWS, this, args$LWS);
  };

  return [originalHas$LWS, has$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageKeys$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy3$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const keys$LWS = function keys$LWS() {
    return PromiseThen$LWS(ReflectApply$LWS(originalKeys$LWS, this, []), result$LWS => {
      const sandboxedCacheNames$LWS = [];

      for (let i$LWS = 0, j$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cacheName$LWS = unprefixCacheName$LWS(result$LWS[i$LWS], key$LWS);

        if (typeof cacheName$LWS === 'string') {
          sandboxedCacheNames$LWS[j$LWS++] = cacheName$LWS;
        }
      }

      return sandboxedCacheNames$LWS;
    });
  };

  return [originalKeys$LWS, keys$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageMatch$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy4$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const match$LWS = function match$LWS( // @ts-ignore TypeScript's confusion about using CacheStorage here.
  ...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // This should be sufficient enough to affirm the presense of at least the
    // request | string argument. We want to skip the distorted behavior
    // ONLY in cases where there are no arguments at all, or the request argument
    // is invalid, which is then handled by the host function.

    if (length$LWS && isConvertibleToString$LWS(args$LWS[0])) {
      // Next we check if length is 2, which means that options are present
      const options$LWS = length$LWS === 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the options.cacheName.
      // The value of options.cacheName must also be safely convertable to a string.

      if (!isObjectLike$LWS(options$LWS) || !options$LWS.cacheName || !isConvertibleToString$LWS(options$LWS.cacheName)) {
        return PromiseReject$LWS(new LockerSecurityError$LWS('caches.match() expects the options argument to be present and to have a "cacheName" property.'));
      }

      args$LWS[1] = prefixCacheName$LWS(options$LWS, key$LWS);
    }

    return ReflectApply$LWS(originalMatch$LWS, this, args$LWS);
  };

  return [originalMatch$LWS, match$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageOpen$LWS(globalObject$LWS, options$LWS) {
  var _CacheStorage$prototy5$LWS;

  const {
    CacheStorage: CacheStorage$LWS
  } = globalObject$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS

  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const open$LWS = function open$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixCacheName$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  };

  return [originalOpen$LWS, open$LWS];
}

const CHAR_CODE_EQUALS$LWS = 61;
const COOKIE_DELIMITER$LWS = '; ';

function prefixCookieName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = nsCookieKey$LWS(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = nsCookieKey$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookieName$LWS(name$LWS, key$LWS) {
  const rootKey$LWS = nsCookieRootKey$LWS(key$LWS); // First check that this cookie belongs to this sandbox,
  // if not then return null.

  if (!StringStartsWith$LWS(name$LWS, rootKey$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key


  const {
    length: rootKeyLength$LWS
  } = rootKey$LWS;
  const rootKeySubstringLength$LWS = StringCharCodeAt$LWS(name$LWS, rootKeyLength$LWS) === CHAR_CODE_EQUALS$LWS ? rootKeyLength$LWS + 1 : rootKeyLength$LWS;
  return StringSlice$LWS(name$LWS, rootKeySubstringLength$LWS);
}

function normalizeCookieListItem$LWS(cookie$LWS, key$LWS) {
  if (cookie$LWS) {
    const unprefixedCookieName$LWS = unprefixCookieName$LWS(cookie$LWS.name, key$LWS); // If unprefixCookieName() returns null, that means this cookie
    // doesn't belong to the provided sandbox (based on the key)

    if (unprefixedCookieName$LWS === null) {
      return null;
    }

    cookie$LWS.name = unprefixedCookieName$LWS;
  }

  return cookie$LWS;
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreDelete$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const deleteValue$LWS = function deleteValue$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, deleteValue$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp2$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const get$LWS = function get$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(detailsOrName$LWS, key$LWS);
    }

    return PromiseThen$LWS(ReflectApply$LWS(originalGet$LWS, this, args$LWS), result$LWS => normalizeCookieListItem$LWS(result$LWS, key$LWS));
  };

  return [originalGet$LWS, get$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGetAll$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp3$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const getAll$LWS = function getAll$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieName$LWS(args$LWS[0], key$LWS);
    }

    return PromiseThen$LWS(ReflectApply$LWS(originalGetAll$LWS, this, args$LWS), result$LWS => {
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = normalizeCookieListItem$LWS(result$LWS[i$LWS], key$LWS);

        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }

      return sandboxedCookies$LWS;
    });
  };

  return [originalGetAll$LWS, getAll$LWS];
}

const restrictionsBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(eventTarget$LWS, eventName$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    [key$LWS]: bySandboxKeyRegistry$LWS
  } = restrictionsBySandboxKeyRegistry$LWS;

  if (bySandboxKeyRegistry$LWS === undefined || bySandboxKeyRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  const {
    constructor: constructor$LWS
  } = eventTarget$LWS;
  return SetHas$LWS(bySandboxKeyRegistry$LWS[eventName$LWS], constructor$LWS);
}

function registerEventTargetRestriction$LWS(EventTargetCtor$LWS, eventName$LWS, options$LWS) {
  const {
    prototype: EventTargetProto$LWS
  } = EventTargetCtor$LWS;

  if (!isEventTargetRestricted$LWS(EventTargetProto$LWS, eventName$LWS, options$LWS)) {
    const {
      key: key$LWS
    } = options$LWS;
    const {
      [key$LWS]: bySandboxKeyRegistry$LWS = {
        __proto__: null
      }
    } = restrictionsBySandboxKeyRegistry$LWS;
    const {
      [eventName$LWS]: byEventName$LWS = new SetCtor$LWS()
    } = bySandboxKeyRegistry$LWS;
    SetAdd$LWS(byEventName$LWS, EventTargetCtor$LWS);
    bySandboxKeyRegistry$LWS[eventName$LWS] = byEventName$LWS;
    restrictionsBySandboxKeyRegistry$LWS[key$LWS] = bySandboxKeyRegistry$LWS;
  }
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreOnChange$LWS(globalObject$LWS, options$LWS) {
  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalOnChangeSetter$LWS = ObjectLookupOwnSetter$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return null;
  }

  const onchange$LWS = function onchange$LWS() {
    throw new LockerSecurityError$LWS('Cannot set cookieStore.onchange.');
  };

  registerEventTargetRestriction$LWS(CookieStore$LWS, 'change', options$LWS);
  return [originalOnChangeSetter$LWS, onchange$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreSet$LWS(globalObject$LWS, options$LWS) {
  var _CookieStore$prototyp4$LWS;

  const {
    CookieStore: CookieStore$LWS
  } = globalObject$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return null;
  }

  const {
    key: key$LWS
  } = options$LWS;

  const set$LWS = function set$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        0: name$LWS
      } = args$LWS;
      args$LWS[0] = nsCookieKey$LWS(name$LWS, key$LWS);
    } else if (length$LWS) {
      const {
        0: details$LWS
      } = args$LWS;

      if (isObjectLike$LWS(details$LWS)) {
        const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
        clonedDetails$LWS.name = nsCookieKey$LWS(clonedDetails$LWS.name, key$LWS);
        args$LWS[0] = clonedDetails$LWS;
      }
    }

    return ReflectApply$LWS(originalSet$LWS, this, args$LWS);
  };

  return [originalSet$LWS, set$LWS];
}

function distortionCSSStyleRuleStyleGetter$LWS(globalObject$LWS) {
  const {
    CSSStyleRule: CSSStyleRule$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(CSSStyleRule$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionCustomElementRegistryGet$LWS(globalObject$LWS, options$LWS) {
  var _CustomElementRegistr$LWS;

  const {
    key: key$LWS
  } = options$LWS;
  const LOWER_CASED_NS$LWS = StringToLowerCase$LWS(key$LWS);
  const {
    CustomElementRegistry: CustomElementRegistry$LWS
  } = globalObject$LWS;
  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    if (args$LWS.length) {
      const sanitizedName$LWS = toString$LWS(args$LWS[0]);
      const lowerCasedName$LWS = StringToLowerCase$LWS(sanitizedName$LWS);

      if (!StringStartsWith$LWS(lowerCasedName$LWS, `${LOWER_CASED_NS$LWS}-`)) {
        return undefined;
      }

      args$LWS[0] = sanitizedName$LWS;
    }

    return ReflectApply$LWS(originalGet$LWS, this, args$LWS);
  };

  return [originalGet$LWS, get$LWS];
}
/**
 * Factory patched cookie getter. Must be invoked with namespace argument.
 * Will return a patched cookie getter bound to the namespace.
 * @param key
 * @returns Distortion: string
 */


function distortionDocumentCookieGetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS(Document$LWS.prototype, 'cookie');

  function get$LWS() {
    const documentCookieValue$LWS = DocumentCookieGetter$LWS(this);
    const cookies$LWS = StringSplit$LWS(documentCookieValue$LWS, COOKIE_DELIMITER$LWS);
    const sandboxedCookies$LWS = [];
    let sandboxedCookiesOffset$LWS = 0;

    for (let i$LWS = 0, {
      length: length$LWS
    } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const cookie$LWS = unprefixCookieName$LWS(cookies$LWS[i$LWS], key$LWS);

      if (cookie$LWS) {
        sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
      }
    }

    return ArrayJoin$LWS(sandboxedCookies$LWS, COOKIE_DELIMITER$LWS);
  }

  return [originalCookieGetter$LWS, get$LWS];
}
/**
 * Factory patched cookie setter. Must be invoked with namespace argument.
 * Returns a distortion function bound to the namespace.
 * @param ns
 * @returns Distortion
 */


function distortionDocumentCookieSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');

  function set$LWS(value$LWS) {
    const cookieEntries$LWS = StringSplit$LWS(value$LWS, COOKIE_DELIMITER$LWS);
    let {
      0: newCookieEntry$LWS
    } = cookieEntries$LWS;

    if (StringCharCodeAt$LWS(newCookieEntry$LWS, 0) === CHAR_CODE_EQUALS$LWS) {
      newCookieEntry$LWS = StringSlice$LWS(newCookieEntry$LWS, 1);
    }

    cookieEntries$LWS[0] = nsCookieKey$LWS(newCookieEntry$LWS, key$LWS);
    DocumentCookieSetter$LWS(this, ArrayJoin$LWS(cookieEntries$LWS, COOKIE_DELIMITER$LWS));
  }

  return [originalCookieSetter$LWS, set$LWS];
}

function distortionDocumentDomainSetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');

  function domain$LWS() {
    throw new LockerSecurityError$LWS('Cannot set document.domain.');
  }

  return [originalDomainSetter$LWS, domain$LWS];
} // eslint-disable-next-line no-shadow


var CookieSameSite$LWS;

(function (CookieSameSite$LWS) {
  CookieSameSite$LWS[CookieSameSite$LWS["strict"] = 0] = "strict";
  CookieSameSite$LWS[CookieSameSite$LWS["lax"] = 1] = "lax";
  CookieSameSite$LWS[CookieSameSite$LWS["none"] = 2] = "none";
})(CookieSameSite$LWS || (CookieSameSite$LWS = {})); // eslint-disable-next-line no-shadow


var SandboxType$LWS;

(function (SandboxType$LWS) {
  SandboxType$LWS[SandboxType$LWS["External"] = 0] = "External";
  SandboxType$LWS[SandboxType$LWS["Internal"] = 1] = "Internal";
})(SandboxType$LWS || (SandboxType$LWS = {}));

ReflectSetPrototypeOf$LWS(SandboxType$LWS, null);

function distortionDocumentExecCommand$LWS(globalObject$LWS, options$LWS) {
  const {
    Document: Document$LWS,
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const {
    execCommand: originalExecCommand$LWS
  } = Document$LWS.prototype;
  const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS(Document$LWS.prototype, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'isContentEditable'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);
  const {
    sandboxType: sandboxType$LWS
  } = options$LWS;

  function execCommand$LWS(...args$LWS) {
    if (args$LWS.length > 2) {
      const {
        2: unsanitizedValue$LWS
      } = args$LWS;

      if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
        const command$LWS = toString$LWS(args$LWS[0]);

        if (StringToLowerCase$LWS(command$LWS) === 'inserthtml') {
          if (sandboxType$LWS === SandboxType$LWS.External) {
            const activeElement$LWS = ReflectApply$LWS(originalActiveElement$LWS, this, []);

            if (isSharedElement$LWS(activeElement$LWS) && ReflectApply$LWS(originalIsContentEditable$LWS, activeElement$LWS, [])) {
              throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${toString$LWS(activeElement$LWS.nodeName)}.`);
            }
          }

          args$LWS[0] = command$LWS;
          args$LWS[2] = sanitize$LWS(unsanitizedValue$LWS);
        }
      }
    }

    return ReflectApply$LWS(originalExecCommand$LWS, this, args$LWS);
  }

  return [originalExecCommand$LWS, execCommand$LWS];
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    let windowFeatures$LWS = StringToLowerCase$LWS(toString$LWS(sanitizedArgs$LWS[2]));

    if (RegExpTest$LWS(noopenerRegExp$LWS, windowFeatures$LWS)) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      windowFeatures$LWS = StringReplace$LWS(windowFeatures$LWS, // RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`);
    }

    sanitizedArgs$LWS[2] = windowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function distortionDocumentOpen$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    open: originalDocumentOpen$LWS
  } = Document$LWS.prototype;

  function open$LWS(...args$LWS) {
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      const rawOpenWindow$LWS = ReflectApply$LWS(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
      return getPatchedWindow$LWS(rawOpenWindow$LWS);
    }

    return ReflectApply$LWS(originalDocumentOpen$LWS, this, args$LWS);
  }

  return [originalDocumentOpen$LWS, open$LWS];
}

function distortionDocumentReplaceChildren$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChild$LWS
  } = Document$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check if
    // its `head` property is a shared element. This will allow magenta window
    // documents to call replaceChildren successfully.
    if (isSharedElement$LWS(DocumentHeadGetter$LWS(this))) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    }

    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChildren$LWS];
}

function distortionDOMParserParseFromString$LWS(globalObject$LWS) {
  const {
    DOMParser: DOMParser$LWS
  } = globalObject$LWS;
  const {
    parseFromString: originalParseFromString$LWS
  } = DOMParser$LWS.prototype;

  function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with exactly
    // two arguments. If it receives one argument, it will fail. Some implementations
    // will also fail if it receives more than two arguments. Since any call that does
    // not have at least two arguments will fail no matter what, we only need to
    // expend effort to sanitize when we know that the operation is definitely
    // NOT going to fail.
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = toString$LWS(args$LWS[0]);
      const mimeType$LWS = toString$LWS(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? sanitizeSvgInnerHtml$LWS(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : sanitize$LWS(string$LWS);
    }

    return ReflectApply$LWS(originalParseFromString$LWS, this, args$LWS);
  }

  return [originalParseFromString$LWS, parseFromString$LWS];
}

function distortionElementAfter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    after: originalAfter$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function after$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAfter$LWS, this, args$LWS);
  }

  return [originalAfter$LWS, after$LWS];
}

function distortionElementAppend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    append: originalAppend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function append$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAppend$LWS, this, args$LWS);
  }

  return [originalAppend$LWS, append$LWS];
}

function distortionElementAttachShadow$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    attachShadow: originalAttachShadow$LWS
  } = Element$LWS.prototype;

  function attachShadow$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS;

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit because
        // attachShadow() accepts inherited shadowRootInit properties.


        const shadowRootInit$LWS = ObjectAssign$LWS({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment of mode
        // to avoid complications with inherited non-configurable/non-writable
        // mode properties.

        const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$LWS(originalShadowRootInit$LWS);
        ReflectSetPrototypeOf$LWS(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return ReflectApply$LWS(originalAttachShadow$LWS, this, args$LWS);
  }

  return [originalAttachShadow$LWS, attachShadow$LWS];
}

const registry$LWS = new WeakMapCtor$LWS();

function getPairedElement$LWS(attrInstance$LWS) {
  return WeakMapGet$LWS(registry$LWS, attrInstance$LWS);
}

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  WeakMapSet$LWS(registry$LWS, attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(originalMethod$LWS, nodeNameMap$LWS, attr$LWS, options$LWS) {
  const element$LWS = getPairedElement$LWS(nodeNameMap$LWS);

  if (element$LWS) {
    const {
      key: key$LWS
    } = options$LWS;
    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(element$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const attrValue$LWS = AttrValueGetter$LWS(attr$LWS);
      return ReflectApply$LWS(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  }

  return ReflectApply$LWS(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function distortionElementAttributesGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'attributes');

  function attributes$LWS() {
    const attrs$LWS = ReflectApply$LWS(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }

  return [originalAttributesGetter$LWS, attributes$LWS];
}

function distortionElementBefore$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    before: originalBefore$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function before$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalBefore$LWS, this, args$LWS);
  }

  return [originalBefore$LWS, before$LWS];
}

function distortionElementInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'innerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function innerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${this.nodeName}.`);
    }

    const sanitizedValue$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS);
    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [sanitizedValue$LWS]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionElementInsertAdjacentElement$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentElement: originalInsertAdjacentElement$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function insertAdjacentElement$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${element$LWS.nodeName} adjacent to ${this.nodeName}.`);
      }
    }

    return ReflectApply$LWS(originalInsertAdjacentElement$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentElement$LWS, insertAdjacentElement$LWS];
}

function distortionElementInsertAdjacentHTML$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    insertAdjacentHTML: originalInsertAdjacentHTML$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${toString$LWS(this.nodeName)}.`);
    }

    if (args$LWS.length > 1) {
      args$LWS[1] = sanitize$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentHTML$LWS, insertAdjacentHTML$LWS];
}

function distortionElementOuterHTMLSetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function outerHTML$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalOuterHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalOuterHTMLSetter$LWS, outerHTML$LWS];
}

function distortionElementPrepend$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    prepend: originalPrepend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function prepend$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? argValue$LWS.nodeName : argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${toString$LWS(this.nodeName)}.`);
        }
      }
    }

    return ReflectApply$LWS(originalPrepend$LWS, this, args$LWS);
  }

  return [originalPrepend$LWS, prepend$LWS];
}

function distortionElementRemove$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    remove: originalRemove$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function remove$LWS() {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalRemove$LWS, this, []);
  }

  return [originalRemove$LWS, remove$LWS];
}

function distortionElementReplaceChildren$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceChildren: originalReplaceChildren$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChildren$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${toString$LWS(this.nodeName)}.`);
    }

    return ReflectApply$LWS(originalReplaceChildren$LWS, this, args$LWS);
  }

  return [originalReplaceChildren$LWS, replaceChildren$LWS];
}

function distortionElementReplaceWith$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    replaceWith: originalReplaceWith$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceWith$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${toString$LWS(this.nodeName)}.`);
    }

    return ReflectApply$LWS(originalReplaceWith$LWS, this, args$LWS);
  }

  return [originalReplaceWith$LWS, replaceWith$LWS];
}

function normalizeAttrName$LWS(name$LWS) {
  return StringToLowerCase$LWS(toString$LWS(name$LWS));
}

function distortionElementSetAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element$LWS.prototype;

  function setAttribute$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const attrValue$LWS = toString$LWS(args$LWS[1]);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
        return;
      }

      args$LWS[0] = attrName$LWS;
      args$LWS[1] = attrValue$LWS;
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, args$LWS);
  }

  return [originalSetAttribute$LWS, setAttribute$LWS];
}

function distortionElementSetAttributeNode$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNode: originalSetAttributeNode$LWS
  } = Element$LWS.prototype;

  function setAttributeNode$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (AttrOwnerElementGetter$LWS(attr$LWS)) {
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    }

    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ElementGetAttributeNode$LWS(this, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect old attribute.
        ElementRemoveAttributeNode$LWS(this, oldAttr$LWS);
      }

      const attrValue$LWS = AttrValueGetter$LWS(attr$LWS);
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ElementGetAttributeNode$LWS(this, attrName$LWS);

      if (newAttr$LWS) {
        // Remove distorted attribute.
        ElementRemoveAttributeNode$LWS(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = AttrValueGetter$LWS(newAttr$LWS); // Set the distorted attr value.

        AttrValueSetter$LWS(attr$LWS, newValue$LWS); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNode$LWS, this, [attr$LWS]);
      }

      return undefined;
    }

    return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
  }

  return [originalSetAttributeNode$LWS, setAttributeNode$LWS];
}

function distortionElementSetAttributeNodeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Attr: Attr$LWS,
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNodeNS: originalSetAttributeNodeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNodeNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.


    if (AttrOwnerElementGetter$LWS(attr$LWS)) {
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    }

    const attrName$LWS = AttrNameGetter$LWS(attr$LWS);
    const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(attr$LWS);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ElementGetAttributeNodeNS$LWS(this, attrNamespace$LWS, attrName$LWS);

      if (oldAttr$LWS) {
        // Disconnect the old attribute.
        ElementRemoveAttributeNode$LWS(this, oldAttr$LWS);
      }

      const attrValue$LWS = toString$LWS(AttrValueGetter$LWS(attr$LWS));
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ElementGetAttributeNodeNS$LWS(this, attrNamespace$LWS, attrName$LWS);

      if (newAttr$LWS) {
        // Remove the distorted attribute.
        ElementRemoveAttributeNode$LWS(this, newAttr$LWS);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = AttrValueGetter$LWS(newAttr$LWS); // Set the distorted attr value.

        AttrValueSetter$LWS(attr$LWS, newValue$LWS); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }

      return null;
    }

    return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
  }

  return [originalSetAttributeNodeNS$LWS, setAttributeNodeNS$LWS];
}

function distortionElementSetAttributeNS$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    setAttributeNS: originalSetAttributeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNS$LWS(...args$LWS) {
    if (args$LWS.length < 3) {
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
      return;
    }

    const {
      1: qualifiedName$LWS
    } = args$LWS;
    const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
    const attrNamespace$LWS = toStringIfNotNullOrUndefined$LWS(args$LWS[0]);
    const attrValue$LWS = toString$LWS(args$LWS[2]);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      return;
    }

    args$LWS[0] = attrNamespace$LWS;
    args$LWS[1] = attrName$LWS;
    args$LWS[2] = attrValue$LWS;
    ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
  }

  return [originalSetAttributeNS$LWS, setAttributeNS$LWS];
}

function distortionElementShadowRootGetter$LWS(globalObject$LWS) {
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'shadowRoot');

  function shadowRoot$LWS() {
    return null;
  }

  return [originalShadowRootGetter$LWS, shadowRoot$LWS];
}

function distortionElementToggleAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    Element: Element$LWS
  } = globalObject$LWS;
  const {
    hasAttribute: ElementProtoHasAttribute$LWS,
    toggleAttribute: originalToggleAttribute$LWS
  } = Element$LWS.prototype;

  const toggleAttribute$LWS = function toggleAttribute$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 0) {
      const {
        0: qualifiedName$LWS
      } = args$LWS;
      const attrName$LWS = normalizeAttrName$LWS(qualifiedName$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(this, key$LWS, attrName$LWS);

      if (distortion$LWS) {
        const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely, if the distortion throws.

        ReflectApply$LWS(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to return true | false, based on
        // the presense or absense of this attribute.

        return ReflectApply$LWS(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
      }

      args$LWS[0] = attrName$LWS;
    }

    return ReflectApply$LWS(originalToggleAttribute$LWS, this, args$LWS);
  };

  return [originalToggleAttribute$LWS, toggleAttribute$LWS];
}

function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = EventCurrentTargetGetter$LWS(event$LWS);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$LWS(originalComposedPath$LWS, event$LWS, []);
  const indexOfcurrentTarget$LWS = ArrayIndexOf$LWS(rawComposedPath$LWS, currentTarget$LWS);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = indexOfcurrentTarget$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ArraySlice$LWS(rawComposedPath$LWS, i$LWS + 1);
      break;
    }
  }

  return distortedComposedPath$LWS;
}

function distortionEventComposedPath$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const {
    composedPath: originalComposedPath$LWS
  } = Event$LWS.prototype;

  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }

  return [originalComposedPath$LWS, composedPath$LWS];
}

function distortionEventPathGetter$LWS(globalObject$LWS) {
  const {
    Event: Event$LWS
  } = globalObject$LWS;
  const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return null;
  }

  const path$LWS = function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  };

  return [originalPathGetter$LWS, path$LWS];
}

function distortionEventTargetAddEventListener$LWS(globalObject$LWS, options$LWS) {
  const {
    EventTarget: EventTarget$LWS
  } = globalObject$LWS;
  const {
    addEventListener: originalAddEventListener$LWS
  } = EventTarget$LWS.prototype;

  function addEventListener$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Ensure that we fallback to the default platform behavior which
    // should fail if less than 2 arguments are provided.

    if (length$LWS > 1) {
      const {
        0: eventName$LWS
      } = args$LWS;

      if (isEventTargetRestricted$LWS(this, eventName$LWS, options$LWS)) {
        var _safeDesc$LWS;

        const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(this.constructor, 'name');
        let safeDesc$LWS;

        if (unsafeDesc$LWS) {
          safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
        }

        const name$LWS = (_safeDesc$LWS = safeDesc$LWS) == null ? void 0 : _safeDesc$LWS.value;
        let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;

        if (typeof name$LWS === 'string') {
          exceptionMessage$LWS += ` to ${name$LWS} object`;
        }

        throw new LockerSecurityError$LWS(`${exceptionMessage$LWS}.`);
      }
    }

    return ReflectApply$LWS(originalAddEventListener$LWS, this, args$LWS);
  }

  return [originalAddEventListener$LWS, addEventListener$LWS];
}

function distortionHistoryPushState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    pushState: originalPushState$LWS
  } = History$LWS.prototype;

  function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPushState$LWS, this, args$LWS);
  }

  return [originalPushState$LWS, pushState$LWS];
}

function distortionHistoryReplaceState$LWS(globalObject$LWS) {
  const {
    History: History$LWS
  } = globalObject$LWS;
  const {
    replaceState: originalReplaceState$LWS
  } = History$LWS.prototype;

  function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalReplaceState$LWS, this, args$LWS);
  }

  return [originalReplaceState$LWS, replaceState$LWS];
}

function distortionHTMLElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionHTMLElementInnerTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText');

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  const innerText$LWS = function innerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalInnerTextSetter$LWS, this, [value$LWS]);
  };

  return [originalInnerTextSetter$LWS, innerText$LWS];
} // outerText is not a standard property, so the descriptor could be undefined, like in the case
// of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility


function distortionHTMLElementOuterTextSetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText');

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  const outerText$LWS = function outerText$LWS(value$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${toString$LWS(this.nodeName)}.`);
    }

    ReflectApply$LWS(originalOuterTextSetter$LWS, this, [value$LWS]);
  };

  return [originalOuterTextSetter$LWS, outerText$LWS];
}

function distortionHTMLElementStyleGetter$LWS(globalObject$LWS) {
  const {
    HTMLElement: HTMLElement$LWS
  } = globalObject$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionHTMLFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLFrameElement: HTMLFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLIFrameElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement$LWS.prototype, 'contentWindow');

  function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  }

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function distortionHTMLIFrameElementSrcSetter$LWS(globalObject$LWS) {
  const {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');

  function src$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
    }

    HTMLIFrameElementSrcSetter$LWS(this, urlString$LWS);
  }

  registerElementSetDistortion$LWS(HTMLIFrameElement$LWS, {
    attributeName: 'src',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

const IMPORT$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return !RegExpTest$LWS(IMPORT$LWS, value$LWS);
}

function distortionHTMLLinkElementRelSetter$LWS(globalObject$LWS) {
  const {
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const string$LWS = toString$LWS(value$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  registerElementSetDistortion$LWS(HTMLLinkElement$LWS, {
    attributeName: 'rel',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: rel$LWS
  });
  return [originalRelSetter$LWS, rel$LWS];
}

function distortionHTMLLinkElementRelListSetter$LWS(globalObject$LWS) {
  const {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  } = globalObject$LWS;
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');

  function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? DOMTokenListValueGetter$LWS(relListValue$LWS) : toString$LWS(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  return [originalRelListSetter$LWS, relList$LWS];
}

function distortionHTMLObjectElementContentDocumentGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLObjectElement$LWS.prototype, 'contentDocument');

  function contentDocument$LWS() {
    // Intentionally ignoring the returned value from the original to
    // preserve error messages and other factors of the runtime.
    ReflectApply$LWS(originalContentDocumentGetter$LWS, this, []);
    return null;
  }

  return [originalContentDocumentGetter$LWS, contentDocument$LWS];
}

function distortionHTMLObjectElementContentWindowGetter$LWS(globalObject$LWS) {
  const {
    HTMLObjectElement: HTMLObjectElement$LWS
  } = globalObject$LWS;
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLObjectElement$LWS.prototype, 'contentWindow'); // contentWindow is not supported on object elements in iOS < 13.
  // https://caniuse.com/mdn-api_htmlobjectelement_contentwindow

  if (typeof originalContentWindowGetter$LWS !== 'function') {
    return null;
  }

  const contentWindow$LWS = function contentWindow$LWS() {
    const rawContentWindow$LWS = ReflectApply$LWS(originalContentWindowGetter$LWS, this, []);
    return getPatchedWindow$LWS(rawContentWindow$LWS);
  };

  return [originalContentWindowGetter$LWS, contentWindow$LWS];
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = HTMLElementDatasetGetter$LWS(el$LWS);
  const distortedSrc$LWS = ObjectLookupOwnValue$LWS(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function distortionHTMLScriptElementSrcGetter$LWS(globalObject$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLScriptElement$LWS.prototype, 'src');

  function src$LWS() {
    return getDatasetSrcValue$LWS(this) || ReflectApply$LWS(originalSrcGetter$LWS, this, []);
  }

  return [originalSrcGetter$LWS, src$LWS];
}

function abstractFactoryValueThrower$LWS(proto$LWS, propName$LWS) {
  return function valueThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const {
      [propName$LWS]: originalValue$LWS
    } = proto$LWS;

    function value$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalValue$LWS, value$LWS];
  };
}

function abstractFactoryGetThrower$LWS(proto$LWS, propName$LWS) {
  return function getThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalGet$LWS = ObjectLookupOwnGetter$LWS(proto$LWS, propName$LWS);

    function get$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalGet$LWS, get$LWS];
  };
}

function abstractFactorySetThrower$LWS(proto$LWS, propName$LWS) {
  return function setThrowerDistortionFactory$LWS(_globalObject$LWS) {
    const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, propName$LWS);

    function set$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalSet$LWS, set$LWS];
  };
}
/**
 * Wraps the source content of a script tag in the evaluator
 * Creates a blob: url with the wrapped content
 * @param text String
 * @param key String
 * @returns String
 */


function createScriptUrl$LWS(text$LWS, key$LWS) {
  const transformedText$LWS = transformUncompiledSource$LWS(text$LWS);
  const payload$LWS = WindowEncodeURIComponent$LWS(transformedText$LWS);
  const blobScript$LWS = `
    {
        const { $evaluator$ } = document.currentScript;
        const text = decodeURIComponent(\`${payload$LWS}\`);
        delete document.currentScript.$evaluator$;
        $evaluator$('${key$LWS}', text, { ${UNCOMPILED_LOCATION_NAME$LWS}: location });
    }`;
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([blobScript$LWS], {
    type: 'text/javascript'
  }));
}

function scriptDistortion$LWS(attributeName$LWS, options$LWS, datasetGetter$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const normalizerAnchor$LWS = DocumentCreateElement$LWS(document, 'a');
  return function distortion$LWS(value$LWS) {
    const originalValue$LWS = value$LWS;
    const elementNamespaceURI$LWS = ElementGetNamespaceURI$LWS(this);
    const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;

    if (value$LWS === '') {
      ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, value$LWS);
      return;
    } // Normalize Value


    HTMLAnchorElementHrefSetter$LWS(normalizerAnchor$LWS, value$LWS);
    value$LWS = HTMLAnchorElementHrefGetter$LWS(normalizerAnchor$LWS); // Create Synthetic Attribute

    const dataset$LWS = datasetGetter$LWS(this);
    dataset$LWS[`distorted${capitalizeFirstChar$LWS(attributeName$LWS)}`] = originalValue$LWS; // Create XHR

    const hostname$LWS = HTMLAnchorElementHostnameGetter$LWS(normalizerAnchor$LWS);
    const xhr$LWS = new XhrCtor$LWS();

    if (StringMatch$LWS(hostname$LWS, TRUSTED_DOMAINS$LWS)) {
      XhrWithCredentialsSetter$LWS(xhr$LWS, true);
    }

    EventTargetAddEventListener$LWS(xhr$LWS, 'load', () => {
      const status$LWS = XhrStatusGetter$LWS(xhr$LWS);

      if (status$LWS === 200) {
        const responseText$LWS = XhrResponseTextGetter$LWS(xhr$LWS);
        ReflectDefineProperty$LWS(this, '$evaluator$', {
          __proto__: null,
          configurable: true,
          value: evaluator$LWS
        });
        ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, createScriptUrl$LWS(responseText$LWS, key$LWS));
      } else if (status$LWS === 404) {
        ElementSetAttributeNS$LWS(this, attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found');
      }
    });
    XhrOpen$LWS(xhr$LWS, 'GET', value$LWS);
    XhrSend$LWS(xhr$LWS);
  };
}

function distortBlockedProperties$LWS(proto$LWS, propertyList$LWS) {
  const entries$LWS = [];
  let entriesOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = propertyList$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = propertyList$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;

        if (getter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactoryGetThrower$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          entries$LWS[entriesOffset$LWS++] = abstractFactorySetThrower$LWS(proto$LWS, prop$LWS);
        }
      } else if (typeof value$LWS === 'function') {
        entries$LWS[entriesOffset$LWS++] = abstractFactoryValueThrower$LWS(proto$LWS, prop$LWS);
      }
    }
  }

  return entries$LWS;
}

function distortBlockedAttributes$LWS(ctor$LWS, attributes$LWS, elNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attributeName$LWS = attributes$LWS[i$LWS];
    const {
      name: ctorName$LWS
    } = ctor$LWS;
    registerElementSetDistortion$LWS(ctor$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: elNamespace$LWS,

      distortion() {
        throw new LockerSecurityError$LWS(`Attribute "${attributeName$LWS}" not allowed on ${ctorName$LWS}.`);
      }

    });
  }
}

function maybeMaskDistortion$LWS(distortedValue$LWS, rawValue$LWS) {
  if (typeof distortedValue$LWS === 'function' && typeof rawValue$LWS === 'function') {
    return maskDistortion$LWS(distortedValue$LWS, rawValue$LWS);
  }

  return distortedValue$LWS;
}

function distortionHTMLScriptElementSrcSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    HTMLScriptElement: HTMLScriptElement$LWS
  } = globalObject$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLScriptElement$LWS.prototype, 'src');
  const src$LWS = scriptDistortion$LWS('src', options$LWS, HTMLElementDatasetGetter$LWS);
  registerElementSetDistortion$LWS(HTMLScriptElement$LWS, {
    attributeName: 'src',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: src$LWS
  });
  return [originalSrcSetter$LWS, src$LWS];
}

function distortionIDBObjectStoreAdd$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    add: originalAdd$LWS
  } = IDBObjectStore$LWS.prototype;

  function add$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalAdd$LWS, this, args$LWS);
  }

  return [originalAdd$LWS, add$LWS];
}

function distortionIDBObjectStorePut$LWS(globalObject$LWS) {
  const {
    IDBObjectStore: IDBObjectStore$LWS
  } = globalObject$LWS;
  const {
    put: originalPut$LWS
  } = IDBObjectStore$LWS.prototype;

  function put$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPut$LWS, this, args$LWS);
  }

  return [originalPut$LWS, put$LWS];
}

function distortionMessageEventSourceGetter$LWS(globalObject$LWS) {
  const {
    MessageEvent: MessageEvent$LWS
  } = globalObject$LWS;
  const originalSourceGetter$LWS = ObjectLookupOwnGetter$LWS(MessageEvent$LWS.prototype, 'source');

  function source$LWS() {
    const rawSource$LWS = ReflectApply$LWS(originalSourceGetter$LWS, this, []);
    return toString$LWS(rawSource$LWS) === '[object Window]' ? getPatchedWindow$LWS(rawSource$LWS) : rawSource$LWS;
  }

  return [originalSourceGetter$LWS, source$LWS];
}

function distortionNamedNodeMapSetNamedItem$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItem: originalSetNamedItem$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItem$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetNamedItem$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItem$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItem$LWS, setNamedItem$LWS];
}

function distortionNamedNodeMapSetNamedItemNS$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    NamedNodeMap: NamedNodeMap$LWS
  } = globalObject$LWS;
  const {
    setNamedItemNS: originalSetNamedItemNS$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItemNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetNamedItemNS$LWS, this, args$LWS);
    }

    return setNamedItemWithAttr$LWS(originalSetNamedItemNS$LWS, this, attr$LWS, options$LWS);
  }

  return [originalSetNamedItemNS$LWS, setNamedItemNS$LWS];
}

function distortionNavigatorSendBeacon$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const {
    sendBeacon: originalSendBeacon$LWS
  } = Navigator$LWS.prototype;

  function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: url$LWS
      } = args$LWS;
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return ReflectApply$LWS(originalSendBeacon$LWS, this, args$LWS);
  }

  return [originalSendBeacon$LWS, sendBeacon$LWS];
}

function distortionNavigatorServiceWorkerGetter$LWS(globalObject$LWS) {
  const {
    Navigator: Navigator$LWS
  } = globalObject$LWS;
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS(Navigator$LWS.prototype, 'serviceWorker');

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS() {
    return undefined;
  };

  return [originalServiceWorkerGetter$LWS, get$LWS];
}

function distortionNodeInsertBefore$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    insertBefore: originalInsertBefore$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);

  function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${toString$LWS(argValue$LWS.nodeName)} into ${toString$LWS(this.nodeName)},`);
      }
    }

    return ReflectApply$LWS(originalInsertBefore$LWS, this, args$LWS);
  }

  return [originalInsertBefore$LWS, insertBefore$LWS];
}

function distortionAttrNodeValueSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');

  function nodeValue$LWS(value$LWS) {
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the nodeValue property.
    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

      if (ownerElement$LWS === null) {
        return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
      }

      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [value$LWS]);
      }
    }

    return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
  }

  return [originalNodeValueSetter$LWS, nodeValue$LWS];
}

function distortionNodeRemoveChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    removeChild: originalRemoveChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${toString$LWS(argValue$LWS.nodeName)}.`);
      }
    }

    return ReflectApply$LWS(originalRemoveChild$LWS, this, args$LWS);
  }

  return [originalRemoveChild$LWS, removeChild$LWS];
}

function distortionNodeReplaceChild$LWS(globalObject$LWS) {
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    replaceChild: originalReplaceChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments. If the "old element"
    // argument is a valid shared element, an exception is thrown.
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      const {
        1: argValue$LWS
      } = args$LWS;

      if (isSharedElement$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${toString$LWS(argValue$LWS.nodeName)}.`);
      }
    }

    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChild$LWS];
}

function distortionNodeTextContentSetter$LWS(globalObject$LWS, options$LWS) {
  const {
    Attr: Attr$LWS,
    Node: Node$LWS
  } = globalObject$LWS;
  const {
    key: key$LWS
  } = options$LWS;
  const originalTextContentSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'textContent'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(window);

  function textContent$LWS(value$LWS) {
    const valueString$LWS = toString$LWS(value$LWS); // There are two existence of the attribute textContent, one on Attr and one on Node.
    // This first if statement is checking to figure out which distortion should be applied.
    // The instanceof operator tests to see if the current global object, this, is of the type Attr,
    // while also taking inheritance into consideration.
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the textContent property.

    if (this instanceof Attr$LWS) {
      const ownerElement$LWS = AttrOwnerElementGetter$LWS(this);

      if (ownerElement$LWS === null) {
        return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueString$LWS]);
      }

      const attrName$LWS = AttrNameGetter$LWS(this);
      const attrNamespace$LWS = AttrNamespaceURIGetter$LWS(this);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(ownerElement$LWS, key$LWS, attrName$LWS, normalizedNamespace$LWS);

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [valueString$LWS]);
      }
    }

    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set textContent of ${toString$LWS(this.nodeName)} elements.`);
    }

    return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueString$LWS]);
  }

  return [originalTextContentSetter$LWS, textContent$LWS];
}

function distortionNotificationCtor$LWS(globalObject$LWS) {
  const {
    Notification: originalNotificationCtor$LWS
  } = globalObject$LWS;

  if (typeof originalNotificationCtor$LWS !== 'function') {
    return null;
  }

  const Notification$LWS = function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = partialStructuredClone$LWS(args$LWS[1]);
    }

    return ReflectApply$LWS(originalNotificationCtor$LWS, this, args$LWS);
  };

  return [originalNotificationCtor$LWS, Notification$LWS];
}

function distortionRangeCreateContextualFragment$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    createContextualFragment: originalCreateContextualFragment$LWS
  } = Range$LWS.prototype;

  function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = sanitize$LWS(tagString$LWS);
      }
    }

    return ReflectApply$LWS(originalCreateContextualFragment$LWS, this, args$LWS);
  }

  return [originalCreateContextualFragment$LWS, createContextualFragment$LWS];
}

function distortionRangeDeleteContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    deleteContents: originalDeleteContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function deleteContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = ReflectApply$LWS(originalCloneContents$LWS, this, []);
    const elementFound$LWS = DocumentFragmentQuerySelector$LWS(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new LockerSecurityError$LWS(`Cannot delete contents of ${elementFound$LWS.nodeName}.`);
    }

    return ReflectApply$LWS(originalDeleteContents$LWS, this, args$LWS);
  }

  return [originalDeleteContents$LWS, deleteContents$LWS];
}

function distortionRangeExtractContents$LWS(globalObject$LWS) {
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    extractContents: originalExtractContents$LWS,
    cloneContents: originalCloneContents$LWS
  } = Range$LWS.prototype;

  function extractContents$LWS(...args$LWS) {
    // In order to search the selected objects of a Range,
    // we need to convert the nodes in the Range into a DocumentFragment.
    const clonedContentsFragment$LWS = ReflectApply$LWS(originalCloneContents$LWS, this, []);
    const elementFound$LWS = DocumentFragmentQuerySelector$LWS(clonedContentsFragment$LWS, 'html,head,body');

    if (elementFound$LWS) {
      throw new LockerSecurityError$LWS(`Cannot extract contents of ${elementFound$LWS.nodeName}.`);
    }

    return ReflectApply$LWS(originalExtractContents$LWS, this, args$LWS);
  }

  return [originalExtractContents$LWS, extractContents$LWS];
}

function distortionRangeInsertNode$LWS(globalObject$LWS) {
  // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(window);
  const {
    Range: Range$LWS
  } = globalObject$LWS;
  const {
    insertNode: originalInsertNode$LWS
  } = Range$LWS.prototype;
  const originalCommonAncestorContainer$LWS = ObjectLookupOwnGetter$LWS(Range$LWS.prototype, 'commonAncestorContainer');

  function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: argValue$LWS
      } = args$LWS;
      const commonAncestorContainer$LWS = ReflectApply$LWS(originalCommonAncestorContainer$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(argValue$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${commonAncestorContainer$LWS.nodeName}.`);
      }
    }

    return ReflectApply$LWS(originalInsertNode$LWS, this, args$LWS);
  }

  return [originalInsertNode$LWS, insertNode$LWS];
}

function distortionServiceWorkerContainer$LWS(globalObject$LWS) {
  const {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  } = globalObject$LWS;

  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionShadowRootInnerHTMLSetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');

  function innerHTML$LWS(value$LWS) {
    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionShadowRootModeGetter$LWS(globalObject$LWS) {
  const {
    ShadowRoot: ShadowRoot$LWS
  } = globalObject$LWS;
  const originalModeGetter$LWS = ObjectLookupOwnGetter$LWS(ShadowRoot$LWS.prototype, 'mode');

  function mode$LWS() {
    return 'closed';
  }

  return [originalModeGetter$LWS, mode$LWS];
}

function distortionSharedWorkerCtor$LWS(globalObject$LWS) {
  const {
    SharedWorker: originalSharedWorkerCtor$LWS
  } = globalObject$LWS;

  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return null;
  }

  const SharedWorker$LWS = function SharedWorker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toString$LWS(scriptURL$LWS)}.`);
  };

  return [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
}

function distortionSharedWorkerProto$LWS(globalObject$LWS) {
  const {
    SharedWorker: SharedWorker$LWS
  } = globalObject$LWS;

  if (typeof SharedWorker$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (StringStartsWith$LWS(key$LWS, storageRootKey$LWS)) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = new ArrayCtor$LWS(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = StringReplace$LWS(key$LWS, storageRootKey$LWS, '');
  }

  return keys$LWS;
}

const meta$LWS = new WeakMap();

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = WeakMapGet$LWS(meta$LWS, storage$LWS);

  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(s$LWS) {
  return new Proxy(s$LWS, {
    get(target$LWS, key$LWS, receiver$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwnProperty$LWS(storage$LWS, keyForNamespace$LWS)) {
        return ReflectGet$LWS(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, descriptor$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const safeDesc$LWS = toSafeDescriptor$LWS(descriptor$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDefineProperty$LWS(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDeleteProperty$LWS(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, keyForNamespace$LWS);
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },

    has(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwnProperty$LWS(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return ReflectHas$LWS(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
}

class PatchedStorage$LWS {
  constructor() {
    throw new LockerSecurityError$LWS('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return StringReplace$LWS(resolvedKey$LWS, storageRootKey$LWS, '');
    }

    return ReflectApply$LWS(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    return ReflectApply$LWS(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
      args$LWS[1] = toString$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const target$LWS = {
    __proto__: PatchedStorage$LWS.prototype
  };
  markLiveObject$LWS(target$LWS);
  const proxy$LWS = createStorageProxy$LWS(target$LWS);
  const storageMeta$LWS = {
    proxy: proxy$LWS,
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  };
  WeakMapSet$LWS(meta$LWS, proxy$LWS, storageMeta$LWS);
  WeakMapSet$LWS(meta$LWS, target$LWS, storageMeta$LWS);
  return proxy$LWS;
}

const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorage$LWS.prototype;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS(PatchedStorage$LWS.prototype, 'length');

function createDistortionStorageFactory$LWS(storageName$LWS) {
  return function distortionStorageFactory$LWS(globalObject$LWS, options$LWS) {
    const storageObject$LWS = globalObject$LWS[storageName$LWS];

    if (!isObject$LWS(storageObject$LWS)) {
      return null;
    }

    const {
      key: key$LWS
    } = options$LWS;
    const rootKey$LWS = getStorageRootKey$LWS(key$LWS);
    const patchedStorageObject$LWS = createStorage$LWS(storageObject$LWS, rootKey$LWS);
    return [storageObject$LWS, patchedStorageObject$LWS];
  };
}

function distortionStorageLength$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(Storage$LWS.prototype, 'length');
  return [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
}

function distortionStorageGetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    getItem: originalStorageGetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
}

function distortionStorageSetItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    setItem: originalStorageSetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
}

function distortionStorageKey$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    key: originalStorageKey$LWS
  } = Storage$LWS.prototype;
  return [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
}

function distortionStorageRemoveItem$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    removeItem: originalStorageRemoveItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
}

function distortionStorageClear$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  const {
    clear: originalStorageClear$LWS
  } = Storage$LWS.prototype;
  return [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
}

function distortionStorage$LWS(globalObject$LWS) {
  const {
    Storage: Storage$LWS
  } = globalObject$LWS;
  return [Storage$LWS, PatchedStorage$LWS];
}

const distortionLocalStorage$LWS = createDistortionStorageFactory$LWS('localStorage');
const distortionSessionStorage$LWS = createDistortionStorageFactory$LWS('sessionStorage');

function distortionSVGAnimateElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ElementHasAttribute$LWS(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = ElementGetAttribute$LWS(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'from');
      distortAttribute$LWS(this, 'to');
      distortAttribute$LWS(this, 'values');
    }
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGAnimateElementFromAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function from$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'from',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: from$LWS
  });
  return null;
}

function distortionSVGAnimateElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'to',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: to$LWS
  });
  return null;
}

function distortionSVGAnimateElementValuesAttribute$LWS(globalObject$LWS) {
  const {
    SVGAnimateElement: SVGAnimateElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      const valuesSplit$LWS = StringSplit$LWS(value$LWS, ';');
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = ArrayJoin$LWS(valuesSplit$LWS, ';');
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  registerElementSetDistortion$LWS(SVGAnimateElement$LWS, {
    attributeName: 'values',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: values$LWS
  });
  return null;
}

function distortionSVGElementDatasetGetter$LWS(globalObject$LWS) {
  const {
    SVGElement: SVGElement$LWS
  } = globalObject$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionSVGScriptElementHrefAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'href',
    attributeNamespace: NAMESPACE_XLINK$LWS,
    distortion: scriptDistortion$LWS('href', options$LWS, SVGElementDatasetGetter$LWS)
  });
  registerElementSetDistortion$LWS(SVGScriptElement$LWS, {
    attributeName: 'xlink:href',
    attributeNamespace: NAMESPACE_XLINK$LWS,
    distortion: scriptDistortion$LWS('xlink:href', options$LWS, SVGElementDatasetGetter$LWS)
  });
  return null;
}

function distortionSVGSetElementAttributeNameAttribute$LWS(globalObject$LWS, options$LWS) {
  const {
    key: key$LWS
  } = options$LWS;
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ElementHasAttribute$LWS(el$LWS, attrName$LWS)) {
      const originalAttributeValue$LWS = ElementGetAttribute$LWS(el$LWS, attrName$LWS);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(el$LWS, key$LWS, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'to');
    }
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'attributeName',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: attributeName$LWS
  });
  return null;
}

function distortionSVGSetElementToAttribute$LWS(globalObject$LWS) {
  const {
    SVGSetElement: SVGSetElement$LWS
  } = globalObject$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ElementGetAttribute$LWS(this, 'attributeName') === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(SVGSetElement$LWS, {
    attributeName: 'to',
    attributeNamespace: NAMESPACE_DEFAULT$LWS,
    distortion: to$LWS
  });
  return null;
}

function createDistortionHrefAttributeFactory$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactory$LWS(globalObject$LWS) {
    const {
      SVGUseElement: SVGUseElement$LWS
    } = globalObject$LWS;
    const {
      setAttribute: originalSetAttribute$LWS,
      setAttributeNS: originalSetAttributeNS$LWS
    } = Element.prototype;

    if (attributeName$LWS === 'href') {
      const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
        ReflectApply$LWS(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
      };

      registerElementSetDistortion$LWS(SVGUseElement$LWS, {
        attributeName: attributeName$LWS,
        attributeNamespace: NAMESPACE_DEFAULT$LWS,
        distortion: defaultNamespaceDistortion$LWS
      });
    }

    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }

    registerElementSetDistortion$LWS(SVGUseElement$LWS, {
      attributeName: attributeName$LWS,
      attributeNamespace: NAMESPACE_XLINK$LWS,
      distortion: xlinkNamespaceDistortion$LWS
    });
    return null;
  };
}

const distortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('href');
const distortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('xlink:href');

function distortionTrustedTypePolicyFactoryCreatePolicy$LWS(globalObject$LWS) {
  const {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  } = globalObject$LWS;

  if (typeof TrustedTypePolicyFactory$LWS !== 'function') {
    return null;
  }

  const {
    createPolicy: originalCreatePolicy$LWS
  } = TrustedTypePolicyFactory$LWS.prototype;

  const createPolicy$LWS = function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    }

    return ReflectApply$LWS(originalCreatePolicy$LWS, this, args$LWS);
  };

  return [originalCreatePolicy$LWS, createPolicy$LWS];
}

const HTML_MIME_TYPES$LWS = ['text/html', 'image/svg+xml', 'text/xml'];

function distortionURLCreateObjectURL$LWS(globalObject$LWS) {
  const {
    URL: URL$LWS
  } = globalObject$LWS;
  const {
    createObjectURL: originalCreateObjectURL$LWS
  } = URL$LWS;
  const {
    isEqualDomString: isEqualDomString$LWS,
    isMediaSourceObject: isMediaSourceObject$LWS
  } = getValidator$LWS(globalObject$LWS);

  function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [blobObject$LWS]); // MediaSource does not share the same proto object as Blob or File.
    // It can still be used with createObjectURL however we need to treat it separately.
    // MediaSource does not accept plain text input as Blob and File and does not have a MIME type.

    if (isMediaSourceObject$LWS(blobObject$LWS)) {
      return outURL$LWS;
    }

    const type$LWS = BlobTypeGetter$LWS(blobObject$LWS);

    if (type$LWS === '') {
      // browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      return ReflectApply$LWS(originalCreateObjectURL$LWS, this, [BlobSlice$LWS(blobObject$LWS, 0, undefined, 'text/plain')]);
    }

    if (ArrayIncludes$LWS(HTML_MIME_TYPES$LWS, type$LWS)) {
      const normalizedBlob$LWS = BlobSlice$LWS(blobObject$LWS, 0, BlobSizeGetter$LWS(blobObject$LWS), `${type$LWS};charset=utf-8`);
      URLRevokeObjectURL$LWS(outURL$LWS);
      outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new XhrCtor$LWS();
      XhrOpen$LWS(xhr$LWS, 'GET', outURL$LWS, false);
      XhrSend$LWS(xhr$LWS);
      const sanitizer$LWS = blobSanitizer$LWS();
      const responseText$LWS = XhrResponseTextGetter$LWS(xhr$LWS);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS(`Cannot "createObjectURL" using a unsecure ${toString$LWS(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (isMIMETypeAllowed$LWS(type$LWS)) {
      return outURL$LWS;
    }

    URLRevokeObjectURL$LWS(outURL$LWS);
    throw new LockerSecurityError$LWS('Unsupported MIME type.');
  }

  return [originalCreateObjectURL$LWS, createObjectURL$LWS];
}

function distortionWindowFetch$LWS(globalObject$LWS) {
  const {
    fetch: originalFetch$LWS
  } = globalObject$LWS;

  function fetch$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(RequestURLGetter$LWS(url$LWS));
      } else {
        parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toString$LWS(url$LWS)}.`));
      }
    }

    return ReflectApply$LWS(originalFetch$LWS, this, args$LWS);
  }

  return [originalFetch$LWS, fetch$LWS];
}
/* eslint-disable class-methods-use-this, max-classes-per-file */


function distortionWindowFramesGetter$LWS(globalObject$LWS) {
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'frames');

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return null;
  }

  let framesProxy$LWS;

  const frames$LWS = function frames$LWS() {
    if (!framesProxy$LWS) {
      const integerRegExp$LWS = /^0$|^[1-9][0-9]*$/;
      const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS(globalObject$LWS);
      const WindowProperties$LWS = ReflectGetPrototypeOf$LWS(WindowPrototype$LWS);

      const getFrameByIndexKey$LWS = key$LWS => {
        if (isFrameIndexKey$LWS(key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return getPatchedWindow$LWS(value$LWS);
          }
        }

        return undefined;
      };

      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
        !ObjectHasOwnProperty$LWS(globalObject$LWS, key$LWS) && // ...Or its prototype.
        !ObjectHasOwnProperty$LWS(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);

          if (isFrame$LWS(value$LWS)) {
            return getPatchedWindow$LWS(value$LWS);
          }
        }

        return undefined;
      };

      const getValueByKey$LWS = key$LWS => {
        if (key$LWS === 'length') {
          return WindowLengthGetter$LWS(globalObject$LWS);
        }

        if (isFrameIndexKey$LWS(key$LWS)) {
          return getFrameByIndexKey$LWS(key$LWS);
        }

        return undefined;
      };

      const isFrame$LWS = value$LWS => value$LWS !== undefined && value$LWS !== globalObject$LWS && isWindowLike$LWS(value$LWS) && isWindow$LWS(value$LWS);

      const isFrameIndexKey$LWS = key$LWS => RegExpTest$LWS(integerRegExp$LWS, key$LWS) && key$LWS < WindowLengthGetter$LWS(globalObject$LWS); // The rules for this proxy are as follows:
      //
      // If the key is a string...
      //      ...And the key is a valid index that matches an existing
      //      index in the frame list or matches the value of a name
      //      property of a frame in the frame list, then return the
      //      appropriate frame from the frame list.
      //
      //      ...Or the key's value is "length", then return the number of
      //      frames in the in the frame list.
      //  Else,
      //      ...Return the value of the key from the shadow target


      class BaseFrameHandler$LWS {
        defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
          return false;
        }

        deleteProperty(_target$LWS, _key$LWS) {
          return false;
        }

        getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
          return undefined;
        }

        isExtensible(_target$LWS) {
          return true;
        }

        ownKeys(_target$LWS) {
          return [];
        }

        preventExtensions(_target$LWS) {
          return true;
        }

        set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
          return false;
        }

        setPrototypeOf(_target$LWS) {
          return false;
        }

      }

      ReflectSetPrototypeOf$LWS(BaseFrameHandler$LWS.prototype, null);
      ObjectFreeze$LWS(BaseFrameHandler$LWS.prototype);

      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.length
          // window.frames[n]
          // window.frames['n']
          const value$LWS = getValueByKey$LWS(key$LWS);

          if (value$LWS !== undefined) {
            return value$LWS;
          } // window.frames.foo when iframe.name is 'foo'


          return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              configurable: true,
              enumerable: true,

              get() {
                return getValueByKey$LWS('length');
              },

              set(_v$LWS) {}

            };
          }

          const value$LWS = isFrameIndexKey$LWS(key$LWS) ? getFrameByIndexKey$LWS(key$LWS) : undefined;

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getValueByKey$LWS(key$LWS) !== undefined || ReflectHas$LWS(target$LWS, key$LWS);
        }

        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = ArrayCtor$LWS(length$LWS + 1);

          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }

          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }

      }

      class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          // window.frames.foo when iframe.name is 'foo'
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ? ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);

          if (value$LWS) {
            return {
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return getFrameByNameKey$LWS(key$LWS) !== undefined || ReflectHas$LWS(target$LWS, key$LWS);
        }

        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const descMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
          ReflectSetPrototypeOf$LWS(descMap$LWS, null);

          for (const key$LWS in descMap$LWS) {
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = descMap$LWS[key$LWS];

              if (ObjectHasOwnProperty$LWS(unsafeDesc$LWS, 'value') && isFrame$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }

          return keys$LWS;
        }

      } // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.


      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = ObjectFreeze$LWS(new ShadowFrameHandler$LWS());
      const shadowFramesPrototypeHandler$LWS = ObjectFreeze$LWS(new ShadowFramesPrototypeHandler$LWS());
      const shadowWindowPropertiesHandler$LWS = ObjectFreeze$LWS(new ShadowWindowPropertiesHandler$LWS());
      const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      ReflectSetPrototypeOf$LWS(shadowFrames$LWS, framesPrototypeProxy$LWS);
      ReflectSetPrototypeOf$LWS(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      framesProxy$LWS = new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
    }

    return framesProxy$LWS;
  };

  return [originalWindowFramesGetter$LWS, frames$LWS];
}

function distortionWindowGetComputedStyle$LWS(globalObject$LWS) {
  const {
    getComputedStyle: originalGetComputedStyle$LWS
  } = globalObject$LWS;

  function getComputedStyle$LWS(...args$LWS) {
    return toLiveValue$LWS(ReflectApply$LWS(originalGetComputedStyle$LWS, this, args$LWS));
  }

  return [originalGetComputedStyle$LWS, getComputedStyle$LWS];
}

function distortionWindowLengthGetter$LWS(globalObject$LWS) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'length');

  if (typeof originalLengthGetter$LWS !== 'function') {
    return null;
  }

  const length$LWS = function length$LWS() {
    return 0;
  };

  return [originalLengthGetter$LWS, length$LWS];
}

function distortionWindowOnstorage$LWS(globalObject$LWS, options$LWS) {
  const {
    Window: Window$LWS
  } = globalObject$LWS;
  const originalOnstorageSetter$LWS = ObjectLookupOwnSetter$LWS(globalObject$LWS, 'onstorage');

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return null;
  }

  const onstorage$LWS = function onstorage$LWS() {
    throw new LockerSecurityError$LWS('Cannot set window.onstorage.');
  };

  registerEventTargetRestriction$LWS(Window$LWS, 'storage', options$LWS);
  return [originalOnstorageSetter$LWS, onstorage$LWS];
}

function distortionWindowOpen$LWS(globalObject$LWS) {
  const {
    open: originalWindowOpen$LWS
  } = globalObject$LWS;

  function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    const rawOpenWindow$LWS = ReflectApply$LWS(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
    return getPatchedWindow$LWS(rawOpenWindow$LWS);
  }

  return [originalWindowOpen$LWS, open$LWS];
}

function distortionWindowOpenerGetter$LWS(globalObject$LWS) {
  const originalOpenerGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'opener');

  if (typeof originalOpenerGetter$LWS !== 'function') {
    return null;
  }

  const opener$LWS = function opener$LWS() {
    const rawOpener$LWS = ReflectApply$LWS(originalOpenerGetter$LWS, globalObject$LWS, []);
    return getPatchedWindow$LWS(rawOpener$LWS);
  };

  return [originalOpenerGetter$LWS, opener$LWS];
}

function distortionWindowParentGetter$LWS(globalObject$LWS) {
  const originalParentGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'parent');

  if (typeof originalParentGetter$LWS !== 'function') {
    return null;
  }

  const parent$LWS = function parent$LWS() {
    const rawParentWindow$LWS = ReflectApply$LWS(originalParentGetter$LWS, globalObject$LWS, []);
    return getPatchedWindow$LWS(rawParentWindow$LWS);
  };

  return [originalParentGetter$LWS, parent$LWS];
}

function distortionWindowPostMessage$LWS(globalObject$LWS) {
  return [globalObject$LWS.postMessage, getPatchedPostMessage$LWS(globalObject$LWS)];
}

function distortionWindowSetInterval$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setInterval: originalSetInterval$LWS
  } = globalObject$LWS;

  function setInterval$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetInterval$LWS, this, args$LWS);
  }

  return [originalSetInterval$LWS, setInterval$LWS];
}

function distortionWindowSetTimeout$LWS(globalObject$LWS, options$LWS) {
  const {
    evaluator: evaluator$LWS,
    key: key$LWS
  } = options$LWS;
  const {
    setTimeout: originalSetTimeout$LWS
  } = globalObject$LWS;

  function setTimeout$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const code$LWS = toString$LWS(callback$LWS); // Replace callback parameter.

        args$LWS[0] = () => {
          evaluator$LWS(key$LWS, code$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetTimeout$LWS, this, args$LWS);
  }

  return [originalSetTimeout$LWS, setTimeout$LWS];
}

function distortionWindowStructuredClone$LWS(globalObject$LWS) {
  const {
    structuredClone: originalStructuredClone$LWS
  } = globalObject$LWS;

  if (typeof originalStructuredClone$LWS !== 'function') {
    return null;
  }

  const structuredClone$LWS = function structuredClone$LWS(...args$LWS) {
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalStructuredClone$LWS, this, args$LWS);
  };

  return [originalStructuredClone$LWS, structuredClone$LWS];
}

function distortionWorkerCtor$LWS(globalObject$LWS) {
  const {
    Worker: originalWorkerCtor$LWS
  } = globalObject$LWS;

  function Worker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create Worker with ${toString$LWS(scriptURL$LWS)}.`);
  }

  return [originalWorkerCtor$LWS, Worker$LWS];
}

function distortionWorkerProto$LWS(globalObject$LWS) {
  const {
    Worker: {
      prototype: originalPrototype$LWS
    }
  } = globalObject$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionXMLHttpRequestOpen$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const {
    open: originalOpen$LWS
  } = XMLHttpRequest$LWS.prototype;

  function open$LWS(...args$LWS) {
    // Let the browser handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (isInvalidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  }

  return [originalOpen$LWS, open$LWS];
}

function distortionXMLHttpRequestResponseGetter$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'response');

  function response$LWS() {
    const rawResponse$LWS = ReflectApply$LWS(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS) : rawResponse$LWS;
  }

  return [originalResponseGetter$LWS, response$LWS];
}

function distortionXMLHttpRequestResponseXMLGetter$LWS(globalObject$LWS) {
  const {
    XMLHttpRequest: XMLHttpRequest$LWS
  } = globalObject$LWS;
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'responseXML');

  function responseXML$LWS() {
    const rawResponseXML$LWS = ReflectApply$LWS(originalResponseXMLGetter$LWS, this, []);
    return sanitizeDocument$LWS(rawResponseXML$LWS);
  }

  return [originalResponseXMLGetter$LWS, responseXML$LWS];
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const fundamentalDistortionFactories$LWS = [// CSSStyleRule
distortionCSSStyleRuleStyleGetter$LWS, // Document
distortionDocumentDomainSetter$LWS, distortionDocumentExecCommand$LWS, distortionDocumentOpen$LWS, // DOMParser
distortionDOMParserParseFromString$LWS, // Element
distortionElementAttachShadow$LWS, distortionElementAttributesGetter$LWS, distortionElementInnerHTMLSetter$LWS, distortionElementOuterHTMLSetter$LWS, distortionElementInsertAdjacentHTML$LWS, distortionElementRemove$LWS, distortionElementReplaceChildren$LWS, distortionElementReplaceWith$LWS, // Event
distortionEventComposedPath$LWS, distortionEventPathGetter$LWS, // EventTarget
distortionEventTargetAddEventListener$LWS, // History
distortionHistoryPushState$LWS, distortionHistoryReplaceState$LWS, // HTMLElement
distortionHTMLElementDatasetGetter$LWS, distortionHTMLElementInnerTextSetter$LWS, distortionHTMLElementOuterTextSetter$LWS, distortionHTMLElementStyleGetter$LWS, // HTMLFrameElement
distortionHTMLFrameElementContentDocumentGetter$LWS, distortionHTMLFrameElementContentWindowGetter$LWS, // HTMLIFrameElement
distortionHTMLIFrameElementSrcSetter$LWS, distortionHTMLIFrameElementContentDocumentGetter$LWS, distortionHTMLIFrameElementContentWindowGetter$LWS, // HTMLLinkElement
distortionHTMLLinkElementRelSetter$LWS, distortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
distortionHTMLObjectElementContentDocumentGetter$LWS, distortionHTMLObjectElementContentWindowGetter$LWS, // HTMLScriptElement
distortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
distortionIDBObjectStoreAdd$LWS, distortionIDBObjectStorePut$LWS, // MessageEvent
distortionMessageEventSourceGetter$LWS, // Navigator
distortionNavigatorSendBeacon$LWS, distortionNavigatorServiceWorkerGetter$LWS, // Node
distortionNodeRemoveChild$LWS, distortionNodeReplaceChild$LWS, distortionAttrNodeValueSetter$LWS, distortionNodeTextContentSetter$LWS, // Notification
distortionNotificationCtor$LWS, // Range
distortionRangeCreateContextualFragment$LWS, distortionRangeDeleteContents$LWS, distortionRangeExtractContents$LWS, distortionRangeInsertNode$LWS, // ServiceWorkerContainer
distortionServiceWorkerContainer$LWS, // ShadowRoot
distortionShadowRootInnerHTMLSetter$LWS, distortionShadowRootModeGetter$LWS, // SharedWorker
distortionSharedWorkerCtor$LWS, distortionSharedWorkerProto$LWS, // Storage
distortionStorageLength$LWS, distortionStorageGetItem$LWS, distortionStorageSetItem$LWS, distortionStorageKey$LWS, distortionStorageRemoveItem$LWS, distortionStorageClear$LWS, distortionStorage$LWS, // SVGAnimateElement
distortionSVGAnimateElementAttributeNameAttribute$LWS, distortionSVGAnimateElementFromAttribute$LWS, distortionSVGAnimateElementToAttribute$LWS, distortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
distortionSVGElementDatasetGetter$LWS, // SVGSetElement
distortionSVGSetElementAttributeNameAttribute$LWS, distortionSVGSetElementToAttribute$LWS, // SVGUseElement
distortionSVGUseElementHrefAttribute$LWS, distortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
distortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
distortionURLCreateObjectURL$LWS, // Window
distortionWindowFetch$LWS, distortionWindowFramesGetter$LWS, distortionWindowGetComputedStyle$LWS, distortionWindowLengthGetter$LWS, distortionWindowOnstorage$LWS, distortionWindowOpen$LWS, distortionWindowOpenerGetter$LWS, distortionWindowParentGetter$LWS, distortionWindowPostMessage$LWS, distortionWindowStructuredClone$LWS, // Worker
distortionWorkerCtor$LWS, distortionWorkerProto$LWS, // XHR
distortionXMLHttpRequestOpen$LWS, distortionXMLHttpRequestResponseGetter$LWS, distortionXMLHttpRequestResponseXMLGetter$LWS];
const fundamentalKeyedDistortionFactories$LWS = [// Aura
distortionAuraUtilGlobalEval$LWS, // Attr
distortionAttrValueSetter$LWS, // CacheStorage
distortionCacheStorageDelete$LWS, distortionCacheStorageHas$LWS, distortionCacheStorageKeys$LWS, distortionCacheStorageMatch$LWS, distortionCacheStorageOpen$LWS, // CookieStore
distortionCookieStoreDelete$LWS, distortionCookieStoreGet$LWS, distortionCookieStoreGetAll$LWS, distortionCookieStoreOnChange$LWS, distortionCookieStoreSet$LWS, // Document
distortionDocumentCookieGetter$LWS, distortionDocumentCookieSetter$LWS, distortionDocumentReplaceChildren$LWS, // CustomElementRegistry
distortionCustomElementRegistryGet$LWS, // Element
distortionElementSetAttribute$LWS, distortionElementSetAttributeNS$LWS, distortionElementSetAttributeNode$LWS, distortionElementSetAttributeNodeNS$LWS, distortionElementToggleAttribute$LWS, // HTMLScriptElement,
distortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
distortionNamedNodeMapSetNamedItem$LWS, distortionNamedNodeMapSetNamedItemNS$LWS, // SVGScriptElement
distortionSVGScriptElementHrefAttribute$LWS, // Window
distortionWindowSetInterval$LWS, distortionWindowSetTimeout$LWS, // Storage
distortionLocalStorage$LWS, distortionSessionStorage$LWS];
const secondaryExternalDistortionFactories$LWS = [// Element
distortionElementAfter$LWS, distortionElementAppend$LWS, distortionElementBefore$LWS, distortionElementInsertAdjacentElement$LWS, distortionElementPrepend$LWS, distortionElementShadowRootGetter$LWS, // Node
// The distortionNodeAppendChild distortion is temporarily disabled until W-10409618 is resolved
// distortionNodeAppendChild,
distortionNodeInsertBefore$LWS];
const secondaryExternalKeyedDistortionFactories$LWS = [];
const secondaryInternalDistortionsFactories$LWS = [];
const secondaryInternalKeyedDistortionFactories$LWS = [];
const externalDistortionFactories$LWS = ArrayConcat$LWS(fundamentalDistortionFactories$LWS, secondaryExternalDistortionFactories$LWS);
const externalKeyedDistortionFactories$LWS = ArrayConcat$LWS(fundamentalKeyedDistortionFactories$LWS, secondaryExternalKeyedDistortionFactories$LWS);
ArrayConcat$LWS(fundamentalDistortionFactories$LWS, secondaryInternalDistortionsFactories$LWS);
ArrayConcat$LWS(fundamentalKeyedDistortionFactories$LWS, secondaryInternalKeyedDistortionFactories$LWS);
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument']; // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
const externalDistortionCache$LWS = new WeakMapCtor$LWS();

function makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS) {
  const {
    Document: Document$LWS,
    Element: Element$LWS,
    HTMLElement: HTMLElement$LWS,
    HTMLIFrameElement: HTMLIFrameElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XSLTProcessor: XSLTProcessor$LWS
  } = globalObject$LWS;
  const blockedPropertyDistortionFactories$LWS = [];
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(CustomElementRegistry.prototype, CustomElementRegistryBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Document$LWS.prototype, DocumentBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(Element$LWS.prototype, ElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS));
  ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS));

  if (typeof XSLTProcessor$LWS === 'function') {
    ReflectApply$LWS(ArrayProtoPush$LWS, blockedPropertyDistortionFactories$LWS, distortBlockedProperties$LWS(XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS));
  }

  distortBlockedAttributes$LWS(HTMLElement$LWS, HTMLElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLIFrameElement$LWS, HTMLIFrameElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(HTMLScriptElement$LWS, HTMLScriptElementBlockedAttributes$LWS);
  distortBlockedAttributes$LWS(SVGElement$LWS, SVGElementBlockedAttributes$LWS);
  return blockedPropertyDistortionFactories$LWS;
}

function instrumentDistortionForSandbox$LWS(sandboxKey$LWS, fn$LWS, instrumentation$LWS, verboseInstrumentation$LWS, factoryName$LWS) {
  const {
    error,
    startActivity: startActivity$LWS
  } = instrumentation$LWS;

  if (verboseInstrumentation$LWS) {
    const factoryNameNoMarker$LWS = StringReplace$LWS(factoryName$LWS, LOCKER_IDENTIFIER_MARKER$LWS, '');
    return function verboseInstrumentedDistortionWrapper$LWS(...args$LWS) {
      const activity$LWS = startActivity$LWS(factoryNameNoMarker$LWS, {
        sandboxKey: sandboxKey$LWS
      });

      try {
        return ReflectApply$LWS(fn$LWS, this, args$LWS);
      } catch (e$LWS) {
        error({
          sandboxKey: sandboxKey$LWS,
          error: e$LWS
        });
        throw e$LWS;
      } finally {
        activity$LWS.stop();
      }
    };
  }

  return function instrumentedDistortionWrapper$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS(fn$LWS, this, args$LWS);
    } catch (e$LWS) {
      error({
        sandboxKey: sandboxKey$LWS,
        error: e$LWS
      });
      throw e$LWS;
    }
  };
}

function addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS) {
  const {
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = config$LWS;
  const options$LWS = {
    evaluator: evaluator$LWS,
    key: key$LWS,
    instrumentation: instrumentation$LWS,
    sandboxType: sandboxType$LWS
  };
  const pair$LWS = factory$LWS(globalObject$LWS, options$LWS);

  if (pair$LWS) {
    const {
      0: rawValue$LWS,
      1: distortedValue$LWS
    } = pair$LWS;

    if (rawValue$LWS) {
      let maybeInstrumentedDistortedValue$LWS = distortedValue$LWS;

      if (typeof distortedValue$LWS === 'function') {
        maybeInstrumentedDistortedValue$LWS = instrumentDistortionForSandbox$LWS(key$LWS, distortedValue$LWS, instrumentation$LWS, !!verboseInstrumentation$LWS, factory$LWS.name || '<unknown>');
      }

      entries$LWS[entries$LWS.length] = [rawValue$LWS, maybeMaskDistortion$LWS(maybeInstrumentedDistortedValue$LWS, rawValue$LWS)];
    }
  }
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages


function createExternalDistortionEntries$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS) {
  const entries$LWS = [];
  const cached$LWS = WeakMapGet$LWS(externalDistortionCache$LWS, globalObject$LWS);

  if (cached$LWS) {
    ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, cached$LWS);
  } else {
    const blockedPropertyDistortions$LWS = makeBlockedPropertyDistortionFactories$LWS(globalObject$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = blockedPropertyDistortions$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = blockedPropertyDistortions$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    for (let i$LWS = 0, {
      length: length$LWS
    } = externalDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = externalDistortionFactories$LWS[i$LWS];
      addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
    }

    WeakMapSet$LWS(externalDistortionCache$LWS, globalObject$LWS, shallowCloneArray$LWS(entries$LWS));
  }

  for (let i$LWS = 0, {
    length: length$LWS
  } = externalKeyedDistortionFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = externalKeyedDistortionFactories$LWS[i$LWS];
    addDistortionEntry$LWS(globalObject$LWS, key$LWS, evaluator$LWS, config$LWS, entries$LWS, factory$LWS);
  }

  ReflectApply$LWS(ArrayProtoPush$LWS, entries$LWS, makeElementDistortionsForSandboxKey$LWS(key$LWS));
  return entries$LWS;
} // @TODO: [Issue #373] Abstract common code in sandbox and distortion packages
/*! version: 0.15.16 */

/*!
 * Copyright (C) 2021 salesforce.com, inc.
 */
/* eslint-disable class-methods-use-this, max-classes-per-file */

let ticketSequence$LWS = 0;

function getActivityId$LWS() {
  ticketSequence$LWS += 1;
  return DateNow$LWS() + ticketSequence$LWS;
} // Locker Instrumentation Activity class

/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class LockerActivity$LWS {
  constructor(activityName$LWS, startCallback$LWS, stopCallback$LWS, captureTimestamps$LWS = false) {
    this._activityStart = 0;
    this._activityStop = 0;
    this._captureTimestamps = captureTimestamps$LWS;
    this._startCallback = startCallback$LWS;
    this._started = false;
    this._stopCallback = stopCallback$LWS;
    this._stopped = false;
    this.activityId = `${activityName$LWS}-${getActivityId$LWS()}`;
    this.activityName = activityName$LWS;
  }
  /*
   * starts an activity
   */


  start(data$LWS) {
    if (!this._started) {
      this._started = true;

      if (this._captureTimestamps) {
        this._activityStart = getTimestamp$LWS();
      }

      if (typeof this._startCallback === 'function') {
        this._startCallback(this, data$LWS);
      }
    }
  }
  /*
   * stops the current activity
   */


  stop(data$LWS) {
    if (!this._stopped) {
      this._stopped = true;

      if (this._captureTimestamps) {
        this._activityStop = getTimestamp$LWS();
      }

      if (typeof this._stopCallback === 'function') {
        this._stopCallback(this, data$LWS);
      }
    }
  }
  /*
   * stop the current activity with error state.
   */


  error(data$LWS) {
    // @TODO:
    // Aura's metrics service ($A.metricsService) is the current
    // instrumentation service used by Locker. The metrics service does not
    // have an `error` API for perf activities. But O11y provides this
    // feature. When Locker is able to integrate O11y, the following line
    // should be calling O11y's error API instead of `stop()`.
    this.stop(data$LWS);
  }

  get duration() {
    return this._activityStop > this._activityStart ? this._activityStop - this._activityStart : 0;
  }

} // Creates a new no-op Instrumentation instance.


class DefaultInstrumentation$LWS {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startActivity(activityName$LWS, _data$LWS) {
    return new LockerActivity$LWS(activityName$LWS, undefined, undefined);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  log(_data$LWS) {} // eslint-disable-next-line @typescript-eslint/no-unused-vars


  error(_data$LWS) {}

} // Export the default instrumentation instance with no-op operations.


const defaultInstrumentation$LWS = new DefaultInstrumentation$LWS();
/*! version: 0.15.16 */

const K=new WeakMap;function createMembraneMarshall$LWS(e){const t=Array,r=ArrayBuffer,o=Error,n=Object,a=Proxy,l=Reflect,i=RegExp,s=Symbol,c=TypeError,u=WeakMap,{for:p,toStringTag:y}=s,f=/\w*$/,d=Symbol.for("@@lockerDebugMode"),h=p("@@lockerLiveValue"),S=p("@@lockerNearMembraneSerializedValue"),b=p("@@lockerNearMembrane"),g=p("@@lockerNearMembraneUndefinedValue"),LOCKER_UNMINIFIED_FLAG$LWS=`${()=>
/* $LWS */
1}`.includes("*");let $=LOCKER_UNMINIFIED_FLAG$LWS&&void 0;const W="function"==typeof BigInt,{assign:L,defineProperties:v,freeze:P,getOwnPropertyDescriptor:T,getOwnPropertyDescriptors:w,isFrozen:x,isSealed:O,prototype:m,seal:_}=n,{__defineGetter__:E,__defineSetter__:A,__lookupGetter__:B,__lookupSetter__:H,hasOwnProperty:C,propertyIsEnumerable:k,toString:j}=m,{apply:D,construct:M,defineProperty:F,deleteProperty:G,get:I,getOwnPropertyDescriptor:R,getPrototypeOf:N,has:V,isExtensible:U,ownKeys:z,preventExtensions:Z,set:X,setPrototypeOf:J}=l,{isArray:Y}=t,{includes:q,indexOf:Q,slice:ee}=t.prototype,{isView:te}=r,re=D(B,r.prototype,["byteLength"]),oe=W?BigInt.prototype.valueOf:void 0,{valueOf:ne}=Boolean.prototype,{toString:ae}=o.prototype,{bind:le}=Function.prototype,{stringify:ie}=JSON,{valueOf:se}=Number.prototype,{revocable:ce}=a,{prototype:ue}=i,{exec:pe,test:ye,toString:fe}=ue,de=D(B,ue,["flags"])||function(){const e=D(fe,this,[]);return D(pe,f,[e])[0]},he=D(B,ue,["source"]),{replace:Se,slice:be,valueOf:ge}=String.prototype,{valueOf:$e}=s.prototype,{get:We,set:Le}=u.prototype,ve=console,{info:Pe}=ve,Te=eval,we="undefined"!=typeof globalThis&&globalThis||"undefined"!=typeof self&&self||(F(m,"globalThis",{__proto__:null,configurable:!0,get(){return G(m,"globalThis"),this||self}}),globalThis);let xe=!1,Oe=!1;const me=new i(`${D(Se,"$LWS",[/[\\^$.*+?()[\]{}|]/g,"\\$&"])}(?=\\.|$)`);function alwaysFalse$LWS(){return !1}function identity$LWS(e){return e}const _e=LOCKER_UNMINIFIED_FLAG$LWS?()=>{if(xe)return;xe=!0;const e=(()=>{var e;o.prepareStackTrace=(e,t)=>t;const t=(new o).stack;return delete o.prepareStackTrace,Y(t)&&t.length>0?null==(e=t[0])?void 0:e.constructor:void 0})();if("function"!=typeof e)return;const{getEvalOrigin:t,getFunctionName:r,toString:n}=e.prototype;o.prepareStackTrace=function(e,o){return function(e,o){let a="";try{a=D(ae,e,[]);}catch(e){a="<error>";}let l=!1;for(let e=0,{length:i}=o;e<i;e+=1){const i=o[e],s=D(r,i,[]);let c=!1;if("string"==typeof s&&"eval"!==s&&D(ye,me,[s])&&(c=!0),!c){const e=D(t,i,[]);"string"==typeof e&&D(ye,me,[e])&&(c=!0);}if(c)l||(l=!0,a+="\n    at LWS");else {l=!1;try{a+=`\n    at ${D(n,i,[])}`;}catch(e){}}}return a}(e,o)};const{stackTraceLimit:a}=o;("number"!=typeof a||a<20)&&(o.stackTraceLimit=20);}:noop$LWS;function noop$LWS(){}const Ee=e?e=>D(oe,e,[]):noop$LWS,Ae=e?e=>D(ne,e,[]):noop$LWS,Be=e?e=>D(se,e,[]):noop$LWS,He=e?e=>{if(e!==ue){const t=D(he,e,[]);return ie({__proto__:null,flags:D(de,e,[]),source:t})}}:noop$LWS,Ce=e?e=>D(ge,e,[]):noop$LWS,ke=e?e=>D($e,e,[]):noop$LWS,je=e?e=>{switch(D(j,e,[])){case"[object Boolean]":return Ae(e);case"[object Number]":return Be(e);case"[object RegExp]":return He(e);case"[object String]":return Ce(e);case"[object Object]":try{return ke(e)}catch(e){}if(W)try{return Ee(e)}catch(e){}default:return}}:noop$LWS,De=e?e=>{try{return ke(e)}catch(e){}if(W)try{return Ee(e)}catch(e){}try{return Ae(e)}catch(e){}try{return Be(e)}catch(e){}try{return He(e)}catch(e){}try{return Ce(e)}catch(e){}}:noop$LWS;return function(r,o,i){const{distortionCallback:s=identity$LWS,instrumentation:p}=L({__proto__:null},i),f=!e&&"object"==typeof p&&null!==p,W={__proto__:null,0:void 0,1:void 0,2:void 0,3:void 0,4:void 0,n:void 0},oe={__proto__:null,0:void 0,1:void 0,2:void 0,3:void 0,4:void 0,n:void 0},ne=new u,ae=new u,ie=f?p.startActivity:void 0;let se,pe,ye,fe,de,Se,ge,$e,xe,me,Ee,Ae,Be,He,Ce,ke,Me,Fe,Ge,Ie,Re,Ne,Ke,Ve,Ue,ze,Ze,Xe=0,Je=!1;const Ye=e?(e,t,r)=>{r[t]=!1;const o=getTransferablePointer$LWS(e);let n;try{ge(o,t,(e,t,r,o,a,l,i)=>{n=createDescriptorFromMeta$LWS(t,r,o,a,l,i);});}catch(e){var a;const t=null!=(a=Ze)?a:e;throw Ze=void 0,t}n?F(e,t,n):delete e[t];}:noop$LWS;function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(e,t){let r,o,n;f&&(r=ie("callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors"));try{o=Ve(e,(...e)=>{const r={};for(let t=0,{length:o}=e;t<o;t+=7){r[e[t]]=createDescriptorFromMeta$LWS(e[t+1],e[t+2],e[t+3],e[t+4],e[t+5],e[t+6]);}v(t,r);});}catch(e){var a;const t=null!=(a=Ze)?a:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}"function"==typeof o?(o(),n=Ze,Ze=void 0):n=null,J(t,n);}function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(e){const t=1&e,r=t?"callableApplyWithZeroOrMoreArgs":"callableConstructWithZeroOrMoreArgs",o=t?W:oe,n=t?pe:ye;return function(a,l,i){Xe=e;const s=t?i:l,{length:c}=s;var u;if(0!==c)return D(null!=(u=o[c])?u:o.n,this,[a,l,i]);let p;f&&(p=ie(r));const{foreignTargetPointer:y}=this,d=t?l:i;try{const e=n(y,"object"==typeof d&&null!==d||"function"==typeof d?getTransferablePointer$LWS(d):"undefined"==typeof d?void 0:d);let t;return "function"==typeof e?(e(),t=Ze,Ze=void 0):t=e,t}catch(e){var h;const t=null!=(h=Ze)?h:e;throw Ze=void 0,f&&p.error(t),t}finally{f&&p.stop();}}}function createApplyOrConstructTrapForOneOrMoreArgs$LWS(e){const t=1&e,r=t?"callableApplyWithOneOrMoreArgs":"callableConstructWithOneOrMoreArgs",o=t?W:oe,n=t?pe:ye;return function(a,l,i){Xe=e;const s=t?i:l,{length:c}=s;var u;if(1!==c)return D(null!=(u=o[c])?u:o.n,this,[a,l,i]);let p;f&&(p=ie(r));const{foreignTargetPointer:y}=this,d=t?l:i;try{const{0:e}=s,t=n(y,"object"==typeof d&&null!==d||"function"==typeof d?getTransferablePointer$LWS(d):"undefined"==typeof d?void 0:d,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e);let r;return "function"==typeof t?(t(),r=Ze,Ze=void 0):r=t,r}catch(e){var h;const t=null!=(h=Ze)?h:e;throw Ze=void 0,f&&p.error(t),t}finally{f&&p.stop();}}}function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(e){const t=1&e,r=t?"callableApplyWithTwoOrMoreArgs":"callableConstructWithTwoOrMoreArgs",o=t?W:oe,n=t?pe:ye;return function(a,l,i){Xe=e;const s=t?i:l,{length:c}=s;var u;if(2!==c)return D(null!=(u=o[c])?u:o.n,this,[a,l,i]);let p;f&&(p=ie(r));const{foreignTargetPointer:y}=this,d=t?l:i;try{const{0:e,1:t}=s,r=n(y,"object"==typeof d&&null!==d||"function"==typeof d?getTransferablePointer$LWS(d):"undefined"==typeof d?void 0:d,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t);let o;return "function"==typeof r?(r(),o=Ze,Ze=void 0):o=r,o}catch(e){var h;const t=null!=(h=Ze)?h:e;throw Ze=void 0,f&&p.error(t),t}finally{f&&p.stop();}}}function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(e){const t=1&e,r=t?"callableApplyWithThreeOrMoreArgs":"callableConstructWithThreeOrMoreArgs",o=t?W:oe,n=t?pe:ye;return function(a,l,i){Xe=e;const s=t?i:l,{length:c}=s;var u;if(3!==c)return D(null!=(u=o[c])?u:o.n,this,[a,l,i]);let p;f&&(p=ie(r));const{foreignTargetPointer:y}=this,d=t?l:i;try{const{0:e,1:t,2:r}=s,o=n(y,"object"==typeof d&&null!==d||"function"==typeof d?getTransferablePointer$LWS(d):"undefined"==typeof d?void 0:d,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):"undefined"==typeof r?void 0:r);let a;return "function"==typeof o?(o(),a=Ze,Ze=void 0):a=o,a}catch(e){var h;const t=null!=(h=Ze)?h:e;throw Ze=void 0,f&&p.error(t),t}finally{f&&p.stop();}}}function createApplyOrConstructTrapForFourOrMoreArgs$LWS(e){const t=1&e,r=t?"callableApplyWithFourOrMoreArgs":"callableConstructWithFourOrMoreArgs",o=t?W:oe,n=t?pe:ye;return function(a,l,i){Xe=e;const s=t?i:l,{length:c}=s;var u;if(4!==c)return D(null!=(u=o[c])?u:o.n,this,[a,l,i]);let p;f&&(p=ie(r));const{foreignTargetPointer:y}=this,d=t?l:i;try{const{0:e,1:t,2:r,3:o}=s,a=n(y,"object"==typeof d&&null!==d||"function"==typeof d?getTransferablePointer$LWS(d):"undefined"==typeof d?void 0:d,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):"undefined"==typeof r?void 0:r,"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):"undefined"==typeof o?void 0:o);let l;return "function"==typeof a?(a(),l=Ze,Ze=void 0):l=a,l}catch(e){var h;const t=null!=(h=Ze)?h:e;throw Ze=void 0,f&&p.error(t),t}finally{f&&p.stop();}}}function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(e){const r=1&e,o=r?"callableApplyWithAnyNumberOfArgs":"callableConstructWithAnyNumberOfArgs",n=r?pe:ye;return function(a,l,i){let s;Xe=e,f&&(s=ie(o));const{foreignTargetPointer:c}=this,u=r?i:l,p=r?l:i,{length:y}=u;let d=2;const h=new t(y+d);h[0]=c;try{h[1]="object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p;for(let e=0;e<y;e+=1){const t=u[e];h[d++]="object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t;}const e=D(n,void 0,h);let t;return "function"==typeof e?(e(),t=Ze,Ze=void 0):t=e,t}catch(e){var S;const t=null!=(S=Ze)?S:e;throw Ze=void 0,f&&s.error(t),t}finally{f&&s.stop();}}}function createDescriptorFromMeta$LWS(e,t,r,o,n,a){const l={__proto__:null};if(e!==g&&(l.configurable=e),t!==g&&(l.enumerable=t),r!==g&&(l.writable=r),n!==g){let e;"function"==typeof n?(n(),e=Ze,Ze=void 0):e=n,l.get=e;}if(a!==g){let e;"function"==typeof a?(a(),e=Ze,Ze=void 0):e=a,l.set=e;}if(o!==g){let e;"function"==typeof o?(o(),e=Ze,Ze=void 0):e=o,l.value=e;}return l}function createPointer$LWS(e){return ()=>{Ze=e;}}const qe=e?e=>{let t=D(We,ne,[e]);if(void 0===t){const r=ke(getTransferablePointer$LWS(e));"function"==typeof r&&(r(),t=Ze,Ze=void 0,t&&D(Le,ne,[e,t]));}return t}:noop$LWS;function getTransferablePointer$LWS(t){let r=D(We,ae,[t]);if(r)return r;const o=e?t:s(t);if(o!==t&&typeof o!=typeof t)throw new c(`Invalid distortion ${t}.`);let n,a=8;try{Y(o)&&(a=1);}catch(e){a=16;}if("function"==typeof o){n=0,a=2;try{"prototype"in o||(a|=4);const e=R(t,"length");if(e){J(e,null);const{value:t}=e;"number"==typeof t&&(n=t);}void 0;}catch(e){}}return r=se(createPointer$LWS(o),a,n,undefined),D(Le,ae,[t,r]),r}const Qe=e?e=>{if(Oe)return;Oe=!0;const t=Y(e)&&e.length>0,r=t?{__proto__:null}:void 0,o=t?(t,r)=>D(q,e,[r])?{configurable:!1,enumerable:D(k,t,[r]),get:i(r),set:void 0}:R(t,r):void 0,i=t?e=>{let t=r[e];return void 0===t&&(t=D(le,u,[]),r[e]=t),t}:void 0,s=t?(t,r)=>D(q,e,[r])?i(r):D(B,t,[r]):void 0,c=t?(t,r)=>D(q,e,[r])?void 0:D(H,t,[r]):void 0,u=t?()=>we:void 0,wrapDefineAccessOrProperty$LWS=e=>{const{length:t}=e,r=2===t;return new a(e,{apply(o,n,a){if(a.length>=t){const e=r?n:a[0],t=r?a[0]:a[1],o=qe(e);null!=o&&o[t]&&I(e,t);}return D(e,n,a)}})},wrapLookupAccessor$LWS=(e,r)=>new a(e,{apply(o,n,a){if(a.length){const{0:e}=a,o=qe(n);if(null!=o&&o[e]&&I(n,e),t&&n===we)return r(n,e)}return D(e,n,a)}}),wrapGetOwnPropertyDescriptor$LWS=e=>new a(e,{apply(r,n,a){if(a.length>1){const{0:e,1:r}=a,n=qe(e);if(null!=n&&n[r]&&I(e,r),t&&e===we)return o(e,r)}return D(e,n,a)}});var p;l.defineProperty=wrapDefineAccessOrProperty$LWS(F),l.getOwnPropertyDescriptor=wrapGetOwnPropertyDescriptor$LWS(R),n.getOwnPropertyDescriptor=wrapGetOwnPropertyDescriptor$LWS(T),n.getOwnPropertyDescriptors=new a(p=w,{apply(e,r,n){if(!n.length)return D(p,r,n);const{0:a}=n,l=qe(a),i=a===we&&t,s=i?{}:D(p,r,n);if(!i&&void 0===l)return s;const c=z(i?a:s);for(let e=0,{length:t}=c;e<t;e+=1){const t=c[e],r=!(null==l||!l[t]);if(r&&I(a,t),r||i){const e=i?o(a,t):R(a,t);e?s[t]=e:i||delete s[t];}}return s}}),m.__defineGetter__=wrapDefineAccessOrProperty$LWS(E),m.__defineSetter__=wrapDefineAccessOrProperty$LWS(A),m.__lookupGetter__=wrapLookupAccessor$LWS(B,s),m.__lookupSetter__=wrapLookupAccessor$LWS(H,c);}:noop$LWS;function lockShadowTarget$LWS(e,t){copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(t,e),Z(e);}function lookupForeignDescriptor$LWS(e,t,r){let o,n,a,l;f&&(o=ie("callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor"));try{n=ze(e,r,(e,o,n,l,i,s,c)=>{a=createDescriptorFromMeta$LWS(o,n,l,i,s,c),!1===a.configurable&&F(t,r,a);});}catch(e){var i;const t=null!=(i=Ze)?i:e;throw Ze=void 0,f&&o.error(t),t}finally{f&&o.stop();}if(a)return a;for("function"==typeof n?(n(),l=Ze,Ze=void 0):l=n;l;){if(a=R(l,r),a)return J(a,null),a;l=N(l);}}function pushErrorAcrossBoundary$LWS(e){if("object"==typeof e&&null!==e||"function"==typeof e){getTransferablePointer$LWS(e)();}return e}const et=e?(e,t)=>{D(Le,ne,[e,t]),Ke(getTransferablePointer$LWS(e),getTransferablePointer$LWS(t));}:noop$LWS;class BoundaryProxyHandler$LWS{constructor(t,o,n,a){let l;this.color=r,this.foreignTargetTraits=0;const i=1&o,s=2&o;l=s?4&o?()=>{}:function(){}:i?[]:{};const{proxy:c,revoke:u}=ce(l,this);var p,y;(this.foreignTargetPointer=t,this.foreignTargetTraits=o,this.nonConfigurableDescriptorCallback=(e,t,r,o,n,a,l)=>{F(this.shadowTarget,e,createDescriptorFromMeta$LWS(t,r,o,n,a,l));},this.proxy=c,this.revoke=u,this.serializedValue=void 0,this.shadowTarget=l,this.staticToStringTag=void 0,s)&&(this.apply=null!=(p=W[n])?p:W.n,this.construct=null!=(y=oe[n])?y:oe.n);if(this.defineProperty=BoundaryProxyHandler$LWS.defaultDefinePropertyTrap,this.deleteProperty=BoundaryProxyHandler$LWS.defaultDeletePropertyTrap,this.isExtensible=BoundaryProxyHandler$LWS.defaultIsExtensibleTrap,this.getOwnPropertyDescriptor=BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap,this.getPrototypeOf=BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap,this.get=BoundaryProxyHandler$LWS.defaultGetTrap,this.has=BoundaryProxyHandler$LWS.defaultHasTrap,this.ownKeys=BoundaryProxyHandler$LWS.defaultOwnKeysTrap,this.preventExtensions=BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap,this.setPrototypeOf=BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap,this.set=BoundaryProxyHandler$LWS.defaultSetTrap,16&o&&u(),e)i&&this.makeProxyLive();else {if(8&o){let e=g;D(E,this,["serializedValue",()=>(e===g&&(e=Ne(this.foreignTargetPointer)),e)]);}P(this);}}makeProxyLive(){this.deleteProperty=BoundaryProxyHandler$LWS.passthruDeletePropertyTrap,this.defineProperty=BoundaryProxyHandler$LWS.passthruDefinePropertyTrap,this.preventExtensions=BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap,this.set=BoundaryProxyHandler$LWS.passthruSetTrap,this.setPrototypeOf=BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap,P(this);}makeProxyStatic(){this.defineProperty=BoundaryProxyHandler$LWS.staticDefinePropertyTrap,this.deleteProperty=BoundaryProxyHandler$LWS.staticDeletePropertyTrap,this.get=BoundaryProxyHandler$LWS.staticGetTrap,this.getOwnPropertyDescriptor=BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap,this.getPrototypeOf=BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap,this.has=BoundaryProxyHandler$LWS.staticHasTrap,this.isExtensible=BoundaryProxyHandler$LWS.staticIsExtensibleTrap,this.ownKeys=BoundaryProxyHandler$LWS.staticOwnKeysTrap,this.preventExtensions=BoundaryProxyHandler$LWS.staticPreventExtensionsTrap,this.set=BoundaryProxyHandler$LWS.staticSetTrap,this.setPrototypeOf=BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;const{foreignTargetPointer:e,shadowTarget:t}=this,r=Me(e);if(8&r)return P(this),this.revoke(),void 0;try{copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(e,t);}catch(t){if(Re(e))return P(this),this.revoke(),void 0}if(8&this.foreignTargetTraits&&!V(t,y)){let t="Object";try{t=Fe(e);}catch(e){}"Object"!==t&&(this.staticToStringTag=t);}4&r?P(t):2&r?_(t):1&r?Z(t):!1!==$&&($=Ce("Mutations on the membrane of an object originating outside of the sandbox will not be reflected on the object itself:",e)),P(this);}makeProxyUnambiguous(){Ie(this.foreignTargetPointer)?this.makeProxyLive():this.makeProxyStatic();}static passthruDefinePropertyTrap(e,t,r){let o;Xe=4,f&&(o=ie("callableDefineProperty"));const n=r;J(n,null);const{value:a,get:l,set:i}=n,s="value"in n?"object"==typeof a&&null!==a||"function"==typeof a?getTransferablePointer$LWS(a):"undefined"==typeof a?void 0:a:g,c="get"in n?"object"==typeof l&&null!==l||"function"==typeof l?getTransferablePointer$LWS(l):l:g,u="set"in n?"object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):i:g;try{return fe(this.foreignTargetPointer,t,"configurable"in n?!!n.configurable:g,"enumerable"in n?!!n.enumerable:g,"writable"in n?!!n.writable:g,s,c,u,this.nonConfigurableDescriptorCallback)}catch(e){var p;const t=null!=(p=Ze)?p:e;throw Ze=void 0,f&&o.error(t),t}finally{f&&o.stop();}}static passthruDeletePropertyTrap(e,t){let r;Xe=8,f&&(r=ie("callableDeleteProperty"));try{return de(this.foreignTargetPointer,t)}catch(e){var o;const t=null!=(o=Ze)?o:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}}static passthruGetTrap(e,t,r){if(Je&&(Je=128===Xe),Xe=16,Je){if(t===b)return !0;if(t===S)return this.serializedValue}let o;f&&(o=ie("callableGet"));const n="object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):r;try{const e=Se(this.foreignTargetPointer,this.foreignTargetTraits,t,n);let r;return "function"==typeof e?(e(),r=Ze,Ze=void 0):r=e,r}catch(e){var a;const t=null!=(a=Ze)?a:e;throw Ze=void 0,f&&o.error(t),t}finally{f&&o.stop();}}static passthruGetPrototypeOfTrap(e){let t,r,o;Xe=64,f&&(t=ie("callableGetPrototypeOf"));try{r=$e(this.foreignTargetPointer);}catch(e){var n;const r=null!=(n=Ze)?n:e;throw Ze=void 0,f&&t.error(r),r}finally{f&&t.stop();}return "function"==typeof r?(r(),o=Ze,Ze=void 0):o=null,o}static passthruHasTrap(e,t){let r,o;Xe=128,f&&(r=ie("callableHas"));try{o=xe(this.foreignTargetPointer,t);}catch(e){var n;const t=null!=(n=Ze)?n:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}return Je=!o&&(t===b||t===S),o}static passthruIsExtensibleTrap(e){Xe=256;const{shadowTarget:t}=this;if(U(t)){let e;f&&(e=ie("callableIsExtensible"));const{foreignTargetPointer:o}=this;try{if(me(o))return !0}catch(t){var r;const o=null!=(r=Ze)?r:t;throw Ze=void 0,f&&e.error(o),o}finally{f&&e.stop();}lockShadowTarget$LWS(t,o);}return !1}static passthruOwnKeysTrap(e){let t,r;Xe=512,f&&(t=ie("callableOwnKeys"));try{Ee(this.foreignTargetPointer,(...e)=>{r=e;});}catch(e){var o;const r=null!=(o=Ze)?o:e;throw Ze=void 0,f&&t.error(r),r}finally{f&&t.stop();}return r||[]}static passthruGetOwnPropertyDescriptorTrap(e,t){let r,o;Xe=32,f&&(r=ie("callableGetOwnPropertyDescriptor"));try{ge(this.foreignTargetPointer,t,(e,r,n,a,l,i,s)=>{o=createDescriptorFromMeta$LWS(r,n,a,l,i,s),!1===o.configurable&&F(this.shadowTarget,t,o);});}catch(e){var n;const t=null!=(n=Ze)?n:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}return o}static passthruPreventExtensionsTrap(e){Xe=1024;const{shadowTarget:t}=this;if(U(t)){let e;f&&(e=ie("callablePreventExtensions"));const{foreignTargetPointer:o}=this;let n;try{n=Ae(o);}catch(t){var r;const o=null!=(r=Ze)?r:t;throw Ze=void 0,f&&e.error(o),o}finally{f&&e.stop();}if(2&n)return 1&n||lockShadowTarget$LWS(t,o),!1;lockShadowTarget$LWS(t,o);}return !0}static passthruSetPrototypeOfTrap(e,t){let r;Xe=4096,f&&(r=ie("callableSetPrototypeOf"));const o=t?getTransferablePointer$LWS(t):t;try{return He(this.foreignTargetPointer,o)}catch(e){var n;const t=null!=(n=Ze)?n:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}}static passthruSetTrap(e,t,r,o){Xe=2048;const{foreignTargetPointer:n,proxy:a}=this;return "undefined"==typeof r&&(r=void 0),"undefined"==typeof o&&(o=a),a===o?function(e,t,r,o){let n;f&&(n=ie("callableSet"));const a="object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):r,l=getTransferablePointer$LWS(o);try{return Be(e,t,a,l)}catch(e){var i;const t=null!=(i=Ze)?i:e;throw Ze=void 0,f&&n.error(t),t}finally{f&&n.stop();}}(n,t,r,o):function(e,t,r,o,n){const a=lookupForeignDescriptor$LWS(e,t,r);if(a){if("get"in a||"set"in a){const{set:e}=a;return !!e&&(D(e,n,[o]),!0)}if(!1===a.writable)return !1}if(null===n||"function"!=typeof n&&"object"!=typeof n)return !1;const l=R(n,r);return l?(J(l,null),!("get"in l)&&!("set"in l)&&!1!==l.writable&&(F(n,r,{__proto__:null,value:o}),!0)):F(n,r,{__proto__:null,configurable:!0,enumerable:!0,value:o,writable:!0})}(n,this.shadowTarget,t,r,o)}}return BoundaryProxyHandler$LWS.hybridGetTrap=e?function(e,t,r){const{foreignTargetPointer:o,shadowTarget:n}=this,a=lookupForeignDescriptor$LWS(o,n,t);if(a){const{get:e,value:t}=a;return e?D(e,r,[]):t}if(t===y&&8&this.foreignTargetTraits){let e,t;f&&(e=ie("callableGetToStringTagOfTarget"));try{t=Fe(o);}catch(t){var l;const r=null!=(l=Ze)?l:t;throw Ze=void 0,f&&e.error(r),r}finally{f&&e.stop();}if("Object"!==t)return t}}:noop$LWS,BoundaryProxyHandler$LWS.hybridHasTrap=e?function(e,t){let r,o,n;f&&(r=ie("callableBatchGetPrototypeOfWhenHasNoOwnProperty"));try{o=Ue(this.foreignTargetPointer,t);}catch(e){var a;const t=null!=(a=Ze)?a:e;throw Ze=void 0,f&&r.error(t),t}finally{f&&r.stop();}if(!0===o)return !0;for("function"==typeof o?(o(),n=Ze,Ze=void 0):n=o;n;){if(D(C,n,[t]))return !0;n=N(n);}return !1}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.pendingDefinePropertyTrap=e?function(e,t,r){return this.makeProxyUnambiguous(),this.defineProperty(e,t,r)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.pendingDeletePropertyTrap=e?function(e,t){return this.makeProxyUnambiguous(),this.deleteProperty(e,t)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap=e?function(e){return this.makeProxyUnambiguous(),this.preventExtensions(e)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap=e?function(e,t){return this.makeProxyUnambiguous(),this.setPrototypeOf(e,t)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.pendingSetTrap=e?function(e,t,r,o){return this.makeProxyUnambiguous(),this.set(e,t,r,o)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticDefinePropertyTrap=e?F:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticDeletePropertyTrap=e?G:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap=e?R:noop$LWS,BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap=e?N:()=>null,BoundaryProxyHandler$LWS.staticGetTrap=e?function(e,t,r){const{shadowTarget:o}=this,n=I(o,t,r);return void 0===n&&t===y&&8&this.foreignTargetTraits&&!V(o,t)?this.staticToStringTag:n}:noop$LWS,BoundaryProxyHandler$LWS.staticHasTrap=e?V:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticIsExtensibleTrap=e?U:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticOwnKeysTrap=e?z:()=>[],BoundaryProxyHandler$LWS.staticPreventExtensionsTrap=e?Z:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap=e?J:alwaysFalse$LWS,BoundaryProxyHandler$LWS.staticSetTrap=e?X:alwaysFalse$LWS,BoundaryProxyHandler$LWS.defaultDefinePropertyTrap=e?BoundaryProxyHandler$LWS.pendingDefinePropertyTrap:BoundaryProxyHandler$LWS.passthruDefinePropertyTrap,BoundaryProxyHandler$LWS.defaultDeletePropertyTrap=e?BoundaryProxyHandler$LWS.pendingDeletePropertyTrap:BoundaryProxyHandler$LWS.passthruDeletePropertyTrap,BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap=BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap,BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap=BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap,BoundaryProxyHandler$LWS.defaultGetTrap=e?BoundaryProxyHandler$LWS.hybridGetTrap:BoundaryProxyHandler$LWS.passthruGetTrap,BoundaryProxyHandler$LWS.defaultHasTrap=e?BoundaryProxyHandler$LWS.hybridHasTrap:BoundaryProxyHandler$LWS.passthruHasTrap,BoundaryProxyHandler$LWS.defaultIsExtensibleTrap=BoundaryProxyHandler$LWS.passthruIsExtensibleTrap,BoundaryProxyHandler$LWS.defaultOwnKeysTrap=BoundaryProxyHandler$LWS.passthruOwnKeysTrap,BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap=e?BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap:BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap,BoundaryProxyHandler$LWS.defaultSetTrap=e?BoundaryProxyHandler$LWS.pendingSetTrap:BoundaryProxyHandler$LWS.passthruSetTrap,BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap=e?BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap:BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap,J(BoundaryProxyHandler$LWS.prototype,null),P(BoundaryProxyHandler$LWS.prototype),o(createPointer$LWS(we),e?noop$LWS:()=>{const e=Ze;return Ze=void 0,e},e=>"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,(e,t)=>{e();const r=Ze;Ze=void 0;const o=null==r?void 0:r[t];return createPointer$LWS("undefined"==typeof o?void 0:o)},e?e=>{try{const t=Te(e);return "object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):t}catch(e){throw pushErrorAcrossBoundary$LWS(e)}}:noop$LWS,(e,t)=>{e();const r=Ze;Ze=void 0,("object"==typeof r&&null!==r||"function"==typeof r)&&D(Le,ae,[r,t]);},(e,t,r,o)=>{const{proxy:n}=new BoundaryProxyHandler$LWS(e,t,r,o);return D(Le,ae,[n,e]),createPointer$LWS(n)},(e,t,...r)=>{e();const o=Ze;let n,a;Ze=void 0,"function"==typeof t&&(t(),n=Ze,Ze=void 0);for(let e=0,{length:t}=r;e<t;e+=1){const t=r[e];"function"==typeof t&&(t(),r[e]=Ze,Ze=void 0);}try{a=D(o,n,r);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "object"==typeof a&&null!==a||"function"==typeof a?getTransferablePointer$LWS(a):"undefined"==typeof a?void 0:a},(e,t,...r)=>{e();const o=Ze;let n,a;Ze=void 0,"function"==typeof t&&(t(),n=Ze,Ze=void 0);for(let e=0,{length:t}=r;e<t;e+=1){const t=r[e];"function"==typeof t&&(t(),r[e]=Ze,Ze=void 0);}try{a=M(o,r,n);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "object"==typeof a&&null!==a||"function"==typeof a?getTransferablePointer$LWS(a):"undefined"==typeof a?void 0:a},(e,t,r,o,n,a,l,i,s)=>{e();const c=Ze;Ze=void 0;let u=!1;try{u=F(c,t,createDescriptorFromMeta$LWS(r,o,n,a,l,i));}catch(e){throw pushErrorAcrossBoundary$LWS(e)}if(u&&!1===r){let e;try{e=R(c,t);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}if(e&&(J(e,null),!1===e.configurable)){const{value:r,get:o,set:n}=e;s(t,!1,"enumerable"in e?e.enumerable:g,"writable"in e?e.writable:g,"value"in e?"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):r:g,"get"in e?"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o:g,"set"in e?"object"==typeof n&&null!==n||"function"==typeof n?getTransferablePointer$LWS(n):n:g);}}return u},(e,t)=>{e();const r=Ze;Ze=void 0;try{return G(r,t)}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},(e,t,r,o)=>{e();const n=Ze;let a,l;Ze=void 0,"function"==typeof o?(o(),a=Ze,Ze=void 0):a=o;try{l=I(n,r,a);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}if("object"==typeof l&&null!==l||"function"==typeof l)return getTransferablePointer$LWS(l);if(void 0===l&&r===y&&8&t)try{if(!V(n,r)){const e=D(j,n,[]);"[object Object]"!==e&&(l=D(be,e,[8,-1]));}}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "undefined"==typeof l?void 0:l},(e,t,r)=>{e();const o=Ze;let n;Ze=void 0;try{n=R(o,t);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}if(n){J(n,null);const{value:e,get:o,set:a}=n;r(t,"configurable"in n?n.configurable:g,"enumerable"in n?n.enumerable:g,"writable"in n?n.writable:g,"value"in n?"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e:g,"get"in n?"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o:g,"set"in n?"object"==typeof a&&null!==a||"function"==typeof a?getTransferablePointer$LWS(a):a:g);}},e=>{e();const t=Ze;let r;Ze=void 0;try{r=N(t);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "undefined"==typeof r?null:r?getTransferablePointer$LWS(r):r},(e,t)=>{e();const r=Ze;Ze=void 0;try{return V(r,t)}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},e=>{e();const t=Ze;Ze=void 0;try{return U(t)}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},(e,t)=>{e();const r=Ze;let o;Ze=void 0;try{o=z(r);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}D(t,void 0,o);},e=>{e();const t=Ze;Ze=void 0;let r=2;try{Z(t)&&(r=4);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return 2&r&&U(t)&&(r|=1),r},(e,t,r,o)=>{e();const n=Ze;let a,l;Ze=void 0,"function"==typeof r?(r(),a=Ze,Ze=void 0):a=r,"function"==typeof o?(o(),l=Ze,Ze=void 0):l=o;try{return X(n,t,a,l)}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},(e,t)=>{e();const r=Ze;let o;Ze=void 0,"function"==typeof t?(t(),o=Ze,Ze=void 0):o=null;try{return J(r,o)}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},LOCKER_UNMINIFIED_FLAG$LWS&&!e?(...e)=>{if(void 0===$&&($=D(C,we,[d]),$))try{_e(),Ge();}catch(e){}if($){for(let t=0,{length:r}=e;t<r;t+=1){const r=e[t];"function"==typeof r&&(r(),e[t]=Ze,Ze=void 0);}try{D(Pe,ve,e);}catch(e){}return !0}return !1}:()=>!1,e?(e,...t)=>{e();const r=Ze;Ze=void 0;for(let e=0,{length:o}=t;e<o;e+=7)F(r,t[e],createDescriptorFromMeta$LWS(t[e+1],t[e+2],t[e+3],t[e+4],t[e+5],t[e+6]));}:noop$LWS,e?noop$LWS:e=>{e();const t=Ze;let r;Ze=void 0;try{r=D(We,K,[t]);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return r?getTransferablePointer$LWS(r):r},e?()=>0:e=>{e();const t=Ze;Ze=void 0;try{if(!U(t))return x(t)||O(t)?0:1}catch(e){try{Y(t);}catch(e){return 8}}return 0},e=>{e();const t=Ze;Ze=void 0;try{const e=D(j,t,[]);return "[object Object]"===e?"Object":D(be,e,[8,-1])}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},_e,e?(e,...t)=>{const r=D(Q,t,[g]);let o,n;-1===r?o=t:(o=D(ee,t,[0,r]),n=D(ee,t,[r+1])),e();const a=Ze;Ze=void 0;let l=qe(a);void 0===l&&(l={__proto__:null},et(a,l));for(let e=0,{length:t}=o;e<t;e+=1){const t=o[e];l[t]=!0,F(a,t,{__proto__:null,configurable:!0,get:()=>(Ye(a,t,l),I(a,t)),set(e){Ye(a,t,l),X(a,t,e);}});}Qe(n);}:noop$LWS,e?alwaysFalse$LWS:e=>{e();const t=Ze;if(Ze=void 0,t===m)return !1;try{if("object"==typeof t){const{constructor:e}=t;if(e===n)return !0;if(null===N(t)&&("function"!=typeof e||e.prototype!==t))return !0;if(te(t))return !0;try{return D(re,t,[]),!0}catch(e){}try{if(t!==ue)return D(he,t,[]),!0}catch(e){}}return D(C,t,[h])}catch(e){}return !1},e?alwaysFalse$LWS:e=>{e();const t=Ze;Ze=void 0;try{return Y(t),!1}catch(e){}return !0},e?e=>{e();const t=Ze;Ze=void 0;try{return V(t,y)?De(t):je(t)}catch(e){}}:noop$LWS,e?noop$LWS:(e,t)=>{e();const r=Ze;Ze=void 0,t();const o=Ze;Ze=void 0;try{D(Le,K,[r,o]);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}},(e,r)=>{e();const o=Ze;let n;Ze=void 0;try{n=w(o);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}const a=z(n),{length:l}=a,i=new t(7*l);for(let e=0,t=0;e<l;e+=1,t+=7){const r=a[e],o=n[r];J(o,null);const{value:l,get:s,set:c}=o;i[t]=r,i[t+1]="configurable"in o?o.configurable:g,i[t+2]="enumerable"in o?o.enumerable:g,i[t+3]="writable"in o?o.writable:g,i[t+4]="value"in o?"object"==typeof l&&null!==l||"function"==typeof l?getTransferablePointer$LWS(l):l:g,i[t+5]="get"in o?"object"==typeof s&&null!==s||"function"==typeof s?getTransferablePointer$LWS(s):s:g,i[t+6]="set"in o?"object"==typeof c&&null!==c||"function"==typeof c?getTransferablePointer$LWS(c):c:g;}let s;D(r,void 0,i);try{s=N(o);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "undefined"==typeof s?null:s?getTransferablePointer$LWS(s):s},(e,t)=>{e();const r=Ze;let o;Ze=void 0;try{if(D(C,r,[t]))return !0;o=N(r);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "undefined"==typeof o?null:o?getTransferablePointer$LWS(o):o},(e,t,r)=>{e();const o=Ze;let n,a;Ze=void 0;try{n=R(o,t);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}if(n){J(n,null);const{value:e,get:o,set:a}=n;return r(t,"configurable"in n?n.configurable:g,"enumerable"in n?n.enumerable:g,"writable"in n?n.writable:g,"value"in n?"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e:g,"get"in n?"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o:g,"set"in n?"object"==typeof a&&null!==a||"function"==typeof a?getTransferablePointer$LWS(a):a:g),void 0}try{a=N(o);}catch(e){throw pushErrorAcrossBoundary$LWS(e)}return "undefined"==typeof a?null:a?getTransferablePointer$LWS(a):a}),(...e)=>{const{6:t,7:r,8:o,9:n,10:a,11:l,12:i,13:s,14:c,15:u,16:p,17:y,18:f,19:d,20:h,22:S,23:b,24:g,25:$,27:L,28:v,29:P,30:T,31:w,32:x,33:O}=e;se=t,pe=r,ye=o,fe=n,de=a,Se=l,ge=i,$e=s,xe=c,me=u,Ee=p,Ae=y,Be=f,He=d,Ce=h,ke=S,Me=b,Fe=g,Ge=$,Ie=L,Re=v,Ne=P,Ke=T,Ve=w,Ue=x,ze=O,W[0]=createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1),W[1]=createApplyOrConstructTrapForOneOrMoreArgs$LWS(1),W[2]=createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1),W[3]=createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1),W[4]=createApplyOrConstructTrapForFourOrMoreArgs$LWS(1),W.n=createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1),oe[0]=createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2),oe[1]=createApplyOrConstructTrapForOneOrMoreArgs$LWS(2),oe[2]=createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2),oe[3]=createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2),oe[4]=createApplyOrConstructTrapForFourOrMoreArgs$LWS(2),oe.n=createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2);}}}const V=TypeError,U=WeakMap,{apply:z}=Reflect,{get:Z,set:X}=U.prototype,J=`\n'use strict';\n(${createMembraneMarshall$LWS.toString()})`,Y=new U;function createConnector$LWS(e){if("function"!=typeof e)throw new V("Missing evaluator function.");let t=z(Z,Y,[e]);return void 0===t&&(t=e(J)(!0),z(X,Y,[e,t])),t}const q=Symbol.for("@@lockerNearMembraneUndefinedValue"),Q=Array,ee=Error,te=Object,{push:re}=Q.prototype,{assign:oe}=te,{apply:ne,ownKeys:ae}=Reflect;class VirtualEnvironment$LWS{constructor(e){if(void 0===e)throw new ee("Missing VirtualEnvironmentOptions options bag.");const{blueConnector:t,redConnector:r,distortionCallback:o,instrumentation:n}=oe({__proto__:null},e);let a;const l=t("blue",(...e)=>{a=e;},{distortionCallback:o,instrumentation:n}),{0:i,1:s,2:c,3:u,4:p,5:y,6:f,7:d,8:h,9:S,10:b,11:g,12:$,13:W,14:L,15:v,16:P,17:T,18:w,19:x,20:O,21:m,22:_,23:E,24:A,25:B,26:H,27:C,28:k,29:j,30:D,31:M,32:F,33:G}=a;let I;const R=r("red",(...e)=>{I=e;}),{0:N,1:K,2:V,3:U,4:z,5:Z,6:X,7:J,8:Y,9:q,10:Q,11:te,12:re,13:ne,14:ae,15:le,16:ie,17:se,18:ce,19:ue,20:pe,21:ye,22:fe,23:de,24:he,25:Se,26:be,27:ge,28:$e,29:We,30:Le,31:ve,32:Pe,33:Te}=I;l(N,K,V,U,z,Z,X,J,Y,q,Q,te,re,ne,ae,le,ie,se,ce,ue,pe,ye,fe,de,he,Se,be,ge,$e,We,Le,ve,Pe,Te),R(i,s,c,u,p,y,f,d,h,S,b,g,$,W,L,v,P,T,w,x,O,m,_,E,A,B,H,C,k,j,D,M,F,G),this.blueGlobalThisPointer=i,this.blueGetSelectedTarget=s,this.blueGetTransferableValue=c,this.blueCallableGetPropertyValuePointer=u,this.blueCallableLinkPointers=y,this.redGlobalThisPointer=N,this.redCallableGetPropertyValuePointer=U,this.redCallableEvaluate=z,this.redCallableLinkPointers=Z,this.redCallableSetPrototypeOf=ue,this.redCallableDefineProperties=ye,this.redCallableInstallLazyPropertyDescriptors=be;}evaluate(e){try{const t=this.redCallableEvaluate(e);return "function"==typeof t?(t(),this.blueGetSelectedTarget()):t}catch(e){var t;throw null!=(t=this.blueGetSelectedTarget())?t:e}}lazyRemapProperties(e,t,r){const o=[this.blueGetTransferableValue(e)];ne(re,o,t),null!=r&&r.length&&(o[o.length]=q,ne(re,o,r)),ne(this.redCallableInstallLazyPropertyDescriptors,void 0,o);}link(...e){let t=this.blueGlobalThisPointer,r=this.redGlobalThisPointer;for(let o=0,{length:n}=e;o<n;o+=1){const n=e[o];t=this.blueCallableGetPropertyValuePointer(t,n),r=this.redCallableGetPropertyValuePointer(r,n),this.redCallableLinkPointers(r,t),this.blueCallableLinkPointers(t,r);}}remapProperties(e,t){const r=this.blueGetTransferableValue(e),o=ae(t),{length:n}=o,a=new Q(1+7*n);a[0]=r;for(let e=0,r=1;e<n;e+=1,r+=7){const n=o[e],l=t[n],i=oe({__proto__:null},l);a[r]=n,a[r+1]="configurable"in i?!!i.configurable:q,a[r+2]="enumerable"in i?!!i.enumerable:q,a[r+3]="writable"in i?!!i.writable:q,a[r+4]="value"in i?this.blueGetTransferableValue(i.value):q,a[r+5]="get"in i?this.blueGetTransferableValue(i.get):q,a[r+6]="set"in i?this.blueGetTransferableValue(i.set):q;}ne(this.redCallableDefineProperties,this,a);}remapProto(e,t){const r=this.blueGetTransferableValue(e),o=t?this.blueGetTransferableValue(t):t;this.redCallableSetPrototypeOf(r,o);}}const{includes:le}=Array.prototype,{assign:ie}=Object,{apply:se,ownKeys:ce}=Reflect,ue=["AggregateError","Array","Error","EvalError","Function","Object","Proxy","RangeError","ReferenceError","SyntaxError","TypeError","URIError","eval","globalThis"],pe=["globalThis","Infinity","NaN","undefined","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","BigInt","Boolean","FinalizationRegistry","Number","RegExp","String","Symbol","WeakRef","JSON","Math","Reflect","escape","unescape",...ue];function getFilteredGlobalOwnKeys$LWS(e){const t=[];let r=0;const o=ce(e);for(let e=0,{length:n}=o;e<n;e+=1){const n=o[e];se(le,pe,[n])||(t[r++]=n);}return t}const ye=WeakMap,{apply:fe,getPrototypeOf:de,ownKeys:he}=Reflect,{get:Se,set:be}=ye.prototype,ge=new ye,$e=(()=>{const{navigator:{userAgent:e,userAgentData:t}}=window,r=null==t?void 0:t.brands;if(Array.isArray(r)&&r.length?r.find(e=>"Chromium"===(null==e?void 0:e.brand)):/ (?:Headless)?Chrome\/\d+/.test(e))return ["window"]})();function getCachedGlobalObjectReferences$LWS(e){let t=fe(Se,ge,[e]);if(t)return t;const{document:r,window:o}=e,n=de(o),a=de(n),l=de(a);return t={document:r,DocumentProto:de(r),window:o,WindowProto:n,WindowPropertiesProto:a,EventTargetProto:l,EventTargetProtoOwnKeys:he(l)},fe(be,ge,[e,t]),t}function filterWindowKeys$LWS(e){const t=[];let r=0;for(let o=0,{length:n}=e;o<n;o+=1){const n=e[o];"document"!==n&&"location "!==n&&"top"!==n&&"window"!==n&&"chrome"!==n&&(t[r++]=n);}return t}getCachedGlobalObjectReferences$LWS(window);const We=Object,Le=TypeError,{prototype:ve}=Document,{prototype:Pe}=Node,{remove:Te,setAttribute:we}=Element.prototype,{appendChild:xe}=Pe,{assign:Oe}=We,{__lookupGetter__:me}=We.prototype,{apply:_e}=Reflect,{close:Ee,createElement:Ae,open:Be}=ve,He=_e(me,ve,["body"]),Ce=_e(me,HTMLElement.prototype,["style"]),ke=_e(me,HTMLIFrameElement.prototype,["contentWindow"]),je=_e(me,Pe,["lastChild"]),De=document,Me=createMembraneMarshall$LWS();let Fe=null;function createIframeVirtualEnvironment$LWS(e,t,r){if("object"!=typeof e)throw new Le("Missing global object shape.");if("object"!=typeof t||null===t)throw new Le("Missing global object virtualization target.");const{distortionCallback:o,endowments:n,instrumentation:a,keepAlive:l=!1}=Oe({__proto__:null},r),i=function(){const e=_e(Ae,De,["iframe"]),t=_e(He,De,[])||_e(je,De,[]);return _e(Ce,e,[]).display="none",_e(we,e,["sandbox","allow-same-origin allow-scripts"]),_e(xe,t,[e]),e}(),s=_e(ke,i,[]),c=null===e;c&&null===Fe&&(Fe=filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(s)));const u=getCachedGlobalObjectReferences$LWS(t),p=new VirtualEnvironment$LWS({blueConnector:Me,distortionCallback:o,redConnector:createConnector$LWS(s.eval),instrumentation:a});if(!function(e,t){for(let r=0,{length:o}=ue;r<o;r+=1){const o=ue[r],n=t[o];n&&(n.prototype?e.link(o,"prototype"):e.link(o));}}(p,t),"undefined"==typeof globalThis?p.link("window","document"):p.link("document"),p.link("__proto__","__proto__","__proto__"),p.remapProto(u.document,u.DocumentProto),p.lazyRemapProperties(u.window,c?Fe:filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(e)),l?void 0:$e),n){const e={};!function(e,t){const r=ce(t);for(let o=0,{length:n}=r;o<n;o+=1){const n=r[o];if(!se(le,pe,[n])){const r=t[n];r&&(e[n]=ie({__proto__:null},r));}}return e}(e,n),delete(y=e).document,delete y.location,delete y.top,delete y.window,delete y.chrome,p.remapProperties(u.window,e);}var y;if(p.lazyRemapProperties(u.EventTargetProto,u.EventTargetProtoOwnKeys),l){const{document:e}=s;_e(Be,e,[]),_e(Ee,e,[]);}else _e(Te,i,[]);return p}const Ge={[SANDBOX_EVAL_CONTEXT_NAME$LWS]:{__proto__:null,get:()=>clearEvalContext$LWS()},[SANDBOX_EVAL_HELPERS_NAME$LWS]:{__proto__:null,get:()=>clearEvalHelpers$LWS()}},Ie=new RegExp(`\\breturn\\s*\\[\\s*(["'])${LOCKER_IDENTIFIER_MARKER$LWS}\\1\\s*,\\s*([^,\\s]+)\\s*,\\s*(["'])=\\3\\s*,\\s*([^\\]\\s]+)\\s*\\]`,"g"),Re=new WeakMapCtor$LWS,Ne={__proto__:null};let Ke,Ve;function clearEvalContext$LWS(){const e=Ke;return Ke=void 0,e}function clearEvalHelpers$LWS(){const e=Ve;return Ve=void 0,e}function createSandbox$LWS(l,i,s,c){const u=new WeakMapCtor$LWS(i(window)),p=createIframeVirtualEnvironment$LWS(null,window,{distortionCallback(e){const o=WeakMapGet$LWS(u,e);if(o)return o;if(isWindowLike$LWS(e)&&isWindow$LWS(e)){const t=i(e);for(let e=0,{length:o}=t;e<o;e+=1){const{0:o,1:n}=t[e];WeakMapSet$LWS(u,o,n);}WeakMapSet$LWS(u,e,e);}return e},endowments:ObjectAssign$LWS({},Ge,s?ObjectGetOwnPropertyDescriptors$LWS(s):void 0),keepAlive:!1,instrumentation:c}),y={};setEvalContext$LWS(e=>{ObjectAssign$LWS(y,e({elementToLoadingPromiseMap:Re}));});const f={distortionFactory:i,distortions:u,env:p,helpers:y};return p.evaluate(`'use strict';\n        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function(e){const{elementToLoadingPromiseMap:t}=e,r=Promise,o=TypeError,{asyncIterator:n,iterator:a}=Symbol,{[a]:l}=Array.prototype,i=function*(){}.constructor.prototype.prototype,{next:s,throw:c}=i,{delete:u,get:p,set:y}=Map.prototype,{appendChild:f}=Node.prototype,{freeze:d}=Object,{then:h}=r.prototype,S=r.resolve.bind(r),{apply:b,getPrototypeOf:g,setPrototypeOf:$}=Reflect,{get:W,set:L}=WeakMap.prototype,{createElement:v}=Document.prototype,{querySelector:P,setAttribute:T}=Element.prototype,{stopPropagation:w}=Event.prototype,{addEventListener:x}=EventTarget.prototype,O=document,{head:m}=O,_=new Map,E="data-locker-id",A=`${crypto.getRandomValues(new Uint32Array(1))[0]}`;function genStep$LWS(e,t,r,o,n,a,l){let i,s;try{i=b(a,e,[l]),s=i.value;}catch(e){return r(e),void 0}i.done?t(s):S(s).then(o,n);}function loadPromise$LWS(e,o){const n=new r((t,r)=>{b(x,e,["load",()=>{t(void 0);}]),b(x,e,["error",e=>{b(w,e,[]),r(`[Locker] resource loader error loading "${o}"`);}]);});return b(L,t,[e,n]),b(f,m,[e]),n}return {asyncToGen:function(e,t,o){return new r((r,n)=>{const a=b(e,t,o);function next$LWS(e){genStep$LWS(a,r,n,next$LWS,thrower$LWS,s,e);}function thrower$LWS(e){genStep$LWS(a,r,n,next$LWS,thrower$LWS,c,e);}next$LWS(void 0);})},forAwaitOf:function(e,t,l){if(0===t){let t=!1,{[n]:r}=l;if(null==r&&(t=!0,({[a]:r}=l)),"function"!=typeof r)throw new o("Object is not iterable.");return b(y,_,[e,{iterable:b(r,l,[]),step:void 0,sync:t}]),void 0}const i=b(p,_,[e]);if(1===t){const e=i.iterable.next();return i.sync?new r(t=>{i.step=e,t();}):b(h,e,[e=>{i.step=e;}])}if(2===t)return i.step.value;if(3===t){const t=!!i.step.done;return t&&b(u,_,[e]),t}},loadScript:function(e,r){let o=b(P,m,[`script[data-distorted-src='${r}'][data-locker-id='${A}']`]);var n;return o?null!=(n=b(W,t,[o]))?n:S():(o=b(v,O,["script"]),b(T,o,[E,A]),o.type="text/javascript",o.src=r,loadPromise$LWS(o,r))},loadStyle:function(e,r){let o=b(P,m,[`link[href='${r}']`]);var n;return o?null!=(n=b(W,t,[o]))?n:S():(o=b(v,O,["link"]),o.type="text/css",o.rel="stylesheet",o.href=r,loadPromise$LWS(o,r))},namespace:function(e){return d(e)},spreadable:function(e){return $(e,null),e[a]=l,e},super:function(e,t,r,o){const n=g(e.prototype)[t];return b(n,r,o)}}}})`),Ne[l]=f,f}function getSandbox$LWS(e){return Ne[e]}function setEvalContext$LWS(e){Ke=e;}function setEvalHelpers$LWS(e){Ve=e;}function toSource$LWS(e){let t=toString$LWS(e);return "function"==typeof e&&(t=StringMatch$LWS(t,/^[\s\S]+?\{(?:[\t ]*\r?\n)?([\s\S]*?)(?:\r?\n[\t ]*)?\}$/)[1]),t=StringReplace$LWS(t,/\/\/# sandbox(?=MappingURL=.*?\s*$)/,"//# source"),t=StringReplace$LWS(t,Ie,(e,t,r,o,n)=>`${r}=${n}`),`'use strict';${t}`}function evaluateInSandbox$LWS(e,t,r,o,n=defaultInstrumentation$LWS,a=!1){const l={sandboxKey:e},i="object"==typeof n&&null!==n&&n.startActivity,s=i("EvaluateInSandboxDuration",l);let c,u=getSandbox$LWS(e);if(void 0===u){isObjectLike$LWS(o)||(o=void 0);const t={__proto__:null,instrumentation:n,sandboxType:SandboxType$LWS.External,verboseInstrumentation:a},distortionFactory$LWS=r=>{const o=i("createExternalDistortionEntries",l),n=createExternalDistortionEntries$LWS(r,e,evaluateInSandbox$LWS,t);return o.stop(),n},r=i("createSandbox",l);u=createSandbox$LWS(e,distortionFactory$LWS,o,a?n:void 0),r.stop();}setEvalContext$LWS(r),setEvalHelpers$LWS(u.helpers);const y=toSource$LWS(t),f=i("externalEvaluatorDuration",l);try{c=u.env.evaluate(y);}catch(t){throw f.error({sandboxKey:e,error:t}),t}finally{clearEvalContext$LWS(),clearEvalHelpers$LWS(),f.stop();}return s.stop(),c}const ze=SymbolFor$LWS("@@lockerDebugMode");if(LOCKER_UNMINIFIED_FLAG$LWS){let e=!0;const t=100,r=5,o=100,n=o/2,a=/^[0-9]$|^[1-9][0-9]+$/,l="display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;",i={style:"margin-left:11px; margin-bottom: 3px;"},s={style:"display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;"},c={style:"color: #9d288c; font-weight: bold"},u={style:"color: #b17ab0"},p={style:"color: #16239f"},y={style:"color: #236d25"},M={style:"color: #606367"},F={style:"color: #b82619"},formatValue$LWS=function(e){if(null==e)return ["span",M,`${e}`];if("boolean"==typeof e)return ["span",p,e];if("number"==typeof e)return NumberIsFinite$LWS(e)?["span",p,e]:["span",p,(e>=0?"":"-")+"Infinity"];if("string"==typeof e){let t=e;const{length:r}=t;if(r>o){t=`${StringSlice$LWS(t,0,n)}${StringSlice$LWS(t,r-n-1,r)}`;}return ["span",F,JSONStringify$LWS(t)]}return ArrayIsArray$LWS(e)?["span",{},`Array(${e.length})`]:isObject$LWS(e)?["span",{},"{}"]:["span",F,StringCtor$LWS(e)]},formatHeader$LWS=function(e,o={}){const n=[],{isChildElement:l}=o;let i=0;l&&(n[i++]=["span",c,o.childKey],n[i++]=["span",{},": "]);const s=ObjectToString$LWS(e);let u=ObjectKeys$LWS(e);if(s===TO_STRING_BRAND_SYMBOL$LWS)ArrayIncludes$LWS(u,"description")||ArrayUnshift$LWS(u,"description");else if(s===TO_STRING_BRAND_STRING$LWS){const{length:t}=e;u=ArrayFilter$LWS(u,e=>!RegExpTest$LWS(a,e)||+e>=t);}const{length:d}=u;if(ArrayIsArray$LWS(e)){n[i++]=["span",l?M:{},`(${e.length}) [`];for(let r=0,o=MathMin$LWS(d,t);r<o;r+=1){const t=e[u[r]];n[i++]=["span",{},r?", ":""],n[i++]=formatValue$LWS(t);}return d>t&&(n[i++]=["span",null,["span",{},", "]]),n[i++]=["span",{},"]"],n}let h,S="{";switch(s){case TO_STRING_BRAND_BIG_INT$LWS:case TO_STRING_BRAND_BOOLEAN$LWS:case TO_STRING_BRAND_NUMBER$LWS:case TO_STRING_BRAND_STRING$LWS:case TO_STRING_BRAND_SYMBOL$LWS:{let t=p;s===TO_STRING_BRAND_BIG_INT$LWS?t=y:s===TO_STRING_BRAND_SYMBOL$LWS&&(t=F),S=`${StringSlice$LWS(s,8,-1)} {`,h=["span",t,`${StringCtor$LWS(getNearMembraneSerializedValue$LWS(e))}`];break}}n[i++]=["span",{},S],h&&(n[i++]=h,d&&(n[i++]=["span",{},", "]));for(let t=0,o=MathMin$LWS(d,r);t<o;t+=1){const r=u[t],o=e[r];n[i++]=["span",{},t?", ":""],n[i++]=["span",M,r],n[i++]=["span",{},": "],n[i++]=formatValue$LWS(o);}return d>r&&(n[i++]=["span",null,["span",{},", "]]),n[i++]=["span",{},"}"],n},formatBody$LWS=function(e){const t=ObjectKeys$LWS(e),r=ReflectOwnKeys$LWS(e);ArrayIsArray$LWS(e)||ArraySort$LWS(r);const o=[];let n=0;for(let a=0,{length:l}=r;a<l;a+=1){const l=r[a],s=e[l];if(isObject$LWS(s))o[n++]=["div",{},["object",{object:s,config:{childKey:StringCtor$LWS(l),isChildElement:!0}}]];else {let e=c;"symbol"!=typeof l&&ArrayIncludes$LWS(t,l)||(e=u),o[n++]=["div",i,["span",e,StringCtor$LWS(l)],["span",{},": "],formatValue$LWS(s)];}}return o};let{devtoolsFormatters:G}=window;ArrayIsArray$LWS(G)||(G=[],ReflectDefineProperty$LWS(window,"devtoolsFormatters",{__proto__:null,configurable:!0,value:G,writable:!0})),G[G.length]={header(t,r={}){if(e&&(e=!1,ReflectDefineProperty$LWS(window,ze,{__proto__:null,configurable:!0,value:!0,writable:!0})),!isNearMembrane$LWS(t))return null;const o=["div",{style:`${l}${r.isChildElement?"":"font-style: italic;"}`}];return ReflectApply$LWS(ArrayProtoPush$LWS,o,formatHeader$LWS(t,r)),["div",{},o]},hasBody:()=>!0,body(e){const t=["div",s];return ReflectApply$LWS(ArrayProtoPush$LWS,t,formatBody$LWS(e)),t}};}

const loaderDefine = globalThis.LWR.define;
/**
 * Mark an exports object as "live", see https://github.com/caridy/secure-javascript-environment/pull/87.
 *
 * @returns the marked object
 */
function markLiveObject(object) {
    Reflect.defineProperty(object, Symbol.for('@@lockerLiveValue'), {});
    return object;
}
/**
 * Evaluate the given exporter in a sandbox of the given namespace
 */
function vNextEvaluateModule(namespace, specifier, exporter) {
    let out;
    // first, stringify the exporter, wrapping it with Locker context
    // note: sourceMap does not work for now
    const src = `"use strict";$lockerEvalContext$(${exporter.toString()});\n//# sourceURL=modules/${specifier}.js\n`;
    evaluateInSandbox$LWS(namespace, src, (def) => {
        out = def;
    });
    return out;
}
/**
 * Return a "secure" version of the given exporter, either
 * the given exporter as is if the module is from a trusted
 * namespace/component, or a "lockerized" version of the exporter if not.
 */
function secureExporter(specifier, dependencies, exporter, trustedNamespaces) {
    const [namespace, name] = specifier.split('/');
    // return the exporter as is if it's from a trusted component or namespace
    if (trustedNamespaces.includes(namespace) ||
        trustedNamespaces.includes(`${namespace}/*`) ||
        trustedNamespaces.includes(`${namespace}/${name}`)) {
        return exporter;
    }
    // not a trusted namespace/component, let's lockerize the exporter
    const out = vNextEvaluateModule(namespace, specifier, exporter);
    // mark the exports object as "live" if needed
    const exportsIndex = dependencies.indexOf('exports');
    if (exportsIndex >= 0) {
        return function (...args) {
            const modifiedArgs = args.map((arg, index) => {
                return (index === exportsIndex && markLiveObject(arg)) || arg;
            });
            return out.apply(this, modifiedArgs);
        };
    }
    return out;
}
function registerLockerDefine(trustedNamespaces) {
    // override the global LWR.define() for Locker
    globalThis.LWR = Object.freeze(Object.assign(Object.assign({}, globalThis.LWR), {
        define: function (specifier, dependencies, exporter, signature) {
            if (typeof dependencies === 'function') {
                // when the module has no dependency, the bundler only passes 3 parameters, the specifier, exporter and signature
                // e.g. LWR.define('my/cmp', function() { return 1; }, {ownhash})
                signature = exporter;
                exporter = dependencies;
                dependencies = [];
            }
            loaderDefine(specifier, dependencies, secureExporter(specifier, dependencies, exporter, trustedNamespaces), signature);
        },
    }));
}

export { registerLockerDefine };
