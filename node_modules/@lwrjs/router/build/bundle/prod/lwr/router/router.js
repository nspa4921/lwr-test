import{registerDecorators as e}from"lwc";function t(e=""){return e=e||"",decodeURIComponent(e)}function n(e){"/"!==(e=e||"/").charAt(0)&&(e="/"+e);const t=e.match(/^[^#?]+/);if(null!==t){const e=t[0];return"/"===e?"/":e.replace(/\/$/,"")}return"/"}function r(e){const n=(e=e||"").indexOf("#");n>=0&&(e=e.substring(0,n));const r=e.indexOf("?"),o=r>=0?e.substr(r+1):null,i={};return o&&o.split("&").forEach((e=>{if(e.indexOf("=")>=0){const[n,r=""]=e.split("=");i[t(n)]=t(r)}else i[t(e)]=null})),i}function o(e={}){const t=Object.keys(e);return t.length?`?${t.map((t=>{const n=e[t];return null===n?t:`${t}=${function(e=""){return e=e||"",encodeURIComponent(e)}(n)}`})).join("&")}`:""}function i(e){return!!(e&&e.length>1)&&e.startsWith(":")}function s(e){return!!e&&(!!i(e)&&e.substr(1))}function a(e){return Object.values(e).reduce(((e,{routeParamName:t})=>{const n=s(t);return n&&e.push(n),e}),[])}function u(e,n){const{regex:r,params:o}=n,i=r.exec(e);if(i){const[,...e]=i,n={};return o.forEach(((r,o)=>{const{name:i}=r,s=e[o];n[i]=s?t(s):s})),n}return null}function c(e,n){if(e&&n){const{queryMatcher:r}=n,o=r(e);if(o){const e={};return Object.keys(o).forEach((n=>{const r=o[n],{value:i,routeParamName:s}=r,a=s?s.substr(1):n;e[a]=i?t(i):i})),e}}return null}function l(e,t){if(t){const{original:{page:{type:o="",attributes:s={},state:a={}}={}}={}}=t,l=n(e),f=r(e),d=u(l,t),p=c(f,t);if(d&&p){const e={...d,...p},n={};Object.keys(s).forEach((t=>{const r=s[t];let o;if(r&&i(r)){const t=r.substr(1);o=e[t]}else o=r;n[t]=o}));const r={};Object.keys(a).forEach((t=>{const n=a[t];let o;if(n&&i(n)){const t=n.substr(1);o=e[t]}else o=n;r[t]=o}));const u=function(e,t){const{compiledQuery:n}=t,r=Object.keys(n).filter((e=>{const{literalValue:t}=n[e];return!t})),o={};return Object.keys(e).forEach((t=>{const n=e[t];r.indexOf(t)<0&&(o[t]=n)})),o}(f,t);return{type:o,attributes:{...n},state:{...u,...r}}}}return null}function f(e,t){const o=n(e),i=r(e),s=t?t.filter((e=>e.regex.test(o))):[],[a]=s.filter((e=>{const{queryMatcher:t}=e;return t(i)&&function(e,t,n){const{original:{patterns:r=null}={}}=n||{};if(r){const o={...u(e,n),...c(t,n)};return Object.keys(r).every((e=>{const t=r[e],n=new RegExp(t),i=o[e]||"";return n.test(i)}))}return!0}(o,i,e)}));return a||null}function d(e,t,n=""){n&&0===e.indexOf(n)&&(e=e.replace(n,""));const r=f(e,t);let o;if(!r)return null;{const t=l(e,r);if(t){return o={route:{id:r.original.id,attributes:{...t.attributes},state:{...t.state},pageReference:{type:t.type,attributes:{...t.attributes},state:{...t.state}}},routeDefinition:r},o}}return null}function p(e,t,n=""){const r=function(e,t){if(!e)return null;const{type:n,attributes:r={},state:o={}}=e;if(n){const[e]=t.filter((e=>{const{original:{page:{type:t=null,attributes:s={},state:a={}}={}}}=e,u=t===n,c=Object.keys(s).every((e=>Object.keys(r).indexOf(e)>=0)),l=Object.keys(s).length===Object.keys(r).length,f=Object.keys(a).every((e=>Object.keys(o).indexOf(e)>=0)),d=Object.keys(s).filter((e=>{const t=s[e];return!t||!i(t)})).every((e=>s[e]===r[e])),p=Object.keys(a).filter((e=>{const t=a[e];return null===t||!i(t)})).every((e=>a[e]===o[e]));return u&&c&&l&&d&&f&&p}));return e||null}return null}(e,t);return r?g(e,r,n):null}function h(e,t,n){const{attributeBindings:r,stateBindings:o}=n,{attributes:i,state:a}=t,u={};return e.forEach((e=>{const[t]=Object.keys(r).filter((t=>s(r[t])===e));if(t)u[e]=i[t];else{const[t]=Object.keys(o).filter((t=>s(o[t])===e));t&&(u[e]=a[t])}})),u}function g(e,t,n=""){const{params:r,original:{page:u={}}={},toPath:c,compiledQuery:l}=t,{attributes:f={},state:d={}}=u,p=c(h(r.filter((({name:e})=>"string"==typeof e)).map((({name:e})=>e)),e,{attributeBindings:f,stateBindings:d})),g=function(e,t,n){const{compiledQuery:r,original:{page:{state:o={}}}}=n,{state:a={}}=e||{},u={};Object.keys(a).filter((e=>!i(o[e]))).forEach((e=>u[e]=a[e]));const c={};return Object.keys(t).forEach((e=>{const n=t[e],[o]=Object.keys(r).filter((t=>{const n=r[t],{routeParamName:o}=n;return s(o)===e}));if(o){c[o]=n}})),{...u,...c}}(e,h(a(l),e,{attributeBindings:f,stateBindings:d}),t);return`${n}${p}${o(g)}`}function m(e,t=2){if(function(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}(e))try{Object.freeze(e),t>0&&Object.keys(e).forEach((n=>{if(function(e,t){return t in e}(e,n)){const r=e[n];r&&"object"==typeof r&&m(r,t-1)}}))}catch(e){}return e}const E=1;function y(e,t){return`${e.code}: ${function(e,t){return Array.isArray(t)?e.replace(/\{([0-9]+)\}/g,((e,n)=>t[n])):e}(e.message,t)}`}function R(e,t,n){if(!e)throw new Error(y(t,n))}const b={INVALID_MIXIN_CMP:{code:"LWR4001",message:"{0} must be an Element type",level:E},MISSING_CONTEXT:{code:"LWR4002",message:"Could not find context to perform navigation action.",level:E},INVALID_CONTEXT:{code:"LWR4003",message:"Cannot register navigation context; it must have this shape: { navigate, generateUrl, subscribe }",level:E},MULTIPLE_ROOTS:{code:"LWR4004",message:"Router connection failed. There can only be one root router.",level:E},MULTIPLE_CHILDREN:{code:"LWR4005",message:"Could not add to the navigation hierarchy. There can only be one child per navigation node.",level:E},MISSING_ROUTE:{code:"LWR4006",message:'A route cannot be created to navigate to URL "{0}"',level:E,address:"{0}"},MISSING_URL:{code:"LWR4007",message:'A URL cannot be created to navigate to route "{0}"',level:E,address:"{0}"},PRENAV_FAILED:{code:"LWR4008",message:'A preNavigate hook listener blocked routing to "{0}"',level:2,address:"{0}"},MISSING_ROUTE_TEMPLATE:{code:"LWR4009",message:'A route definition must contain a "uri" property.',level:E},MISSING_ROUTE_CMP:{code:"LWR4016",message:"Expected a route view component with a default export.",level:E},MISSING_DATA_CONTEXT:{code:"LWR4018",message:"Could not find context to retrieve navigation data.",level:E},INVALID_ROUTE_QUERY:{code:"LWR4019",message:"Invalid query param in route definition.",level:E},MISSING_PAGE_BINDING:{code:"LWR4020",message:"Route definition must provide page binding",level:E},INVALID_PAGE_BINDING:{code:"LWR4021",message:"Invalid page binding in route definition",level:E},INVALID_URI_SYNTAX:{code:"LWR4022",message:"Invalid uri syntax. URI cannot contain *, +, (, ), ",level:E},VIEW_IMPORT_FAILED:{code:"LWR4023",message:'Error importing view with name "{0}", failure was: {1}',level:E,stack:"{2}"},VIEW_MISSING:{code:"LWR4024",message:'Expected a view with name "{0}" in the viewset',level:E},VIEW_IMPORT_FAILED_WITH_SPECIFIER:{code:"LWR4025",message:'Error importing module "{0}" from view with name "{1}", failure was: {2}',level:E,stack:"{3}"},NO_ROUTE_MATCH:{code:"LWR4026",message:"A routing match cannot be found for: {0}",level:E},INVALID_ROUTE_HANDLER:{code:"LWR4027",message:'Route definition "{0}" does not have a valid route handler module',level:E}};function I(e){return e.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function v(e){return e&&e.sensitive?"":"i"}function O(e,t={}){const n=function(e){const t=[];let n=0;for(;n<e.length;){const r=e[n];if("*"!==r&&"+"!==r&&"?"!==r)if("\\"!==r)if("{"!==r)if("}"!==r)if(":"!==r)if("("!==r)t.push({type:"CHAR",index:n,value:e[n++]});else{let r=1,o="",i=n+1;if("?"===e[i])throw new TypeError(`Pattern cannot start with "?" at ${i}`);for(;i<e.length;)if("\\"!==e[i]){if(")"===e[i]){if(r--,0===r){i++;break}}else if("("===e[i]&&(r++,"?"!==e[i+1]))throw new TypeError(`Capturing groups are not allowed at ${i}`);o+=e[i++]}else o+=e[i++]+e[i++];if(r)throw new TypeError(`Unbalanced pattern at ${n}`);if(!o)throw new TypeError(`Missing pattern at ${n}`);t.push({type:"PATTERN",index:n,value:o}),n=i}else{let r="",o=n+1;for(;o<e.length;){const t=e.charCodeAt(o);if(!(t>=48&&t<=57||t>=65&&t<=90||t>=97&&t<=122||95===t))break;r+=e[o++]}if(!r)throw new TypeError(`Missing parameter name at ${n}`);t.push({type:"NAME",index:n,value:r}),n=o}else t.push({type:"CLOSE",index:n,value:e[n++]});else t.push({type:"OPEN",index:n,value:e[n++]});else t.push({type:"ESCAPED_CHAR",index:n++,value:e[n++]});else t.push({type:"MODIFIER",index:n,value:e[n++]})}return t.push({type:"END",index:n,value:""}),t}(e),{prefixes:r="./"}=t,o=`[^${I(t.delimiter||"/#?")}]+?`,i=[];let s=0,a=0,u="";const c=e=>{if(a<n.length&&n[a].type===e)return n[a++].value},l=e=>{const t=c(e);if(void 0!==t)return t;const{type:r,index:o}=n[a];throw new TypeError(`Unexpected ${r} at ${o}, expected ${e}`)},f=()=>{let e,t="";for(;e=c("CHAR")||c("ESCAPED_CHAR");)t+=e;return t};for(;a<n.length;){const e=c("CHAR"),t=c("NAME"),n=c("PATTERN");if(t||n){let a=e||"";-1===r.indexOf(a)&&(u+=a,a=""),u&&(i.push(u),u=""),i.push({name:t||s++,prefix:a,suffix:"",pattern:n||o,modifier:c("MODIFIER")||""});continue}const a=e||c("ESCAPED_CHAR");if(a){u+=a;continue}u&&(i.push(u),u="");if(c("OPEN")){const e=f(),t=c("NAME")||"",n=c("PATTERN")||"",r=f();l("CLOSE"),i.push({name:t||(n?s++:""),pattern:t&&!n?o:n,prefix:e,suffix:r,modifier:c("MODIFIER")||""})}else l("END")}return i}function x(e,t){return function(e,t={}){const n=v(t),{encode:r=(e=>e),validate:o=!0}=t,i=e.map((e=>{if("object"==typeof e)return new RegExp(`^(?:${e.pattern})$`,n)}));return t=>{let n="";for(let s=0;s<e.length;s++){const a=e[s];if("string"==typeof a){n+=a;continue}const u=t?t[a.name]:void 0,c="?"===a.modifier||"*"===a.modifier,l="*"===a.modifier||"+"===a.modifier;if(Array.isArray(u)){if(!l)throw new TypeError(`Expected "${a.name}" to not repeat, but got an array`);if(0===u.length){if(c)continue;throw new TypeError(`Expected "${a.name}" to not be empty`)}for(let e=0;e<u.length;e++){const t=r(u[e],a);if(o&&!i[s].test(t))throw new TypeError(`Expected all "${a.name}" to match "${a.pattern}", but got "${t}"`);n+=a.prefix+t+a.suffix}continue}if("string"==typeof u||"number"==typeof u){const e=r(String(u),a);if(o&&!i[s].test(e))throw new TypeError(`Expected "${a.name}" to match "${a.pattern}", but got "${e}"`);n+=a.prefix+e+a.suffix;continue}if(c)continue;const f=l?"an array":"a string";throw new TypeError(`Expected "${a.name}" to be ${f}`)}return n}}(O(e,t),t)}function A(e,t,n){return function(e,t,n={}){const{strict:r=!1,start:o=!0,end:i=!0,encode:s=(e=>e)}=n,a=`[${I(n.endsWith||"")}]|$`,u=`[${I(n.delimiter||"/#?")}]`;let c=o?"^":"";for(const n of e)if("string"==typeof n)c+=I(s(n));else{const e=I(s(n.prefix)),r=I(s(n.suffix));if(n.pattern)if(t&&t.push(n),e||r)if("+"===n.modifier||"*"===n.modifier){const t="*"===n.modifier?"?":"";c+=`(?:${e}((?:${n.pattern})(?:${r}${e}(?:${n.pattern}))*)${r})${t}`}else c+=`(?:${e}(${n.pattern})${r})${n.modifier}`;else c+=`(${n.pattern})${n.modifier}`;else c+=`(?:${e}${r})${n.modifier}`}if(i)r||(c+=`${u}?`),c+=n.endsWith?`(?=${a})`:"$";else{const t=e[e.length-1],n="string"==typeof t?u.indexOf(t[t.length-1])>-1:void 0===t;r||(c+=`(?:${u}(?=${a}))?`),n||(c+=`(?=${u}|${a})`)}return new RegExp(c,v(n))}(O(e,n),t,n)}function _(e,t,n){return e instanceof RegExp?function(e,t){if(!t)return e;const n=e.source.match(/\((?!\?)/g);if(n)for(let e=0;e<n.length;e++)t.push({name:e,prefix:"",suffix:"",modifier:"",pattern:""});return e}(e,t):Array.isArray(e)?function(e,t,n){const r=e.map((e=>_(e,t,n).source));return new RegExp(`(?:${r.join("|")})`,v(n))}(e,t,n):A(e,t,n)}const{INVALID_ROUTE_QUERY:N,MISSING_ROUTE_TEMPLATE:w,MISSING_PAGE_BINDING:T,INVALID_PAGE_BINDING:$,INVALID_URI_SYNTAX:D}=b;function L(e){const{routes:t,caseSensitive:o}=e;return t.map((e=>function(e,t=!1){const o=[],{uri:u,page:c}=e;R(!!u,w),R(function(e=""){return!["*","+","(",")",";"].some((t=>e.indexOf(t)>=0))}(u),D),R(!!c,T);const l=n(u),f=r(u),d=_(l,o,{sensitive:t,end:!1!==e.exact}),p=x(l,{encode:encodeURIComponent}),h=function(e){const t={};return Object.keys(e).forEach((n=>{const r=e[n];R(!i(n)||null===r,N),i(n)?t[n.substr(1)]={routeParamName:n}:r&&i(r)?t[n]={routeParamName:r}:t[n]={literalValue:null===r?null:r}})),t}(f),g=function(e,t=!1){return n=>{const r=Object.keys(n),o=Object.keys(e);return o.every((e=>r.indexOf(e)>=0))?o.reduce(((r,o)=>{if(null===r)return null;const{literalValue:i,routeParamName:s}=e[o],a=n[o];let u=!0;return"string"==typeof i?u=t?i===a:i.toUpperCase()===(null==a?a:a.toUpperCase()):null===i&&(u=a===i),r=u?{...r,[o]:{value:a,routeParamName:s}}:null}),{}):null}}(h,t),m={original:e,regex:d,params:o,toPath:p,compiledQuery:h,queryMatcher:g};return R(function(e){const{original:{page:t}={},params:n,compiledQuery:r}=e,o=t?t.type:t,u=(t?t.attributes:t)||{},c=(t?t.state:t)||{};if("string"!=typeof o||"object"!=typeof u||"object"!=typeof c)return!1;const l=Object.values(n).map((({name:e})=>e)),f=a(r),d=[...l,...f],p=Object.values(u).filter(i).map(s),h=Object.values(c).filter(i).map(s),g=d.every((e=>"string"==typeof e&&(p.indexOf(e)>=0||h.indexOf(e)>=0))),m=d.length===p.length+h.length;return!!(t&&o&&u&&c&&g&&m)}(m),$),m}(e,o)))}function P(){let e,t,n=[];const r=r=>{n.filter((e=>null!==e)).forEach((e=>e.error&&e.error(r))),e=void 0,t=r};return{next:r=>{n.filter((e=>null!==e)).forEach((e=>e.next&&e.next(r))),e=r,t=void 0},error:r,complete:()=>{n.filter((e=>null!==e)).forEach((e=>e.complete&&e.complete())),n=[],e=void 0,t=void 0},subscribe:(o,i=!0)=>{(e=>{n.push(e)})(o),e&&i&&o.next(e),t&&r(t);const s=n.length-1;return{unsubscribe:()=>(e=>{n=[...n.slice(0,e),...n.slice(e+1)]})(s)}}}}class U{constructor(e){this.deprecatedConfig={},this.routeHandlerId=0,this.compiledRoutes=[],this.routeObservable=P(),this.config={basePath:e.basePath||"",caseSensitive:Boolean(e.caseSensitive),routes:e.routes||[],generateUrl:e=>p(e,this.compiledRoutes,this.config.basePath),parseUrl:e=>function(e,t,n=""){const r=d(e,t,n);return r&&r.route&&r.route.pageReference?r.route.pageReference:null}(e,this.compiledRoutes,this.config.basePath)};const{DEPRECATED_getRouteFromUrl:t,DEPRECATED_getUrlFromRoute:n}=e;t&&(this.deprecatedConfig.DEPRECATED_getRouteFromUrl=t),n&&(this.deprecatedConfig.DEPRECATED_getUrlFromRoute=n),this.compiledRoutes=L(this.config)}generateUrl(e){const{DEPRECATED_getUrlFromRoute:t}=this.deprecatedConfig;return t?t(e,this.config.generateUrl.bind(this,e)):this.config.generateUrl(e)}parseUrl(e){const{DEPRECATED_getRouteFromUrl:t}=this.deprecatedConfig;return t?t(e,this.config.parseUrl.bind(this,e)):this.config.parseUrl(e)}matchRoute(e){const t="string"==typeof e?e:this.generateUrl(e);if(null===t)return null;const n=d(t,this.compiledRoutes,this.config.basePath),r=n&&g(n.route.pageReference,n.routeDefinition,this.config.basePath);return n&&r?{pathMatch:r,route:n.route,routeDefinition:n.routeDefinition.original}:null}async resolveView(e){return new Promise(((t,n)=>{const r=this.matchRoute(e);return r?r.routeDefinition.handler().then((e=>{const o=e.default;if(!o)return n(y(b.INVALID_ROUTE_HANDLER,[r.routeDefinition.id]));const i=new o(t);i&&i.update(r.route)})):n(y(b.NO_ROUTE_MATCH,[JSON.stringify(e)]))}))}navigate(e){const t=this.matchRoute(e);if(!t)throw new Error(y(b.MISSING_ROUTE,[JSON.stringify(e)]));this.pendingRoute={...t},this._mapView(this.pendingRoute)}subscribe(e,t){return this.routeObservable.subscribe({next:e,error:()=>{},complete:()=>{}},Boolean(t))}async _mapView(e){const t=Math.random();this.routeHandlerId=t;const n=(await e.routeDefinition.handler()).default;if(!n)throw new Error(y(b.INVALID_ROUTE_HANDLER,[e.routeDefinition.id]));return this.routeHandler=new n((e=>{this._updateView(t,e)})),this.routeHandler&&this.routeHandler.update(e.route),!0}_updateView(e,t){if(!t||!t.viewset||e!==this.routeHandlerId)return;if(!this.pendingRoute)throw new Error("Trying to commit route state without a route");const n=m(t.viewset);this.routeObservable.next({...this.pendingRoute,viewset:n})}}function C(e={}){return new U(e)}e(U,{fields:["deprecatedConfig","routeHandlerId"]});export{C as createRouter};
