import { BOOTSTRAP_AVAILABILITY, BOOTSTRAP_DURATION, BOOTSTRAP_END, BOOTSTRAP_ERROR, MAPPINGS_AVAILABILITY, MAPPINGS_ERROR, MAPPINGS_FETCH, MAPPINGS_FETCH_COUNT, MAPPINGS_FETCH_DURATION, MODULE_AVAILABILITY, MODULE_DEFINE, MODULE_DEFINE_COUNT, MODULE_ERROR, MODULE_FETCH, MODULE_FETCH_COUNT, MODULE_FETCH_DURATION } from 'lwr/metrics';
export class PerformanceApiSink {
  marks = {};

  constructor(instrumentation, config) {
    this.config = config || {};
    this.instrumentation = instrumentation;
  }

  track() {
    this.trackExistingMarks();
    this.setupObserver();
  } // Return true if the mark is clearable
  // logOperationEnd clears the marks and measures passed to it, so these are NOT clearable
  // As of now, only "lwr.loader.*.fetch" metrics have durations (i.e. are not clearable)


  isClearable(name) {
    return !name.startsWith(MODULE_FETCH) && !name.startsWith(MAPPINGS_FETCH);
  } // Retrieve existing metrics to this point


  trackExistingMarks() {
    /**
     * Loader define marks prior to service bootstrap
     */
    const marks = performance.getEntriesByType('mark').filter(e => e.name.startsWith(MODULE_DEFINE)); // initialize the module define count
    // at this point in time, the count will include modules NOT fetched by the loader:
    //      - required modules
    //      - preload modules
    //      - the application bootstrap module
    //      - the loader module itself

    if (marks.length > 0) {
      this.instrumentation.incrementCounter(MODULE_DEFINE_COUNT, marks.length);
    }
  } // Add observer to log future metrics
  // observe lwr client runtime performance metrics


  setupObserver() {
    let bootstrapErrorCount = 0;
    let loaderModuleErrorCount = 0;
    let loaderMappingsErrorcount = 0;
    const observer = new PerformanceObserver(list => {
      // grab the lwr performance marks
      const marks = [];
      /**
       * Bootstrap and Loader marks
       */

      list.getEntries().forEach(entry => {
        const {
          name,
          entryType,
          duration
        } = entry;

        if (entryType === 'mark' && name.startsWith('lwr.')) {
          marks.push(entry);
        }

        if (name === BOOTSTRAP_END) {
          this.marks[name] = entry;
        }

        if (name === BOOTSTRAP_ERROR) {
          bootstrapErrorCount += 1;
        }

        if (name === MODULE_ERROR) {
          loaderModuleErrorCount += 1;
        }

        if (name === MAPPINGS_ERROR) {
          loaderMappingsErrorcount += 1;
        }

        if (this.config.enableModuleFetchTracking && name.startsWith(MODULE_FETCH_DURATION)) {
          this.instrumentation.trackValue(name, duration);
        }

        if (this.config.enableMappingFetchTracking && name.startsWith(MAPPINGS_FETCH_DURATION)) {
          this.instrumentation.trackValue(name, duration);
        }
      });

      if (this.marks[BOOTSTRAP_END] !== undefined) {
        this.instrumentation.trackValue(BOOTSTRAP_DURATION, this.marks[BOOTSTRAP_END].startTime);
        this.instrumentation.trackValue(BOOTSTRAP_AVAILABILITY, 1 / (1 + bootstrapErrorCount) * 100); // reset to prevent multiple reports

        delete this.marks[BOOTSTRAP_END];
      } // count how many modules were defined and report the count


      const moduleDefineCount = marks.reduce((count, mark) => {
        return mark.name.startsWith(MODULE_DEFINE) ? count + 1 : count;
      }, 0);

      if (moduleDefineCount > 0) {
        this.instrumentation.incrementCounter(MODULE_DEFINE_COUNT, moduleDefineCount);
      } // count how many modules were loaded and report the count


      const moduleLoadCount = marks.reduce((count, mark) => {
        return mark.name.startsWith(MODULE_FETCH) ? count + 1 : count;
      }, 0);

      if (moduleLoadCount > 0) {
        this.instrumentation.incrementCounter(MODULE_FETCH_COUNT, moduleLoadCount);
        this.instrumentation.trackValue(MODULE_AVAILABILITY, moduleLoadCount / (moduleLoadCount + loaderModuleErrorCount) * 100);
      } // count how many mapping resources were loaded and report the count


      const mappingLoadCount = marks.reduce((count, mark) => {
        return mark.name.startsWith(MAPPINGS_FETCH) ? count + 1 : count;
      }, 0);

      if (mappingLoadCount > 0) {
        this.instrumentation.incrementCounter(MAPPINGS_FETCH_COUNT, mappingLoadCount);
        this.instrumentation.trackValue(MAPPINGS_AVAILABILITY, mappingLoadCount / (mappingLoadCount + loaderMappingsErrorcount) * 100);
      } // remove clearable marks


      marks.forEach(mark => this.isClearable(mark.name) && performance.clearMarks(mark.name));
    });
    observer.observe({
      entryTypes: ['mark', 'measure']
    });
  }

}