import * as parse5 from 'parse5';
import { CompilerDiagnostic, LWCErrorInfo } from '@lwc/errors';
import { IRElement, LWCDirectiveRenderMode, IRBaseAttribute, IRNode } from '../shared/types';
import { ResolvedConfig } from '../config';
export default class ParserCtx {
    private readonly source;
    readonly config: ResolvedConfig;
    readonly warnings: CompilerDiagnostic[];
    readonly seenIds: Set<string>;
    readonly seenSlots: Set<string>;
    readonly parentStack: IRElement[];
    constructor(source: String, config: ResolvedConfig);
    getSource(start: number, end: number): string;
    ancestors(element?: IRElement): Generator<{
        current: IRElement;
        index: number;
    }, void, unknown>;
    findAncestor(args: {
        element?: IRElement;
        predicate: (elm: IRElement) => unknown;
        traversalCond?: (nodes: {
            current: IRElement;
            parent: IRElement | null;
        }) => unknown;
    }): IRElement | null;
    /**
     * This method recovers from diagnostic errors that are encountered when fn is invoked.
     * All other errors are considered compiler errors and can not be recovered from.
     *
     * @param fn - method to be invoked.
     */
    withErrorRecovery<T>(fn: () => T): T | undefined;
    withErrorWrapping<T>(fn: () => T, errorInfo: LWCErrorInfo, location: parse5.Location, msgFormatter?: (error: any) => string): T;
    throwOnError(errorInfo: LWCErrorInfo, error: any, location?: parse5.Location): never;
    /**
     * This method throws a diagnostic error with the IRNode's location.
     */
    throwOnIRNode(errorInfo: LWCErrorInfo, irNode: IRNode | IRBaseAttribute, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error with location information.
     */
    throwAtLocation(errorInfo: LWCErrorInfo, location: parse5.Location, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error and will immediately exit the current routine.
     */
    throw(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: parse5.Location): never;
    /**
     * This method logs a diagnostic warning with the IRNode's location.
     */
    warnOnIRNode(errorInfo: LWCErrorInfo, irNode: IRNode | IRBaseAttribute, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning with location information.
     */
    warnAtLocation(errorInfo: LWCErrorInfo, location: parse5.Location, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning and will continue execution of the current routine.
     */
    warn(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: parse5.Location): void;
    private addDiagnostic;
    getRoot(element: IRElement): IRElement;
    getRenderMode(element: IRElement): LWCDirectiveRenderMode;
    getPreserveComments(element: IRElement): boolean;
}
