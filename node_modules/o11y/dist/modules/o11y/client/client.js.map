{"version":3,"file":"client.js","sources":["../../../../src/library/PublicSafety.ts","../../../../src/library/Tracing.ts","../../../../src/library/ActivityImpl.ts","../../../../../../node_modules/o11y_schema/sf_instrumentation/activity.js","../../../../../../node_modules/o11y_schema/sf_instrumentation/error.js","../../../../../../node_modules/o11y_schema/sf_instrumentation/instrumented_event.js","../../../../../../node_modules/o11y_schema/sf_instrumentation/simple.js","../../../../src/library/ActivityNoOp.ts","../../../../src/library/DomEventHelpers.ts","../../../../src/library/LogValidator.ts","../../../../src/library/UpCounterImpl.ts","../../../../src/library/ValueRecorderImpl.ts","../../../../src/library/SizeLimitedMap.ts","../../../../src/library/MetricsImpl.ts","../../../../src/library/MockEvent.ts","../../../../src/library/InstrumentationImpl.ts","../../../../src/library/RootActivityImpl.ts","../../../../src/library/RootActivityNoOp.ts","../../../../src/library/AppInstrumentationImpl.ts","../../../../src/library/AutomaticClickTracker.ts","../../../../src/library/NextgenImpl.ts","../../../../src/index.ts","../../../../src/library/TaskerImpl.ts","../../../../src/console-collector/ConsoleCollector.ts","../../../../src/client.ts","../../../../src/library/IdleDetectorImpl.ts"],"sourcesContent":["import { UpCounter } from '../interfaces';\nimport { utility } from 'o11y/shared';\n\nexport class PublicSafety {\n    private _safeCatchMode = false;\n\n    constructor(private readonly _errorCounter?: UpCounter) {}\n\n    /**\n     * Instrumentation should never throw in production. Therefore, we need to include in\n     * all our public methods a top-most try/catch wrapper. Simply use this function\n     * as your first and only top-level call in the function block and sleep well at night.\n     *\n     * @param fn The body of the unsafe function that doesn't return a value but can throw\n     */\n    tryCatch(fn: () => void): void {\n        try {\n            fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n        }\n    }\n\n    /**\n     *\n     * @param fn The body of the unsafe function that returns a value and that can throw\n     * @param noopValue A static, noop instance of V (like a mock) that will be returned in case\n     * the function could not be called.\n     */\n    tryCatchReturn<V>(fn: () => V, noopValue: V): V {\n        try {\n            utility.requireArgument(noopValue, 'noopValue');\n            return fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n            return noopValue;\n        }\n    }\n\n    /**\n     * Safely handles exceptions. Suppresses throws in a production environment.\n     * This method is intended to be called inside a catch block.\n     *\n     * @param error The error that was caught\n     */\n    private _prodSafeCatch(error: unknown): void {\n        let allowThrow;\n        try {\n            allowThrow = !utility.isProduction;\n            if (allowThrow) {\n                // Just throw the error in development\n                throw error;\n            }\n\n            if (this._safeCatchMode) {\n                // If we're here, that means code in the try block of prodSafeCatch itself is throwing an error\n                // (i.e. prodSafeCatch is already on the stack). Break out now to prevent infinite loop.\n                this._safeCatchMode = false;\n\n                throw new Error('Internal error in prodSafeCatch.');\n            }\n\n            this._safeCatchMode = true;\n            if (this._errorCounter) {\n                this._errorCounter.increment();\n            }\n\n            if (!(error instanceof Error)) {\n                const errorText =\n                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n                    (error && (error as any).message) ||\n                    (typeof error.toString === 'function' ? error.toString() : '');\n                error = new Error(errorText);\n            }\n\n            // If not allowed to throw the error, at least try to log it\n            // TODO: This error should be attributed to the global Instrumentation (not to \"this\")\n            // this.error(error);\n            this._safeCatchMode = false;\n        } catch (internalError) {\n            // Do not call any methods in this catch block except for console.error\n\n            if (allowThrow) {\n                // pass it along\n                throw internalError;\n            }\n\n            // eslint-disable-next-line no-console\n            if (internalError && console && typeof console.error === 'function') {\n                try {\n                    // eslint-disable-next-line no-console\n                    console.error(internalError);\n                } catch {\n                    // Nothing we can do at this point\n                }\n            }\n            this._safeCatchMode = false;\n        }\n    }\n}\n","import {\n    Instrumentation,\n    TracingHeadersOptions,\n    NetworkInstrumentationOptions,\n    Activity\n} from '../interfaces';\nimport { utility } from 'o11y/shared';\n\ntype FetchType = (input: RequestInfo, init?: RequestInit) => Promise<Response>;\ntype XhrType = {\n    prototype: XMLHttpRequest;\n    new (): XMLHttpRequest;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n};\ntype XhrSendType = (body?: Document | BodyInit | null) => void;\ninterface O11yXhr extends XMLHttpRequest {\n    _o11yActivity: Activity;\n}\n\nconst defaultTraceIdLengthW3 = 32; // 32 Characters = 128 bits\nconst defaultTraceIdLengthB3 = 16; // 16 Characters = 64 bits\nconst defaultSpanIdLength = 16; // 16 Characters = 64 bits\n\n// Headers for W3 tracing (https://www.w3.org/TR/trace-context/#traceparent-header)\nconst headerTraceParent = 'traceparent';\n\n// Headers for B3 tracing (https://github.com/openzipkin/b3-propagation)\nconst headerB3 = 'b3';\nconst headerTraceId = 'X-B3-TraceId';\nconst headerSpanId = 'X-B3-SpanId';\nconst headerSampled = 'X-B3-Sampled';\nconst headerParentSpanId = 'X-B3-ParentSpanId';\n\nconst defaultActivityNameForFetch = 'fetch';\nconst defaultActivityNameForXhrSend = 'xhr_send';\n\nexport class Tracing {\n    private static _global = utility.getGlobal();\n    private static _originalFetch: FetchType;\n    private static _originalXhr: XhrType;\n    private static _originalXhrSend: XhrSendType;\n    private static _isNetworkInstrumentationEnabled = false;\n\n    constructor(private readonly instr: Instrumentation) {\n        utility.requireArgument(instr, 'instr', 'object');\n    }\n\n    private static _getB3CompactFormat(\n        traceId: string,\n        spanId: string,\n        isSampled?: boolean,\n        parentSpanId?: string\n    ): string {\n        // b3={TraceId}-{SpanId}-{SamplingState}-{ParentSpanId}\n        // Note: last two fields are optional\n\n        let b3 = `${traceId}-${spanId}`;\n\n        if (isSampled !== undefined || parentSpanId !== undefined) {\n            b3 += isSampled ? '-1' : '-0';\n            if (parentSpanId !== undefined) {\n                b3 += `-${parentSpanId}`;\n            }\n        }\n        return b3;\n    }\n\n    private static _getW3CompactFormat(\n        traceId: string,\n        spanId: string,\n        isSampled: boolean\n    ): string {\n        // traceparent={version}-{trace-id}-{parent-id}-{trace-flags}\n        // \"in some tracing systems, parent-id is known as the span-id, where a span is the execution of a client request\"\n        return `00-${traceId}-${spanId}-${isSampled ? '01' : '00'}`;\n    }\n\n    private static _conformTextAsId(text: string, numChars: number): string {\n        // First validate\n        text = text.toLowerCase();\n        const len: number = text.length;\n        for (let i = 0; i < len; i += 1) {\n            const c = text[i];\n            if (!(c >= 'a' && c <= 'f') && !(c >= '0' && c <= '9')) {\n                throw new Error(`The text '${text}' has an invalid character at index #${i}`);\n            }\n        }\n\n        if (len > numChars) {\n            // Use the right-most characters per spec\n            return text.substr(len - numChars);\n        }\n        if (len < numChars) {\n            // Pad left with 0s per spec\n            return text.padStart(numChars, '0');\n        }\n        return text;\n    }\n\n    public static getHeaders(\n        traceId: string,\n        spanId: string,\n        isSampled?: boolean,\n        options?: TracingHeadersOptions\n    ): Record<string, string> {\n        utility.requireArgument(traceId, 'traceId', 'string');\n        utility.requireArgument(spanId, 'spanId', 'string');\n\n        const useB3Headers: boolean = options && options.useB3Headers;\n\n        traceId = this._conformTextAsId(\n            traceId,\n            options && options.traceIdEffectiveLength !== undefined\n                ? options.traceIdEffectiveLength\n                : useB3Headers\n                ? defaultTraceIdLengthB3\n                : defaultTraceIdLengthW3\n        );\n        spanId = this._conformTextAsId(spanId, defaultSpanIdLength);\n\n        const parentSpanId =\n            (options &&\n                options.parentSpanId !== undefined &&\n                this._conformTextAsId(options.parentSpanId, defaultSpanIdLength)) ||\n            undefined;\n\n        const headers: Record<string, string> = {};\n\n        if (useB3Headers) {\n            // By default, use non-compact\n            const isCompact: boolean = options && options.useCompactHeader;\n            if (isCompact) {\n                headers[headerB3] = this._getB3CompactFormat(\n                    traceId,\n                    spanId,\n                    isSampled,\n                    parentSpanId\n                );\n            } else {\n                headers[headerTraceId] = traceId;\n                headers[headerSpanId] = spanId;\n                if (parentSpanId !== undefined) {\n                    headers[headerParentSpanId] = parentSpanId;\n                }\n                if (isSampled !== undefined) {\n                    headers[headerSampled] = isSampled ? '1' : '0';\n                }\n            }\n        } else {\n            headers[headerTraceParent] = this._getW3CompactFormat(traceId, spanId, isSampled);\n        }\n\n        return headers;\n    }\n\n    private _disableNetworkInstrumentation(): void {\n        if (Tracing._isNetworkInstrumentationEnabled) {\n            if (Tracing._originalFetch) {\n                Tracing._global.fetch = Tracing._originalFetch;\n                Tracing._originalFetch = undefined;\n            }\n            if (Tracing._originalXhr) {\n                Tracing._global.XMLHttpRequest = Tracing._originalXhr;\n                Tracing._originalXhr = undefined;\n            }\n            if (Tracing._originalXhrSend) {\n                Tracing._global.XMLHttpRequest.prototype.send = Tracing._originalXhrSend;\n                Tracing._originalXhrSend = undefined;\n            }\n            Tracing._isNetworkInstrumentationEnabled = false;\n        }\n    }\n\n    private _enableNetworkInstrumentation(\n        instr: Instrumentation,\n        logErrors: boolean,\n        activityName: string,\n        useTracing: boolean,\n        options: TracingHeadersOptions\n    ): void {\n        if (typeof Tracing._global.fetch === 'function') {\n            this._overrideFetch(instr, logErrors, activityName, useTracing, options);\n            Tracing._isNetworkInstrumentationEnabled = true;\n        }\n\n        if (typeof Tracing._global.XMLHttpRequest === 'function') {\n            this._overrideXhr(instr, logErrors, activityName, useTracing, options);\n            Tracing._isNetworkInstrumentationEnabled = true;\n        }\n    }\n\n    private _overrideFetch(\n        instr: Instrumentation,\n        logErrors: boolean,\n        activityName: string,\n        useTracing: boolean,\n        options: TracingHeadersOptions\n    ): void {\n        Tracing._originalFetch = Tracing._global.fetch;\n        const o11yFetch: FetchType = async (url, reqOptions, ...restArgs) => {\n            let activity: Activity;\n            try {\n                activity = instr.startActivity(activityName || defaultActivityNameForFetch);\n\n                if (useTracing) {\n                    reqOptions = reqOptions || {};\n                    const traceHeaders = activity.getTraceHeaders(options);\n                    reqOptions.headers = Object.assign(reqOptions.headers || {}, traceHeaders);\n                }\n                return await Tracing._originalFetch.call(\n                    Tracing._global,\n                    url,\n                    reqOptions,\n                    ...restArgs\n                );\n            } catch (ex) {\n                if (logErrors) {\n                    if (activity) {\n                        activity.error(ex);\n                    } else {\n                        instr.error(ex);\n                    }\n                }\n                throw ex;\n            } finally {\n                if (activity) {\n                    activity.stop();\n                }\n            }\n        };\n        Tracing._global.fetch = o11yFetch;\n    }\n\n    private _overrideXhr(\n        instr: Instrumentation,\n        logErrors: boolean,\n        activityName: string,\n        useTracing: boolean,\n        options: TracingHeadersOptions\n    ): void {\n        Tracing._originalXhr = Tracing._global.XMLHttpRequest;\n        Tracing._originalXhrSend = Tracing._originalXhr.prototype.send;\n\n        Tracing._originalXhr.prototype.send = function (this: O11yXhr, ...args) {\n            let activity: Activity;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const xhr: O11yXhr = this;\n            try {\n                xhr._o11yActivity = activity = instr.startActivity(\n                    activityName || defaultActivityNameForXhrSend\n                );\n                if (useTracing) {\n                    const headers = activity.getTraceHeaders(options);\n\n                    Object.entries(headers).forEach((entry) => {\n                        xhr.setRequestHeader(entry[0], entry[1]);\n                    });\n                }\n                Tracing._originalXhrSend.call(this, ...args);\n            } catch (ex) {\n                if (logErrors) {\n                    if (activity) {\n                        activity.error(ex);\n                    } else {\n                        instr.error(ex);\n                    }\n                }\n                if (activity) {\n                    activity.stop();\n                }\n                throw ex;\n            }\n        };\n\n        const xhrProxy = new Proxy<XhrType>(Tracing._originalXhr, {\n            construct(target: XhrType) {\n                const newXhr = new target() as O11yXhr;\n\n                // Be the first in the event chain\n                newXhr.addEventListener('load', () => {\n                    const activity = newXhr._o11yActivity;\n                    if (activity) {\n                        activity.stop();\n                    }\n                });\n                newXhr.addEventListener(\n                    'error',\n                    (__err: ProgressEvent<XMLHttpRequestEventTarget>) => {\n                        const error = new Error('XHR Network-Level Error');\n                        const activity = newXhr._o11yActivity;\n                        if (activity) {\n                            if (logErrors) {\n                                activity.error(error);\n                            }\n                            activity.stop();\n                        } else if (logErrors) {\n                            instr.error(error);\n                        }\n                    }\n                );\n                newXhr.addEventListener('abort', () => {\n                    const activity = newXhr._o11yActivity;\n                    if (activity) {\n                        activity.discard();\n                    }\n                });\n                return newXhr;\n            }\n        });\n\n        Tracing._global.XMLHttpRequest = xhrProxy;\n    }\n\n    networkInstrumentation(options: boolean | NetworkInstrumentationOptions): void {\n        utility.requireArgument(options, 'options', ['boolean', 'object']);\n\n        if (options) {\n            // First disable it if necessary, so we can use the new options if it was already enabled\n            this._disableNetworkInstrumentation();\n\n            const tracingOptions: NetworkInstrumentationOptions =\n                typeof options === 'object' ? options : {};\n\n            this._enableNetworkInstrumentation(\n                utility.definedValueOrDefault(tracingOptions.instrumentation, this.instr),\n                utility.definedValueOrDefault(tracingOptions.logErrors, true),\n                tracingOptions.activityName,\n                utility.definedValueOrDefault(tracingOptions.useTracing, true),\n                tracingOptions.tracingHeadersOptions\n            );\n        } else {\n            // Options is falsy, disable.\n            this._disableNetworkInstrumentation();\n        }\n    }\n}\n","import { Activity, ActivityDetail, Schema, TracingHeadersOptions } from '../interfaces';\nimport { PublicSafety } from './PublicSafety';\nimport { Tracing } from './Tracing';\nimport { SchematizedData, utility } from 'o11y/shared';\n\nexport const timedout = 'timedout';\nexport const terminated = 'terminated';\nexport const discarded = 'discarded';\n\nconst stopReason = {\n    timedout,\n    terminated,\n    discarded\n};\n\nexport type onActivityStop = (detail: ActivityDetail) => void;\nexport type onActivityError = (error: Error, detail: ActivityDetail) => void;\n\nexport class ActivityImpl implements Activity {\n    protected readonly _id: string;\n    private readonly _startTimestamp: number;\n    private readonly _startPerfTime: number;\n    private readonly _safety: PublicSafety;\n    private readonly _usePerf: boolean;\n    protected static _count = 0;\n    private readonly _perfId: string;\n    private readonly _perfName: string;\n    private _stopPerfTime: number;\n    private _stopReason: string;\n    private _timer: NodeJS.Timer;\n    private _errorCount = 0;\n\n    constructor(\n        protected readonly _name: string,\n        protected readonly _rootId: string,\n        private readonly _onStopped: onActivityStop,\n        private readonly _onError: onActivityError,\n        timeout?: number,\n        id?: string,\n        protected readonly _isSampled?: boolean\n    ) {\n        const { tsNow, perfNow } = utility.time();\n\n        ActivityImpl._count += 1;\n        this._id = id || utility.generateUniqueId();\n\n        this._usePerf =\n            typeof performance !== 'undefined' &&\n            typeof performance.mark === 'function' &&\n            typeof performance.measure === 'function';\n        if (this._usePerf) {\n            this._perfName = `${this._name}__${ActivityImpl._count}`;\n            this._perfId = `${this._name}__${this.id}`;\n            try {\n                performance.mark(this._perfId);\n            } catch {\n                this._usePerf = false;\n            }\n        }\n\n        this._startTimestamp = tsNow;\n        this._startPerfTime = perfNow;\n\n        if (timeout > 0) {\n            this._timer = setTimeout(() => {\n                this._stopReason = this._stopReason || stopReason.timedout;\n                this.stop();\n            }, timeout);\n        }\n        this._safety = new PublicSafety();\n    }\n\n    get id(): string {\n        return this._id;\n    }\n\n    getId(): string {\n        return this.id;\n    }\n\n    getRootId(): string {\n        return this._rootId;\n    }\n\n    get stopReason(): string {\n        return this._stopReason;\n    }\n\n    error(\n        error: Error | string,\n        userSchemaOrText?: Schema | string,\n        userData?: SchematizedData\n    ): void {\n        this._safety.tryCatch(() => {\n            this._errorCount += 1;\n            if (typeof error === 'string') {\n                error = new Error(error);\n            }\n            this._onError(error, this._getDetail(userSchemaOrText, userData));\n        });\n    }\n\n    stop(userSchemaOrText?: Schema | string, userData?: SchematizedData): void {\n        this._safety.tryCatch(() => this._stopInternal(userSchemaOrText, userData));\n    }\n\n    private _stopInternal(userSchemaOrText: Schema | string, userData: SchematizedData): void {\n        // First things first.\n        const stopPerfTime = utility.perfNow();\n        if (this._usePerf) {\n            try {\n                // Use a more user-friendly name for measure.\n                performance.measure(this._perfName, this._perfId);\n                performance.clearMarks(this._perfId);\n                performance.clearMeasures(this._perfName);\n            } catch {}\n        }\n\n        if (this._timer) {\n            clearTimeout(this._timer);\n            this._timer = undefined;\n        }\n        if (this.isStopped) {\n            // Already stopped\n            return;\n        }\n        this._stopPerfTime = stopPerfTime;\n\n        const activityDetail: ActivityDetail = this._getDetail(userSchemaOrText, userData);\n        this._onStopped(activityDetail);\n    }\n\n    get isStopped(): boolean {\n        return this._stopPerfTime !== undefined;\n    }\n\n    discard(): void {\n        this._safety.tryCatch(() => {\n            this._stopReason = this._stopReason || stopReason.discarded;\n            this.stop();\n        });\n    }\n\n    terminate(): void {\n        this._safety.tryCatch(() => {\n            this._stopReason = this._stopReason || stopReason.terminated;\n            this.stop();\n        });\n    }\n\n    getIsSampled(): boolean {\n        return this._isSampled || false;\n    }\n\n    protected _getDetail(\n        userSchemaOrText: Schema | string,\n        userData: SchematizedData\n    ): ActivityDetail {\n        return {\n            id: this._id,\n            rootId: this._rootId,\n            name: this._name,\n            userSchemaOrText: userSchemaOrText,\n            userData,\n            stopReason: this._stopReason,\n            startTimestamp: this._startTimestamp,\n            startPerfTime: this._startPerfTime,\n            stopPerfTime: this._stopPerfTime,\n            errorCount: this._errorCount,\n            isSampled: this.getIsSampled()\n        };\n    }\n\n    public getTraceHeaders(options: TracingHeadersOptions): Record<string, string> {\n        // Normally, the root activity ID is the traceId.\n        // If the activity is root, it's ID is (also) the traceId.\n        // If the activity has no root, it's ID is (also) the traceId. i.e. It creates its own trace.\n        const spanId = this.id;\n        const traceId = this._rootId || spanId;\n\n        return Tracing.getHeaders(traceId, spanId, this.getIsSampled(), options);\n    }\n\n    getStartTimestamp(): number {\n        return this._startTimestamp;\n    }\n\n    getStartPerfTime(): number {\n        return this._startPerfTime;\n    }\n\n    getStopPerfTime(): number {\n        return this._stopPerfTime;\n    }\n}\n","export const activity={namespace:\"sf.instrumentation\",name:\"Activity\",pbjsSchema:{\"nested\":{\"sf\":{\"nested\":{\"instrumentation\":{\"nested\":{\"Activity\":{\"reserved\":[[5,5],[7,7]],\"fields\":{\"duration\":{\"options\":{},\"id\":3,\"type\":\"double\"},\"stopReason\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"isRoot\":{\"options\":{},\"id\":8,\"type\":\"bool\"},\"name\":{\"options\":{\"(meta.max_length)\":25},\"id\":2,\"type\":\"string\"},\"isSampled\":{\"options\":{},\"id\":11,\"type\":\"bool\"},\"preRootId\":{\"options\":{},\"id\":9,\"type\":\"string\"},\"id\":{\"options\":{},\n\"id\":1,\"type\":\"string\"},\"userPayload\":{\"options\":{},\"id\":4,\"type\":\"Payload\"},\"errorCount\":{\"options\":{},\"id\":10,\"type\":\"uint32\"}}},\"Payload\":{\"fields\":{\"payload\":{\"options\":{},\"id\":2,\"type\":\"bytes\"},\"schemaName\":{\"options\":{},\"id\":1,\"type\":\"string\"}}}}}}}}}};","export const error={namespace:\"sf.instrumentation\",name:\"Error\",pbjsSchema:{\"nested\":{\"sf\":{\"nested\":{\"instrumentation\":{\"nested\":{\"Error\":{\"reserved\":[[5,5],[7,7]],\"fields\":{\"activityId\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"stack\":{\"options\":{},\"id\":3,\"type\":\"string\"},\"name\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"message\":{\"options\":{\"(meta.max_length)\":200},\"id\":2,\"type\":\"string\"},\"userPayload\":{\"options\":{},\"id\":4,\"type\":\"Payload\"}}},\"Payload\":{\"fields\":{\"payload\":{\"options\":{},\"id\":2,\"type\":\"bytes\"},\n\"schemaName\":{\"options\":{},\"id\":1,\"type\":\"string\"}}}}}}}}}};","export const instrumented_event={namespace:\"sf.instrumentation\",name:\"InstrumentedEvent\",pbjsSchema:{\"nested\":{\"sf\":{\"nested\":{\"instrumentation\":{\"nested\":{\"MouseEvent\":{\"fields\":{\"cancelable\":{\"options\":{},\"id\":5,\"type\":\"bool\"},\"ctrlKey\":{\"options\":{},\"id\":9,\"type\":\"bool\"},\"type\":{\"options\":{},\"id\":25,\"type\":\"string\"},\"button\":{\"options\":{},\"id\":3,\"type\":\"uint32\"},\"offsetX\":{\"options\":{},\"id\":17,\"type\":\"uint32\"},\"eventPhase\":{\"options\":{},\"id\":12,\"type\":\"uint32\"},\"shiftKey\":{\"options\":{},\"id\":23,\n\"type\":\"bool\"},\"offsetY\":{\"options\":{},\"id\":18,\"type\":\"uint32\"},\"composed\":{\"options\":{},\"id\":8,\"type\":\"bool\"},\"altKey\":{\"options\":{},\"id\":1,\"type\":\"bool\"},\"isTrusted\":{\"options\":{},\"id\":13,\"type\":\"bool\"},\"buttons\":{\"options\":{},\"id\":4,\"type\":\"uint32\"},\"movementY\":{\"options\":{},\"id\":16,\"type\":\"uint32\"},\"clientY\":{\"options\":{},\"id\":7,\"type\":\"uint32\"},\"clientX\":{\"options\":{},\"id\":6,\"type\":\"uint32\"},\"movementX\":{\"options\":{},\"id\":15,\"type\":\"uint32\"},\"defaultPrevented\":{\"options\":{},\"id\":10,\"type\":\"bool\"},\n\"metaKey\":{\"options\":{},\"id\":14,\"type\":\"bool\"},\"timeStamp\":{\"options\":{},\"id\":24,\"type\":\"double\"},\"bubbles\":{\"options\":{},\"id\":2,\"type\":\"bool\"},\"detail\":{\"options\":{},\"id\":11,\"type\":\"int64\"},\"pageY\":{\"options\":{},\"id\":20,\"type\":\"uint32\"},\"pageX\":{\"options\":{},\"id\":19,\"type\":\"uint32\"},\"screenX\":{\"options\":{},\"id\":21,\"type\":\"uint32\"},\"screenY\":{\"options\":{},\"id\":22,\"type\":\"uint32\"}}},\"InstrumentedEvent\":{\"oneofs\":{\"event\":{\"oneof\":[\"mouseEvent\"]}},\"reserved\":[[4,4],\"xpath\",[6,6],[8,8]],\"fields\":{\"mouseEvent\":{\"options\":{},\n\"id\":7,\"type\":\"MouseEvent\"},\"auto\":{\"options\":{},\"id\":3,\"type\":\"bool\"},\"parentComponent\":{\"options\":{},\"id\":2,\"type\":\"string\"},\"ownerComponent\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"userPayload\":{\"options\":{},\"id\":5,\"type\":\"Payload\"},\"simplePath\":{\"options\":{},\"id\":9,\"type\":\"string\"}}},\"Payload\":{\"fields\":{\"payload\":{\"options\":{},\"id\":2,\"type\":\"bytes\"},\"schemaName\":{\"options\":{},\"id\":1,\"type\":\"string\"}}}}}}}}}};","export const simple={namespace:\"sf.instrumentation\",name:\"Simple\",pbjsSchema:{\"nested\":{\"sf\":{\"nested\":{\"instrumentation\":{\"nested\":{\"Simple\":{\"options\":{\"(meta.msg.desc)\":\"This message is used internally to allow convenient logging of simple text via the API without requiring a schema.\"},\"fields\":{\"text\":{\"options\":{\"(meta.max_length)\":25},\"id\":1,\"type\":\"string\"}}}}}}}}}};","import { Activity, TracingHeadersOptions } from '../interfaces';\n\nconst id: string = new Array(16).fill(0).join('');\nclass ActivityNoOp implements Activity {\n    getId(): string {\n        return id;\n    }\n    getRootId(): string {\n        return undefined;\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    error(): void {}\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    stop(): void {}\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    discard(): void {}\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    terminate(): void {}\n\n    getIsSampled(): boolean {\n        return false;\n    }\n    getTraceHeaders(__options: TracingHeadersOptions): Record<string, string> {\n        return {};\n    }\n    getStartTimestamp(): number {\n        return undefined;\n    }\n    getStartPerfTime(): number {\n        return undefined;\n    }\n    getStopPerfTime(): number {\n        return undefined;\n    }\n}\n\nexport const activityNoOp = Object.freeze(new ActivityNoOp());\n","import { SchematizedPayload } from '../interfaces';\nimport { InstrumentedEventData, MouseEventData } from '../interfaces-private';\nimport { DomEventData } from '../types/TypeDefinitions-Private';\nimport { schemaUtil, utility } from 'o11y/shared';\n\nexport class DomEventHelpers {\n    getInstrumentedEventData(\n        eventData: DomEventData,\n        handledBy: HTMLElement,\n        userPayload: SchematizedPayload\n    ): InstrumentedEventData {\n        const instrumentedEvent: InstrumentedEventData = {\n            ownerComponent: handledBy.tagName,\n            parentComponent:\n                (handledBy.parentElement && handledBy.parentElement.tagName) || undefined,\n            event: eventData,\n            simplePath: utility.getXpath(handledBy)\n        };\n\n        if (userPayload) {\n            instrumentedEvent.userPayload = schemaUtil.makePayload(\n                userPayload.schema,\n                userPayload.payload,\n                true\n            );\n        }\n\n        return instrumentedEvent;\n    }\n\n    getMouseEventData(e: MouseEvent): MouseEventData {\n        return {\n            altKey: e.altKey,\n            bubbles: e.bubbles,\n            button: e.button,\n            buttons: e.buttons,\n            cancelable: e.cancelable,\n            clientX: e.clientX,\n            clientY: e.clientY,\n            composed: e.composed,\n            defaultPrevented: e.defaultPrevented,\n            detail: e.detail,\n            eventPhase: e.eventPhase,\n            isTrusted: e.isTrusted,\n            timeStamp: e.timeStamp,\n            type: e.type,\n            ctrlKey: e.ctrlKey,\n            metaKey: e.metaKey,\n            movementX: e.movementX,\n            movementY: e.movementY,\n            offsetX: e.offsetX,\n            offsetY: e.offsetY,\n            pageX: e.pageX,\n            pageY: e.pageY,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            shiftKey: e.shiftKey\n        };\n    }\n}\n\nconst singleton = new DomEventHelpers();\nexport const domEventHelpers = singleton;\n","import { IType, Schema, SchemaTokens } from '../interfaces';\nimport { PbjsNestedObjectDescriptor, SchematizedData, SchematizedDataValue, schemaUtil, utility } from 'o11y/shared';\n\n// These are temporary fields, the max value should be specified as an option on the schema. We may\n// keep some default values like this in the future\nconst maxFieldLength = 10000;\nconst minFieldLength = 0;\n\nconst maxFourBytesPos = 2147483647;\nconst maxFourBytesNeg = -2147483648;\nconst maxFourBytesUnsigned = 4294967295;\nconst maxEightBytesPos = 9223372036854776000;\nconst maxEightBytesNeg = -9223372036854776001;\nconst maxEightBytesUnsigned = 18446744073709552000;\n\nclass LogValidator {\n    public validate(schema: Schema, data: SchematizedData): void {\n        const schemaTokens: SchemaTokens = schemaUtil.checkSchema(schema);\n        utility.requireArgument(data, 'data', 'object');\n\n        const nestedSchema: PbjsNestedObjectDescriptor = schemaUtil.getTypes(schema);\n        const errorMessage = this.validateFields(\n            data,\n            nestedSchema[schemaTokens.message] as IType,\n            nestedSchema,\n            schemaUtil.getSchemaId(schema)\n        );\n\n        if (errorMessage) {\n            throw new Error(errorMessage);\n        }\n    }\n\n    private validateFields(\n        data: SchematizedData,\n        message: IType,\n        custom: PbjsNestedObjectDescriptor,\n        schemaId: string\n    ): string {\n        const oneofs = message.oneofs || {};\n        const fields = message.fields || {};\n        let errorMessage = undefined;\n        for (const key in data) {\n            const value = data[key];\n            if (!this.isNullOrUndefinedOrEmpty(value)) {\n                // if it's null or undefined we don't need to match\n                if (oneofs[key]) {\n                    errorMessage = this.matchFieldTypes(\n                        value,\n                        oneofs[key].oneof[0],\n                        custom,\n                        schemaId,\n                        key\n                    );\n                } else if (fields[key]) {\n                    errorMessage = this.matchFieldTypes(\n                        value,\n                        fields[key].type,\n                        custom,\n                        schemaId,\n                        key,\n                        fields[key].rule\n                    );\n                }\n                // if the field is not present in the schema then we ignore it and will drop it later\n            }\n            if (errorMessage) {\n                return errorMessage;\n            }\n        }\n        return undefined;\n    }\n\n    private isNullOrUndefinedOrEmpty(val: SchematizedDataValue): boolean {\n        return val === undefined || val === null || val === '';\n    }\n\n    private matchFieldTypes(\n        fieldData: SchematizedDataValue,\n        fieldType: string,\n        descriptor: PbjsNestedObjectDescriptor,\n        schemaId: string,\n        key: string,\n        rule?: string\n    ): string {\n        let convertedSchemaType;\n        // this field can generically track specific conditions for each type\n        let extraContext = undefined;\n        if (rule === 'repeated') {\n            let errorMessage = undefined;\n            if (Array.isArray(fieldData)) {\n                for (const index in fieldData) {\n                    // if it's repeated they should all be the same type so we can just run it as is\n                    errorMessage = this.matchFieldTypes(\n                        fieldData[index],\n                        fieldType,\n                        descriptor,\n                        schemaId,\n                        key\n                    );\n                    if (errorMessage) {\n                        // we should fail if any values are not validated\n                        break;\n                    }\n                }\n            } else {\n                errorMessage = `Schema ${schemaId} on field: ${key}, repeated field should be an array`;\n            }\n            // this means that every value in the array was validated and we can finish\n            return errorMessage;\n        }\n        switch (fieldType) {\n            case 'string':\n                convertedSchemaType = 'string';\n                break;\n            case 'bytes':\n                convertedSchemaType = 'object';\n                if (!(fieldData instanceof Uint8Array)) {\n                    extraContext = `Schema ${schemaId} on field: ${key}, bytes array is malformed`;\n                }\n                break;\n            case 'bool':\n                convertedSchemaType = 'boolean';\n                break;\n            case 'uint32':\n                convertedSchemaType = 'number';\n                extraContext = this.checkNumberRange(\n                    fieldData,\n                    maxFourBytesUnsigned,\n                    0,\n                    schemaId,\n                    key\n                );\n                break;\n            case 'int32':\n            case 'sint32':\n            case 'fixed32':\n            case 'sfixed32':\n                convertedSchemaType = 'number';\n                extraContext = this.checkNumberRange(\n                    fieldData,\n                    maxFourBytesPos,\n                    maxFourBytesNeg,\n                    schemaId,\n                    key\n                );\n                break;\n            case 'uint64':\n                convertedSchemaType = 'number';\n                extraContext = this.checkNumberRange(\n                    fieldData,\n                    maxEightBytesUnsigned,\n                    0,\n                    schemaId,\n                    key\n                );\n                break;\n            case 'fixed64':\n            case 'sfixed64':\n            case 'int64':\n            case 'sint64':\n                convertedSchemaType = 'number';\n                extraContext = this.checkNumberRange(\n                    fieldData,\n                    maxEightBytesPos,\n                    maxEightBytesNeg,\n                    schemaId,\n                    key\n                );\n                break;\n            case 'double':\n            case 'float':\n                convertedSchemaType = 'number';\n                if (!Number.isFinite(fieldData)) {\n                    extraContext = `Schema ${schemaId} on field: ${key}. Value must be finite`;\n                }\n                break;\n            default:\n                const ref: Record<string, string> = {};\n                const keys = Object.keys(descriptor);\n                for (const x in keys) {\n                    ref[keys[x].toLowerCase()] = keys[x];\n                }\n                if (ref[fieldType.toLowerCase()]) {\n                    //now we check this schema\n                    extraContext = this.validateFields(\n                        fieldData,\n                        descriptor[ref[fieldType.toLowerCase()]] as IType,\n                        descriptor,\n                        schemaId\n                    );\n                    convertedSchemaType = 'object';\n                }\n                break;\n        }\n\n        const fieldLength = (fieldData + '').length;\n        if (typeof fieldData !== convertedSchemaType) {\n            return `Schema ${schemaId} on field: ${key}. Expected type ${fieldType} but received type ${typeof fieldData}`;\n        } else if (fieldLength < minFieldLength || fieldLength > maxFieldLength) {\n            return `Schema ${schemaId} on field: ${key}, exceeded maximum or minimum field length`;\n        } else if (extraContext) {\n            return extraContext;\n        }\n        return undefined;\n    }\n\n    private checkNumberRange(\n        value: number,\n        max: number,\n        min: number,\n        schemaId: string,\n        key: string\n    ): string {\n        if (value > max || value < min) {\n            return `Schema ${schemaId} on field: ${key}, number value is too large or small`;\n        }\n        return undefined;\n    }\n}\n\nexport const logValidator = new LogValidator();\n","import { Metric } from '../interfaces/Metric';\nimport { UpCounter } from '../interfaces/UpCounter';\nimport { MetricsTags, utility } from 'o11y/shared';\n\nexport class UpCounterImpl implements Metric<number>, UpCounter {\n    private readonly _createdOn: number;\n    private _lastUpdatedOn: number;\n    private _value = 0;\n\n    constructor(\n        private readonly _name: string,\n        private readonly _ownerName: string,\n        private readonly _ownerAppName: string,\n        private readonly _tags: MetricsTags\n    ) {\n        this._createdOn = utility.time().tsNow;\n    }\n\n    getName(): string {\n        return this._name;\n    }\n\n    getCreatedOn(): number {\n        return this._createdOn;\n    }\n\n    getLastUpdatedOn(): number {\n        return this._lastUpdatedOn;\n    }\n\n    getData(): number {\n        return this._value;\n    }\n\n    increment(value = 1): void {\n        if (typeof value === 'number' && value > 0) {\n            this._value += Math.round(value);\n            this._lastUpdatedOn = utility.time().tsNow;\n            return;\n        }\n\n        throw new Error('UpCounter can only increment positive numbers.');\n    }\n\n    reset(): void {\n        this._lastUpdatedOn = undefined;\n        this._value = 0;\n    }\n\n    getOwnerName(): string {\n        return this._ownerName;\n    }\n\n    getOwnerAppName(): string {\n        return this._ownerAppName;\n    }\n\n    getTags(): Readonly<MetricsTags> {\n        return this._tags;\n    }\n}\n","import { Metric } from '../interfaces/Metric';\nimport { ValueRecorder } from '../interfaces/ValueRecorder';\nimport { MetricsTags, utility } from 'o11y/shared';\n\nexport class ValueRecorderImpl implements Metric<number[]>, ValueRecorder {\n    private readonly _createdOn: number;\n    private _lastUpdatedOn: number;\n    private _values = new Array<number>();\n\n    constructor(\n        private readonly _name: string,\n        private readonly _ownerName: string,\n        private readonly _ownerAppName: string,\n        private readonly _tags: MetricsTags\n    ) {\n        this._createdOn = utility.time().tsNow;\n        // TODO: Add sampling/throttling to put a cap on the size of the array\n    }\n\n    getName(): string {\n        return this._name;\n    }\n\n    getCreatedOn(): number {\n        return this._createdOn;\n    }\n\n    getLastUpdatedOn(): number {\n        return this._lastUpdatedOn;\n    }\n\n    getData(): number[] {\n        return this.values;\n    }\n\n    get values(): number[] {\n        return this._values.slice(0, this._values.length);\n    }\n\n    record(value: number): void {\n        if (typeof value === 'number') {\n            this._values.push(value);\n            this._lastUpdatedOn = utility.time().tsNow;\n            return;\n        }\n\n        throw new Error('ValueRecorder can only record numbers.');\n    }\n\n    reset(): void {\n        this._lastUpdatedOn = undefined;\n        this._values = [];\n    }\n\n    getOwnerName(): string {\n        return this._ownerName;\n    }\n\n    getOwnerAppName(): string {\n        return this._ownerAppName;\n    }\n\n    getTags(): MetricsTags {\n        return this._tags;\n    }\n}\n","export class SizeLimitedMap<K, V> {\n    private readonly _map = new Map<K, V>();\n\n    private _maxSize: number;\n    constructor(maxSize: number) {\n        if (typeof maxSize === 'number' && maxSize > 0) {\n            this._maxSize = Math.ceil(maxSize);\n            return;\n        }\n        throw new Error('maxSize must be a positive number');\n    }\n\n    get maxSize(): number {\n        return this._maxSize;\n    }\n\n    get(key: K): V {\n        return this._map.get(key);\n    }\n\n    has(key: K): boolean {\n        return this._map.has(key);\n    }\n\n    set(key: K, value: V): boolean {\n        if (this.has(key) || this._map.size < this.maxSize) {\n            this._map.set(key, value);\n            return true;\n        }\n        return false;\n    }\n\n    getElements(): V[] {\n        return Array.from(this._map.values());\n    }\n\n    clear(): void {\n        this._map.clear();\n    }\n}\n","import { MetricsReporter, UpCounter, ValueRecorder } from '../interfaces';\n\nimport { UpCounterImpl } from './UpCounterImpl';\nimport { ValueRecorderImpl } from './ValueRecorderImpl';\nimport { SizeLimitedMap } from './SizeLimitedMap';\nimport { MetricsTags } from 'o11y/shared';\n\nconst maxCounters = 1000;\nconst maxValueRecorders = 500;\n\nenum MetricType {\n    Counter,\n    Percentile\n}\n\nexport class MetricsImpl implements MetricsReporter {\n    private readonly _upCounters = new SizeLimitedMap<string, UpCounterImpl>(maxCounters);\n    private readonly _valueRecorders = new SizeLimitedMap<string, ValueRecorderImpl>(\n        maxValueRecorders\n    );\n\n    constructor(\n        private readonly _ownerName: string,\n        private readonly _getOwnerAppName: () => string\n    ) {}\n\n    incrementCounter(\n        operation: string,\n        increment: number,\n        hasError = false,\n        tags: MetricsTags = {}\n    ): void {\n        this._tagError(tags, hasError);\n        this._upCounter(operation, tags).increment(increment);\n    }\n\n    trackValue(operation: string, value: number, hasError = false, tags: MetricsTags = {}): void {\n        this._tagError(tags, hasError);\n        this._valueRecorder(operation, tags).record(value);\n    }\n\n    private _upCounter(name: string, tags: MetricsTags): UpCounter {\n        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Counter);\n        let instrument = this._upCounters.get(key);\n        if (!instrument) {\n            instrument = new UpCounterImpl(\n                name,\n                this._ownerName,\n                this._getOwnerAppName(),\n                sortedTags\n            );\n            if (!this._upCounters.set(key, instrument)) {\n                throw new Error(`Max size of ${maxCounters} exceeeded for UpCounters`);\n            }\n        }\n        return instrument;\n    }\n\n    private _valueRecorder(name: string, tags: MetricsTags): ValueRecorder {\n        const { key, sortedTags } = this._getKeyAndSortedTags(name, tags, MetricType.Percentile);\n        let instrument = this._valueRecorders.get(key);\n        if (!instrument) {\n            instrument = new ValueRecorderImpl(\n                name,\n                this._ownerName,\n                this._getOwnerAppName(),\n                sortedTags\n            );\n            if (!this._valueRecorders.set(key, instrument)) {\n                throw new Error(`Max size of ${maxValueRecorders} exceeeded for ValueRecorders`);\n            }\n        }\n        return instrument;\n    }\n\n    getUpCounters(): UpCounterImpl[] {\n        return this._upCounters.getElements();\n    }\n\n    getValueRecorders(): ValueRecorderImpl[] {\n        return this._valueRecorders.getElements();\n    }\n\n    private _tagError(tags: MetricsTags, hasError: boolean): void {\n        tags.status = hasError === true ? 'error' : 'success';\n    }\n\n    private _getKeyAndSortedTags(\n        operation: string,\n        tags: MetricsTags,\n        metricType: MetricType\n    ): { key: string; sortedTags: MetricsTags } {\n        // This method should be called after any manipulation of tags\n        const sortedTags = Object.keys(tags)\n            .sort()\n            .reduce((prev: MetricsTags, curr: string) => {\n                prev[curr] = tags[curr];\n                return prev;\n            }, {});\n        const key = `${MetricType[metricType]}:${operation}${JSON.stringify(sortedTags)}`;\n        return {\n            key,\n            sortedTags\n        };\n    }\n}\n","export class MockEvent {\n    constructor(\n        public readonly type: string,\n        public readonly composed: boolean,\n        private readonly _composedPaths: unknown[]\n    ) {}\n    composedPath(): unknown[] {\n        return this._composedPaths;\n    }\n}\n","import {\n    activitySchema,\n    errorSchema,\n    instrumentedEventSchema,\n    simpleSchema\n} from 'o11y_schema/sf_instrumentation';\n\nimport {\n    Activity,\n    ActivityDetail,\n    Instrumentation,\n    Metric,\n    MetricsReporter,\n    PayloadProvider,\n    Schema,\n    SchematizedPayload\n} from '../interfaces';\nimport { ActivityData, ErrorData, InstrumentedEventData } from '../interfaces-private';\n\nimport { ActivityImpl, discarded, onActivityError, onActivityStop } from './ActivityImpl';\nimport { activityNoOp } from './ActivityNoOp';\nimport { AutomaticClickTracker } from './AutomaticClickTracker';\nimport { domEventHelpers } from './DomEventHelpers';\nimport { logValidator } from './LogValidator';\nimport { MetricsImpl } from './MetricsImpl';\nimport { MockEvent } from './MockEvent';\nimport { NextgenImpl } from './NextgenImpl';\nimport { PublicSafety } from './PublicSafety';\nimport { LightningElement, MetricsTags, SchematizedData, schemaUtil, utility } from 'o11y/shared';\nimport { LogPromptListener } from 'src/shared/TypeDefinitions';\n\n// @W-10241440, disable timeouts\nconst maxActivityDurationMsecs: number = undefined;\nconst reservedMetricCharacters = ['`'];\nconst reservedMetricNames = {\n    internalError: 'o11y-error'\n};\nconst denyListMetricNames = Object.freeze(Array.from(Object.values(reservedMetricNames)));\n\nexport class InstrumentationImpl implements Instrumentation, MetricsReporter {\n    protected static readonly defaultAppName = 'APP_NOT_REGISTERED';\n    private readonly _metrics: MetricsImpl;\n    private readonly _onActivityStoppedCallback: onActivityStop =\n        this._handleActivityStop.bind(this);\n    protected readonly _onActivityErrorCallback: onActivityError =\n        this._handleActivityError.bind(this);\n    protected readonly _safety: PublicSafety;\n    private readonly _simpleTextMaxLength: number;\n\n    constructor(private readonly _nextGen: NextgenImpl, private readonly _name: string) {\n        for (const reservedChar of reservedMetricCharacters) {\n            if (this._name.indexOf(reservedChar) >= 0) {\n                throw new Error(`Name cannot include the reserved character \"${reservedChar}\"`);\n            }\n        }\n\n        this._safety = new PublicSafety({\n            increment: (increment) => this._incrementError(increment)\n        });\n\n        this._metrics = this._initMetrics();\n\n        const simpleTextOptions = schemaUtil.getOptions(simpleSchema, 'Simple', 'text');\n        this._simpleTextMaxLength = simpleTextOptions\n            ? simpleTextOptions['(meta.max_length)']\n            : Number.MAX_VALUE;\n    }\n\n    protected _initMetrics(): MetricsImpl {\n        return new MetricsImpl(\n            this.name,\n            () => this._nextGen.appName || InstrumentationImpl.defaultAppName\n        );\n    }\n\n    private _incrementError(increment = 1): void {\n        this._metrics.incrementCounter(reservedMetricNames.internalError, increment, false);\n    }\n\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * This function is to allow for convenience calls to our API, where a string can\n     * be provided instead of an actual Schema. In that case, we wrap the text in\n     * a built-in simple schema.\n     * @param userSchemaOrText Schema or string.\n     * @param userData\n     * @param onlyIfBoth If true, then both the schema and the data must be specified.\n     * @returns\n     */\n    protected _wrapUserPayload(\n        userSchemaOrText: Schema | string,\n        userData: SchematizedData,\n        onlyIfBoth = false\n    ): SchematizedPayload {\n        let userSchema: Schema;\n        if (typeof userSchemaOrText === 'string') {\n            userSchema = simpleSchema;\n            if (userSchemaOrText) {\n                userData = {\n                    text: userSchemaOrText.substr(0, this._simpleTextMaxLength)\n                };\n            } else {\n                userData = undefined;\n            }\n        } else {\n            userSchema = userSchemaOrText;\n        }\n\n        return schemaUtil.makePayload(userSchema, userData, onlyIfBoth);\n    }\n\n    /**\n     *\n     * @param userSchema The schema of the second argument. Also used as the basis for auto-generated\n     * counters for log calls using the same schema.\n     * @param userData Optional data that complies with the provided schema\n     */\n    log(userSchemaOrText: Schema | string, userData?: SchematizedData): void {\n        this._safety.tryCatch(() => {\n            const timestamp = utility.time().tsNow;\n            utility.requireArgument(userSchemaOrText, 'userSchemaOrText', ['object', 'string']);\n\n            const userPayload = this._wrapUserPayload(userSchemaOrText, userData);\n\n            if (userPayload && userPayload.payload) {\n                this._logInternal(\n                    this.name,\n                    userPayload.schema,\n                    userPayload.payload,\n                    timestamp,\n                    this._nextGen.getRootActivityId()\n                );\n            }\n        });\n    }\n\n    protected _logInternal(\n        loggerName: string,\n        schema: Schema,\n        data: SchematizedData,\n        timestamp: number,\n        rootId?: string\n    ): number {\n        this._checkInputs(schema, data);\n        const appPayload: SchematizedPayload = this._getPayloadFromProvider(\n            this._nextGen.appPayloadProvider\n        );\n        const pagePayload: SchematizedPayload = this._getPayloadFromProvider(\n            this._nextGen.pagePayloadProvider\n        );\n\n        return this._nextGen.addLog(\n            loggerName,\n            schema,\n            data,\n            timestamp,\n            rootId,\n            pagePayload,\n            appPayload\n        );\n    }\n\n    error(\n        error: Error | string,\n        userSchemaOrText?: Schema | string,\n        userData?: SchematizedData\n    ): void {\n        return this._safety.tryCatch(() =>\n            this._errorInternal(error, userSchemaOrText, userData, undefined)\n        );\n    }\n\n    protected _errorInternal(\n        error: Error | string,\n        userSchemaOrText?: Schema | string,\n        userData?: SchematizedData,\n        activityId?: string\n    ): number {\n        const loggedTimestamp = utility.time().tsNow;\n        utility.requireArgument(error, 'error', [Error, 'string']);\n\n        if (typeof error === 'string') {\n            error = new Error(error);\n        }\n\n        const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);\n\n        const errorData: ErrorData = {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n            userPayload,\n            activityId\n        };\n\n        return this._logInternal(\n            this.name,\n            errorSchema,\n            errorData,\n            loggedTimestamp,\n            this._nextGen.getRootActivityId()\n        );\n    }\n\n    startActivity(name: string): Activity {\n        return this._safety.tryCatchReturn(() => {\n            utility.requireArgument(name, 'name');\n\n            const activity: Activity = new ActivityImpl(\n                name,\n                this._nextGen.getRootActivityId(),\n                this._onActivityStoppedCallback,\n                this._onActivityErrorCallback,\n                maxActivityDurationMsecs,\n                undefined,\n                // By definition, an activity is sampled if root activity is sampled\n                this._nextGen.isRootActivitySampled()\n            );\n            return activity;\n        }, activityNoOp);\n    }\n\n    protected _getActivityData(detail: ActivityDetail): ActivityData {\n        const userPayload = this._wrapUserPayload(detail.userSchemaOrText, detail.userData, true);\n\n        return {\n            id: detail.id,\n            name: detail.name,\n            duration: detail.stopPerfTime - detail.startPerfTime,\n            stopReason: detail.stopReason,\n            userPayload,\n            errorCount: detail.errorCount,\n            isSampled: detail.isSampled\n        };\n    }\n\n    private _handleActivityStop(detail: ActivityDetail): void {\n        if (detail.stopReason === discarded) {\n            return;\n        }\n        const activityData: ActivityData = this._getActivityData(detail);\n\n        this._logActivity(activityData, detail.startTimestamp, detail.rootId);\n    }\n\n    protected _logActivity(\n        activityData: ActivityData,\n        startTimestamp: number,\n        rootId?: string\n    ): void {\n        this._logInternal(this.name, activitySchema, activityData, startTimestamp, rootId);\n    }\n\n    private _handleActivityError(error: Error, detail: ActivityDetail): void {\n        this._errorInternal(error, detail.userSchemaOrText, detail.userData, detail.id);\n    }\n\n    private _getPayloadFromProvider(provider: PayloadProvider): SchematizedPayload {\n        if (provider) {\n            const payload: SchematizedPayload = provider.getPayload();\n            if (payload) {\n                this._checkInputs(payload.schema, payload.payload);\n                return payload;\n            }\n        }\n        return undefined;\n    }\n\n    domEvent(\n        event: Event,\n        handledBy: HTMLElement | LightningElement,\n        userSchemaOrText?: Schema | string,\n        userData?: SchematizedData,\n        auto?: boolean\n    ): void {\n        this._safety.tryCatch(() => {\n            const tsNow = utility.time().tsNow;\n\n            utility.requireArgument(event, 'event', [Event, MockEvent]);\n            // TODO: Using 'object' instead of 'LightningElement' for now (no imports)\n            utility.requireArgument(handledBy, 'handledBy', [HTMLElement, 'object']);\n\n            let htmlElement;\n            if (handledBy instanceof HTMLElement) {\n                htmlElement = handledBy;\n            } else {\n                handledBy = handledBy as LightningElement;\n                // Convenience for LightningElement developers who pass \"this\" in handledBy.\n                // Get the underlying HTML element\n                if (handledBy.template && handledBy.template.host instanceof HTMLElement) {\n                    htmlElement = handledBy.template.host;\n                } else {\n                    utility.requireArgument(undefined, 'handledBy');\n                }\n            }\n\n            const userPayload: SchematizedPayload = this._wrapUserPayload(\n                userSchemaOrText,\n                userData,\n                true\n            );\n\n            switch (event.type) {\n                case 'click': {\n                    const mouseEvent = event as MouseEvent;\n\n                    // If the user has called domEvent API on this event explicitly,\n                    // then we don't need to log it by default.\n                    const acd: AutomaticClickTracker = this._nextGen.getClickTracker();\n                    if (acd) {\n                        acd.markEventHandled(mouseEvent);\n                    }\n\n                    const mouseEventData = domEventHelpers.getMouseEventData(mouseEvent);\n\n                    const instrumentedEvent: InstrumentedEventData =\n                        domEventHelpers.getInstrumentedEventData(\n                            mouseEventData,\n                            htmlElement,\n                            userPayload\n                        );\n                    instrumentedEvent.auto = auto;\n\n                    this._logInternal(\n                        this.name,\n                        instrumentedEventSchema,\n                        instrumentedEvent,\n                        tsNow,\n                        this._nextGen.getRootActivityId()\n                    );\n                    break;\n                }\n                default:\n                    throw new Error(utility.notImplemented);\n            }\n        });\n    }\n\n    incrementCounter(\n        operation: string,\n        increment = 1,\n        hasError = false,\n        tags: MetricsTags = {}\n    ): void {\n        this._safety.tryCatch(() => {\n            utility.requireArgument(operation, 'operation', 'string');\n            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);\n            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);\n            utility.requireArgument(increment, 'increment', 'number');\n            utility.requireArgument(hasError, 'hasError', 'boolean');\n            utility.requireArgument(tags, 'tags', 'object');\n            Object.entries(tags).forEach((entry) => {\n                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [\n                    'string',\n                    'number',\n                    'boolean'\n                ]);\n            });\n            this._metrics.incrementCounter(operation, increment, hasError, tags);\n        });\n    }\n\n    trackValue(operation: string, value: number, hasError = false, tags: MetricsTags = {}): void {\n        this._safety.tryCatch(() => {\n            utility.requireArgument(operation, 'operation', 'string');\n            utility.checkForDenyListedValues(operation, 'operation', denyListMetricNames);\n            utility.checkForReservedCharacters(operation, 'operation', reservedMetricCharacters);\n            utility.requireArgument(value, 'value', 'number');\n            utility.requireArgument(hasError, 'hasError', 'boolean');\n            utility.requireArgument(tags, 'tags', 'object');\n            Object.entries(tags).forEach((entry) => {\n                utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, [\n                    'string',\n                    'number',\n                    'boolean'\n                ]);\n            });\n\n            this._metrics.trackValue(operation, value, hasError, tags);\n        });\n    }\n\n    private _checkInputs(schema: Schema, data: SchematizedData): void {\n        schemaUtil.checkSchema(schema);\n        utility.requireArgument(data, 'data', 'object');\n\n        // TODO: Protobuf-free Validation.\n        // Until then, do a best-case effort.\n        let savedUserPayload: SchematizedPayload;\n        if (data.userPayload !== undefined && schemaUtil.isInternal(schema)) {\n            savedUserPayload = data.userPayload;\n            logValidator.validate(savedUserPayload.schema, savedUserPayload.payload);\n            // userPayload needs to be temporarily removed, since it's not yet encoded.\n            data.userPayload = undefined;\n        }\n        logValidator.validate(schema, data);\n        if (savedUserPayload !== undefined) {\n            // Restore userPayload\n            data.userPayload = savedUserPayload;\n        }\n    }\n\n    getUpCounters(): Metric<number>[] {\n        return this._metrics.getUpCounters().filter((m) => m.getLastUpdatedOn());\n    }\n\n    getValueRecorders(): Metric<number[]>[] {\n        return this._metrics.getValueRecorders().filter((m) => m.getLastUpdatedOn());\n    }\n\n    registerForLogPrompt(listener: LogPromptListener): void {\n        utility.requireArgument(listener, 'listener', 'function');\n        this._nextGen.registerForLogPrompt(listener);\n    }\n}\n","import { RootActivity, Schema } from '../interfaces';\nimport { ActivityDetail } from '../interfaces/ActivityDetail';\nimport { ActivityImpl, onActivityError, onActivityStop } from './ActivityImpl';\nimport { SchematizedData, utility } from 'o11y/shared';\n\nexport class RootActivityImpl extends ActivityImpl implements RootActivity {\n    constructor(\n        name: string,\n        onStopped: onActivityStop,\n        onError: onActivityError,\n        rootId?: string,\n        _isSampled?: boolean\n    ) {\n        super(\n            name,\n            undefined,\n            onStopped,\n            onError,\n            undefined,\n            rootId || utility.generateUniqueId(32),\n            _isSampled\n        );\n    }\n\n    private _preRootId: string;\n    get preRootId(): string {\n        return this._preRootId;\n    }\n    set preRootId(value: string) {\n        this._preRootId = value;\n    }\n\n    protected _getDetail(userSchema: Schema, userData: SchematizedData): ActivityDetail {\n        const detail = super._getDetail(userSchema, userData);\n        detail.isRoot = true;\n        detail.preRootId = this.preRootId;\n        return detail;\n    }\n}\n","import { RootActivity, TracingHeadersOptions } from '../interfaces';\n\nconst rootId: string = new Array(32).fill(0).join('');\nclass RootActivityNoOp implements RootActivity {\n    getId(): string {\n        return rootId;\n    }\n    getRootId(): string {\n        return undefined;\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    error(): void {}\n\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    stop(): void {}\n\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    discard(): void {}\n\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    terminate(): void {}\n\n    getIsSampled(): boolean {\n        return false;\n    }\n    getTraceHeaders(__options: TracingHeadersOptions): Record<string, string> {\n        return {};\n    }\n    getStartTimestamp(): number {\n        return undefined;\n    }\n    getStartPerfTime(): number {\n        return undefined;\n    }\n    getStopPerfTime(): number {\n        return undefined;\n    }\n}\n\nexport const rootActivityNoOp = Object.freeze(new RootActivityNoOp());\n","import { ActivityDetail, RootActivity } from '../interfaces';\nimport { ActivityData } from '../interfaces-private';\nimport { discarded, onActivityStop } from './ActivityImpl';\nimport { InstrumentationImpl } from './InstrumentationImpl';\nimport { RootActivityImpl } from './RootActivityImpl';\nimport { rootActivityNoOp } from './RootActivityNoOp';\nimport { utility } from 'o11y/shared';\nimport { MetricsImpl } from './MetricsImpl';\n\nexport class AppInstrumentationImpl extends InstrumentationImpl {\n    private rootActivity: RootActivityImpl;\n\n    private readonly _onRootActivityStoppedCallback: onActivityStop =\n        this.handleRootActivityStop.bind(this);\n\n    startRootActivity(name: string, rootId?: string, isSampled?: boolean): RootActivity {\n        return this._safety.tryCatchReturn(() => {\n            utility.requireArgument(name, 'name');\n\n            const newRootActivity = new RootActivityImpl(\n                name,\n                this._onRootActivityStoppedCallback,\n                this._onActivityErrorCallback,\n                rootId,\n                isSampled\n            );\n\n            if (this.rootActivity && !this.rootActivity.isStopped) {\n                const preRootId = this.rootActivity.getId();\n                this.rootActivity.terminate();\n                newRootActivity.preRootId = preRootId;\n            }\n            this.rootActivity = newRootActivity;\n\n            return this.rootActivity as RootActivity;\n        }, rootActivityNoOp);\n    }\n\n    private handleRootActivityStop(detail: ActivityDetail): void {\n        if (detail.stopReason === discarded) {\n            return;\n        }\n\n        const activityData: ActivityData = this._getActivityData(detail);\n\n        this._logActivity(activityData, detail.startTimestamp);\n        this.rootActivity = undefined;\n    }\n\n    protected _getActivityData(detail: ActivityDetail): ActivityData {\n        const activityData: ActivityData = super._getActivityData(detail);\n        activityData.isRoot = detail.isRoot;\n        activityData.preRootId = detail.preRootId;\n        return activityData;\n    }\n\n    getRootActivityId(): string {\n        return this.rootActivity && this.rootActivity.getId();\n    }\n\n    isRootActivitySampled(): boolean {\n        return this.rootActivity && this.rootActivity.getIsSampled();\n    }\n\n    protected _initMetrics(): MetricsImpl {\n        return new MetricsImpl(this.name, () => this.name);\n    }\n}\n","import { Instrumentation } from '../interfaces';\nimport { utility } from 'o11y/shared';\n\nconst pathLimit = 5;\n\nexport class AutomaticClickTracker {\n    private instr: Instrumentation;\n    private ignoredEvent: Event;\n    private isActive = false;\n    private document: Document;\n    private readonly _boundClickListener = this.clickListener.bind(this);\n\n    constructor(instrumentation: Instrumentation, document: Document) {\n        utility.requireArgument(instrumentation, 'instrumentation');\n        utility.requireArgument(document, 'document');\n\n        this.instr = instrumentation;\n        this.document = document;\n    }\n\n    activate(): void {\n        if (!this.isActive) {\n            this.document.addEventListener('click', this._boundClickListener, true);\n            this.isActive = true;\n        }\n    }\n\n    deactivate(): void {\n        if (this.isActive) {\n            this.document.removeEventListener('click', this._boundClickListener, true);\n            this.isActive = false;\n        }\n    }\n\n    markEventHandled(event: MouseEvent): void {\n        this.ignoredEvent = event;\n    }\n\n    private clickListener(event: MouseEvent): void {\n        let eventTargets: EventTarget[] = event.composedPath && event.composedPath();\n        if (!eventTargets || !eventTargets.length) {\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n            eventTargets = (event as any).path;\n        }\n        const handledBy: HTMLElement = this.getClickableElement(eventTargets);\n\n        if (handledBy) {\n            // Immediate\n            setTimeout(() => {\n                if (event !== this.ignoredEvent) {\n                    this.instr.domEvent(event, handledBy, undefined, undefined, true);\n                }\n            });\n        }\n    }\n\n    private getClickableElement(path: EventTarget[]): HTMLElement {\n        const limit = path ? Math.min(path.length, pathLimit) : 0;\n        for (let x = 0; x < limit; x += 1) {\n            const currentElement = path[x] as HTMLElement;\n            const tagName = currentElement.tagName && currentElement.tagName.toLowerCase();\n            if (tagName === 'a' || tagName === 'button') {\n                return currentElement;\n            }\n            if (tagName === 'input') {\n                const inputElement = currentElement as HTMLInputElement;\n                if (inputElement.type && inputElement.type.toLowerCase() === 'button') {\n                    return inputElement;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n","import {\n    BufferedLog,\n    Instrumentation,\n    InstrumentedAppMethods,\n    LogCollector,\n    LogMeta,\n    Metric,\n    MetricsCollector,\n    Nextgen,\n    PayloadProvider,\n    Schema,\n    SchematizedPayload\n} from '../interfaces';\nimport { AppInstrumentationImpl } from './AppInstrumentationImpl';\nimport { AutomaticClickTracker } from './AutomaticClickTracker';\nimport { InstrumentationImpl } from './InstrumentationImpl';\nimport { Tracing } from './Tracing';\nimport { SchematizedData, utility } from 'o11y/shared';\nimport { LogCollectorOptions } from 'src/interfaces/LogCollectorOptions';\nimport { LogPromptListener } from 'src/shared/TypeDefinitions';\n\nconst maxInstrumentationLength = 80;\nconst truncatedText = '_CUT';\nconst maxInstrumentationLengthBeforeTruncated = maxInstrumentationLength - truncatedText.length;\n\nexport class NextgenImpl implements Nextgen {\n    private readonly _logCollectors = new Set<LogCollector>();\n    private readonly _instruments = new Map<string, InstrumentationImpl | AppInstrumentationImpl>();\n    private _sequence = 0;\n    private _appInstr: AppInstrumentationImpl;\n    private _autoClickTracker: AutomaticClickTracker;\n    private _metricsCollector: MetricsCollector;\n    private _appPayloadProvider: PayloadProvider;\n    private _pagePayloadProvider: PayloadProvider;\n    private _forceDisabledLogCollectors = new Set<LogCollector>();\n    private _logCollectorFailures = new Map<LogCollector, number>();\n    private static _collectorFailureLimit = 5;\n    private _isBufferingEnabled = false;\n    private _buffer: BufferedLog[] = [];\n    private readonly _logCollectionListeners = new Set<LogPromptListener>();\n\n    get pagePayloadProvider(): PayloadProvider {\n        return this._pagePayloadProvider;\n    }\n    set pagePayloadProvider(provider: PayloadProvider) {\n        this._pagePayloadProvider = provider;\n    }\n\n    get appPayloadProvider(): PayloadProvider {\n        return this._appPayloadProvider;\n    }\n    set appPayloadProvider(provider: PayloadProvider) {\n        this._appPayloadProvider = provider;\n    }\n\n    registerApp(name: string, enableBuffering?: boolean): InstrumentedAppMethods {\n        utility.requireArgument(name, 'name', 'string');\n        if (this._appInstr) {\n            throw new Error('An app has already been registered with instrumentation.');\n        }\n        const instr = this._instruments.get(name);\n        if (instr) {\n            throw new Error(`The instrumentation name ${name} is already taken`);\n        }\n        this._appInstr = new AppInstrumentationImpl(this, name);\n        this._instruments.set(name, this._appInstr);\n        this._isBufferingEnabled = enableBuffering;\n\n        const tracing = new Tracing(this._appInstr);\n\n        return {\n            log: this._appInstr.log.bind(this._appInstr),\n            error: this._appInstr.error.bind(this._appInstr),\n            startActivity: this._appInstr.startActivity.bind(this._appInstr),\n            domEvent: this._appInstr.domEvent.bind(this._appInstr),\n            incrementCounter: this._appInstr.incrementCounter.bind(this._appInstr),\n            trackValue: this._appInstr.trackValue.bind(this._appInstr),\n            networkInstrumentation: tracing.networkInstrumentation.bind(tracing),\n            registerForLogPrompt: this._appInstr.registerForLogPrompt.bind(this._appInstr),\n\n            startRootActivity: this._appInstr.startRootActivity.bind(this._appInstr),\n            registerLogCollector: this.registerLogCollector.bind(this),\n            registerMetricsCollector: this.registerMetricsCollector.bind(this),\n            activateClickTracker: this.activateClickTracker.bind(this),\n            deactivateClickTracker: this.deactivateClickTracker.bind(this),\n            disableBuffering: this.disableBuffering.bind(this),\n            promptLogCollection: this.promptLogCollection.bind(this)\n        };\n    }\n\n    getInstrumentation(name: string): Instrumentation {\n        utility.requireArgument(name, 'name', 'string');\n        if (name.length > maxInstrumentationLength) {\n            // don't throw if it's too long. just add truncated suffix, but stay within max length\n            name = name.substr(0, maxInstrumentationLengthBeforeTruncated) + truncatedText;\n        }\n        let instr: InstrumentationImpl | AppInstrumentationImpl = this._instruments.get(name);\n        if (!instr) {\n            instr = new InstrumentationImpl(this, name);\n            this._instruments.set(name, instr);\n        } else if (instr === this._appInstr) {\n            throw new Error(`The instrumentation name ${name} is being used by the app.`);\n        }\n        return instr;\n    }\n\n    get appName(): string {\n        return this._appInstr && this._appInstr.name;\n    }\n\n    // This is an internal method that needs to be public\n    addLog(\n        loggerName: string,\n        schema: Schema,\n        data: SchematizedData,\n        timestamp: number,\n        rootId: string,\n        pagePayload: SchematizedPayload,\n        appPayload: SchematizedPayload\n    ): number {\n        this._sequence += 1;\n        const sequence: number = this._sequence;\n        const loggerAppName: string = this.appName;\n        const connectionType: string = utility.getConnectionType();\n        const logMeta: LogMeta = {\n            timestamp,\n            rootId,\n            sequence,\n            loggerName,\n            pagePayload,\n            appPayload,\n            loggerAppName,\n            connectionType\n        };\n\n        if (this._isBufferingEnabled) {\n            // Always push to the buffer, even if no eligible collectors\n            this._buffer.push({ schema, data: utility.clone(data), logMeta });\n        }\n\n        const eligibleCollectors: LogCollector[] = Array.from(this._logCollectors).filter(\n            (collector: LogCollector) =>\n                !this._forceDisabledLogCollectors.has(collector) &&\n                !(collector.getIsCollectDisabled && collector.getIsCollectDisabled())\n        );\n\n        if (eligibleCollectors.length > 0) {\n            for (const collector of eligibleCollectors) {\n                // Make a copy of the aguments passed to the collectors lest they change them.\n                const dataClone: SchematizedData = utility.clone(data);\n                let failures: number = this._logCollectorFailures.get(collector) || 0;\n\n                try {\n                    collector.collect(schema, dataClone, logMeta);\n                    // if it got here it means it succeeded/didn't throw so we want to decrement the failure count\n                    if (failures > 0) {\n                        this._logCollectorFailures.set(collector, failures - 1);\n                    }\n                } catch (err) {\n                    failures += 1;\n                    // If a collector fails too much we just disable it\n                    if (failures >= NextgenImpl._collectorFailureLimit) {\n                        this._forceDisabledLogCollectors.add(collector);\n                        if (this._appInstr && (typeof err === 'string' || err instanceof Error)) {\n                            this._appInstr.error(err);\n                        }\n                    } else {\n                        this._logCollectorFailures.set(collector, failures);\n                        // We can't log an error  here, or the same collector will immediately be called\n                        // again, likely resulting in repeat exceptions until the collector gets disabled.\n                    }\n                }\n            }\n        }\n        return this._sequence;\n    }\n\n    getBuffer(): BufferedLog[] {\n        return this._buffer;\n    }\n\n    disableBuffering(): void {\n        this._isBufferingEnabled = false;\n        this._buffer = [];\n    }\n\n    getClickTracker(): AutomaticClickTracker {\n        return this._autoClickTracker;\n    }\n\n    getRootActivityId(): string {\n        return this._appInstr && this._appInstr.getRootActivityId();\n    }\n\n    isRootActivitySampled(): boolean {\n        return this._appInstr && this._appInstr.isRootActivitySampled();\n    }\n\n    activateClickTracker(): void {\n        if (!this._autoClickTracker) {\n            this._autoClickTracker = new AutomaticClickTracker(this._appInstr, window.document);\n        }\n        this._autoClickTracker.activate();\n    }\n\n    deactivateClickTracker(): void {\n        if (this._autoClickTracker) {\n            this._autoClickTracker.deactivate();\n            // In case activateClickTracker is called later with a different instrumentation\n            this._autoClickTracker = undefined;\n        }\n    }\n\n    registerLogCollector(collector: LogCollector, options?: LogCollectorOptions): void {\n        utility.requireArgument(collector, 'collector');\n        if (this._logCollectors.has(collector)) {\n            return;\n        }\n        this._logCollectors.add(collector);\n        this._logCollectorFailures.set(collector, 0);\n        if (\n            (!collector.getIsCollectDisabled || !collector.getIsCollectDisabled()) &&\n            options &&\n            options.retroactive\n        ) {\n            for (const log of this._buffer) {\n                collector.collect(log.schema, log.data, log.logMeta);\n            }\n        }\n    }\n\n    registerMetricsCollector(collector: MetricsCollector): void {\n        utility.requireArgument(collector, 'collector');\n        if (this._metricsCollector) {\n            throw new Error('A metrics Collector is already registered.');\n        }\n        this._metricsCollector = collector;\n        this._metricsCollector.receiveMetricsExtractors({\n            getAllUpCounters: this.getAllUpCounters.bind(this),\n            getAllValueRecorders: this.getAllValueRecorders.bind(this)\n        });\n    }\n\n    private getAllUpCounters(): Metric<number>[] {\n        const arrOfArrs = Array.from(this._instruments.values()).map((instr) =>\n            instr.getUpCounters()\n        );\n        return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);\n    }\n\n    private getAllValueRecorders(): Metric<number[]>[] {\n        const arrOfArrs = Array.from(this._instruments.values()).map((instr) =>\n            instr.getValueRecorders()\n        );\n        return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);\n    }\n\n    registerForLogPrompt(listener: LogPromptListener): void {\n        this._logCollectionListeners.add(listener);\n    }\n\n    promptLogCollection(reason: string): void {\n        for (const listener of this._logCollectionListeners.keys()) {\n            try {\n                listener(reason);\n            } catch {\n                // Ignore\n            }\n        }\n    }\n}\n","import { Instrumentation, InstrumentedAppMethods, InstrumentedAppOptions } from './interfaces';\nimport { NextgenImpl } from './library/NextgenImpl';\nimport { utility } from 'o11y/shared';\n\nclass Index {\n    private _nextgen: NextgenImpl;\n    // We are lazily initializing the singleton to allow any options to be processed\n    // before the instantiation.\n    private get _lazyNextGen(): NextgenImpl {\n        if (!this._nextgen) {\n            this._nextgen = new NextgenImpl();\n        }\n        return this._nextgen;\n    }\n\n    public registerInstrumentedApp(\n        name: string,\n        options?: InstrumentedAppOptions\n    ): InstrumentedAppMethods {\n        if (options && options.isProduction) {\n            // Do this before construction\n            utility.markProduction();\n        }\n        const retVal: InstrumentedAppMethods = this._lazyNextGen.registerApp(\n            name,\n            options && options.enableBuffering\n        );\n        if (options) {\n            this._nextgen.appPayloadProvider = options.appPayloadProvider;\n            this._nextgen.pagePayloadProvider = options.pagePayloadProvider;\n        }\n        return retVal;\n    }\n\n    public getInstrumentation(name?: string): Instrumentation {\n        return this._lazyNextGen.getInstrumentation(name);\n    }\n}\nconst index = new Index(); // singleton\nconst registerInstrumentedApp = index.registerInstrumentedApp.bind(index);\nconst getInstrumentation = index.getInstrumentation.bind(index);\nconst time = utility.time.bind(utility);\n\nexport { registerInstrumentedApp, getInstrumentation, time };\n","import { TaskerMulti, TaskerSingle } from '../interfaces/IdleDetector';\n\nexport type TaskDoneNotifier = () => void;\n\nexport class TaskerImpl implements TaskerSingle, TaskerMulti {\n    private _busyCount = 0;\n    private _isOk = true; // Once an error occurs, make operations no-op\n\n    get isBusy(): boolean {\n        return this._isOk ? this._busyCount > 0 : undefined;\n    }\n    constructor(\n        public readonly name: string,\n        initialCount: number,\n        private readonly _doneCallback: TaskDoneNotifier,\n        private readonly _overDoneCallback: TaskDoneNotifier\n    ) {\n        this._busyCount = initialCount;\n    }\n\n    add(): void {\n        if (this._isOk) {\n            this._busyCount += 1;\n        }\n    }\n    done(): void {\n        if (this._isOk) {\n            if (this._busyCount > 0) {\n                this._busyCount -= 1;\n                if (!this._busyCount) {\n                    this._doneCallback();\n                }\n            } else {\n                this._isOk = false;\n                this._overDoneCallback();\n            }\n        }\n    }\n}\n","import { Environment, LogCollector, LogMeta, Schema } from '../interfaces';\nimport { SchematizedData, schemaUtil } from 'o11y/shared';\n\ntype ColorMap = Record<string, string>;\n\nconst bgColorMap: ColorMap = {\n    Error: 'Crimson',\n    Activity: 'CadetBlue',\n    InstrumentedEvent: 'DarkOliveGreen',\n    O11ySample: 'BlueViolet'\n};\nconst colorMap: ColorMap = {\n    Error: 'white',\n    Activity: 'white',\n    InstrumentedEvent: 'white',\n    O11ySample: 'white'\n};\nconst defaultColor = 'black';\nconst defaultBgColor = 'Gainsboro';\n\nexport class ConsoleCollector implements LogCollector {\n    constructor(environment?: Environment) {\n        if (environment) {\n            this._log('ConsoleCollector', environment);\n        }\n    }\n\n    collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): void {\n        let label, color, bgColor;\n        if (schema.namespace === 'sf.instrumentation') {\n            label = schema.name;\n            color = colorMap[schema.name] || defaultColor;\n            bgColor = bgColorMap[schema.name] || defaultBgColor;\n        } else {\n            label = schemaUtil.getSchemaId(schema);\n        }\n\n        this._log(label, data, logMeta, color, bgColor);\n    }\n\n    private _log(\n        label: string,\n        first: unknown,\n        second?: unknown,\n        color: string = defaultColor,\n        bgColor: string = defaultBgColor\n    ): void {\n        const css = `color:${color};background-color:${bgColor}`;\n        // eslint-disable-next-line no-console\n        console.log(\n            `%cO11Y%c ${label}`,\n            'color:white;background-color:#FF6600;font-weight:bold',\n            css,\n            first || '',\n            second || ''\n        );\n    }\n}\n","// This is the file that exports all `o11y` module level exports.\nimport { IdleDetector } from './interfaces';\nimport { IdleDetectorImpl } from './library/IdleDetectorImpl';\n\nexport const idleDetector: IdleDetector = new IdleDetectorImpl();\n\nexport * from './index';\nexport { ConsoleCollector } from './console-collector/ConsoleCollector';","import { getInstrumentation } from '../index';\nimport { IdleDetector, Instrumentation } from '../interfaces';\nimport {\n    IdleDetectedListener,\n    IsBusyChecker,\n    TaskerMulti,\n    TaskerSingle\n} from '../interfaces/IdleDetector';\nimport { TaskerImpl } from './TaskerImpl';\nimport { utility } from 'o11y/shared';\n\nexport class IdleDetectorImpl implements IdleDetector {\n    private readonly _instr: Instrumentation = getInstrumentation('IdleDetector');\n    private readonly _taskers = new Set<TaskerImpl>();\n    private readonly _listeners = new Set<IdleDetectedListener>();\n    private readonly _busyCheckers = new Map<IsBusyChecker, string>();\n    private _timerCheckQueued = 0; // timerIds are always positive integers. 0 means nothing is queued\n\n    requestIdleDetectedCallback(callback: IdleDetectedListener): void {\n        utility.requireArgument(callback, 'callback', 'function');\n        this._listeners.add(callback);\n        this.checkIfLoaded();\n    }\n\n    declareNotifierTaskSingle(name: string): TaskerSingle {\n        utility.requireArgument(name, 'name', 'string');\n        const tasker = this.addTasker(name, 1);\n\n        const retVal: TaskerSingle = {\n            get isBusy() {\n                return tasker.isBusy;\n            },\n            done: () => {\n                tasker.done();\n                this._taskers.delete(tasker);\n            }\n        };\n        return retVal;\n    }\n\n    declareNotifierTaskMulti(name: string, existingBusyCount = 0): TaskerMulti {\n        utility.requireArgument(name, 'name', 'string');\n        if (existingBusyCount !== undefined) {\n            utility.requireArgument(existingBusyCount, 'existingBusyCount', 'number');\n\n            if (\n                existingBusyCount < 0 ||\n                parseInt(existingBusyCount.toString(), 10) !== existingBusyCount\n            ) {\n                // Remove decimal points to make sure it's an integer\n                throw new Error('existingBusyCount accepts only non-negative integers');\n            }\n        }\n        return this.addTasker(name, existingBusyCount);\n    }\n\n    declarePollableTaskMulti(name: string, isBusyChecker: IsBusyChecker): void {\n        utility.requireArgument(name, 'name', 'string');\n        utility.requireArgument(isBusyChecker, 'isBusyChecker', 'function');\n\n        this._busyCheckers.set(isBusyChecker, name);\n    }\n\n    private addTasker(name: string, existingBusyCount: number): TaskerImpl {\n        const tasker = new TaskerImpl(\n            name,\n            existingBusyCount,\n            () => {\n                this.checkIfLoaded();\n            },\n            () => {\n                throw new Error(`Tasker '${tasker.name}' is done too many times.`);\n            }\n        );\n        this._taskers.add(tasker);\n        return tasker;\n    }\n\n    private areAllNotifiersIdle(): boolean {\n        return !Array.from(this._taskers.values()).some((t) => t.isBusy);\n    }\n\n    private areAllPollablesIdle(): boolean {\n        return !Array.from(this._busyCheckers.keys()).some((sc, index) => {\n            try {\n                return sc();\n            } catch (e) {\n                this._instr.error(e, `BusyChecker #${index}`);\n                return false; // Not busy\n            }\n        });\n    }\n\n    private checkIfLoaded(): void {\n        if (!this._listeners.size) {\n            // bail out early. We don't have any callbacks queued\n            return;\n        }\n\n        // We restart the idle timer check logic whenever we get an external\n        // trigger that a resource was loaded since that would imply that more\n        // work could be queued up and we want to be aware of that\n        if (this._timerCheckQueued) {\n            window.clearTimeout(this._timerCheckQueued);\n        }\n\n        if (this.areAllNotifiersIdle()) {\n            // Enqueue two RAF to make sure nothing got queued in this js cycle\n            // note the use of double setTimeout. We want our setTimeout to queue up after\n            // any set timeouts queued within micro tasks that may run after processing this\n            // xhr response.\n            // Here's a sample timeline\n            // .....[            Single Event Loop          ].....................................\n            // .....[XHR callback][checkIfLoaded][microtasks]-[1st setTimeout]....[2nd setTimeout]\n            //                                               ^\n            // queue settimeout at the end of event loop --->|\n            this._timerCheckQueued = window.setTimeout(() => {\n                this._timerCheckQueued = window.setTimeout(() => {\n                    this.doubleCheck();\n                }, 40);\n            }, 0);\n        }\n    }\n\n    private doubleCheck(): void {\n        this._timerCheckQueued = 0;\n\n        if (this.areAllNotifiersIdle()) {\n            if (!this.areAllPollablesIdle()) {\n                // we'll have to keep polling until polled operations finish\n                this._timerCheckQueued = window.setTimeout(() => {\n                    this.doubleCheck();\n                }, 15);\n            } else {\n                // the listeners need to be copied and cleared out so that we don't get\n                // into an infinite loop situation where each idle callback enqueues a\n                // further idle callback and thus filling up the queue perpetually\n                const listeners = Array.from(this._listeners.values());\n                this._listeners.clear();\n                this.notify(listeners);\n            }\n        }\n    }\n\n    private notify(listeners: IdleDetectedListener[]): void {\n        const idleTimestamp = utility.time().tsNow;\n\n        for (const [index, listener] of listeners.entries()) {\n            try {\n                listener(idleTimestamp);\n            } catch (e) {\n                this._instr.error(e, `Listener #${index}`);\n            }\n        }\n    }\n}\n"],"names":["PublicSafety","[object Object]","_errorCounter","this","fn","err","_prodSafeCatch","noopValue","utility","requireArgument","error","allowThrow","isProduction","_safeCatchMode","Error","increment","errorText","message","toString","internalError","console","Tracing","instr","traceId","spanId","isSampled","parentSpanId","b3","undefined","text","numChars","len","toLowerCase","length","i","c","substr","padStart","options","useB3Headers","_conformTextAsId","traceIdEffectiveLength","headers","useCompactHeader","_getB3CompactFormat","_getW3CompactFormat","_isNetworkInstrumentationEnabled","_originalFetch","_global","fetch","_originalXhr","XMLHttpRequest","_originalXhrSend","prototype","send","logErrors","activityName","useTracing","_overrideFetch","_overrideXhr","async","url","reqOptions","restArgs","activity","startActivity","traceHeaders","getTraceHeaders","Object","assign","call","ex","stop","args","xhr","_o11yActivity","entries","forEach","entry","setRequestHeader","xhrProxy","Proxy","target","newXhr","addEventListener","__err","discard","_disableNetworkInstrumentation","tracingOptions","_enableNetworkInstrumentation","definedValueOrDefault","instrumentation","tracingHeadersOptions","getGlobal","stopReason","ActivityImpl","_name","_rootId","_onStopped","_onError","timeout","id","_isSampled","tsNow","perfNow","time","_count","_id","generateUniqueId","_usePerf","performance","mark","measure","_perfName","_perfId","_startTimestamp","_startPerfTime","_timer","setTimeout","_stopReason","_safety","userSchemaOrText","userData","tryCatch","_errorCount","_getDetail","_stopInternal","stopPerfTime","clearMarks","clearMeasures","clearTimeout","isStopped","_stopPerfTime","activityDetail","rootId","name","startTimestamp","startPerfTime","errorCount","getIsSampled","getHeaders","namespace","pbjsSchema","nested","sf","Activity","reserved","fields","duration","type","isRoot","(meta.max_length)","preRootId","userPayload","Payload","payload","schemaName","activityId","stack","instrumented_event","MouseEvent","cancelable","ctrlKey","button","offsetX","eventPhase","shiftKey","offsetY","composed","altKey","isTrusted","buttons","movementY","clientY","clientX","movementX","defaultPrevented","metaKey","timeStamp","bubbles","detail","pageY","pageX","screenX","screenY","InstrumentedEvent","oneofs","event","oneof","mouseEvent","auto","parentComponent","ownerComponent","simplePath","simple","Simple","(meta.msg.desc)","Array","fill","join","activityNoOp","freeze","__options","domEventHelpers","eventData","handledBy","instrumentedEvent","tagName","parentElement","getXpath","schemaUtil","makePayload","schema","e","logValidator","data","schemaTokens","checkSchema","nestedSchema","getTypes","errorMessage","validateFields","getSchemaId","custom","schemaId","key","value","isNullOrUndefinedOrEmpty","matchFieldTypes","rule","val","fieldData","fieldType","descriptor","convertedSchemaType","extraContext","isArray","index","Uint8Array","checkNumberRange","Number","isFinite","ref","keys","x","fieldLength","max","min","UpCounterImpl","_ownerName","_ownerAppName","_tags","_createdOn","_lastUpdatedOn","_value","Math","round","ValueRecorderImpl","values","_values","slice","push","SizeLimitedMap","maxSize","Map","_maxSize","ceil","_map","get","has","size","set","from","clear","MetricType","MetricsImpl","_getOwnerAppName","operation","hasError","tags","_tagError","_upCounter","_valueRecorder","record","sortedTags","_getKeyAndSortedTags","Counter","instrument","_upCounters","Percentile","_valueRecorders","getElements","status","metricType","sort","reduce","prev","curr","JSON","stringify","MockEvent","_composedPaths","reservedMetricCharacters","reservedMetricNames","denyListMetricNames","InstrumentationImpl","_nextGen","_handleActivityStop","bind","_handleActivityError","reservedChar","indexOf","_incrementError","_metrics","_initMetrics","simpleTextOptions","getOptions","simpleSchema","_simpleTextMaxLength","MAX_VALUE","appName","defaultAppName","incrementCounter","onlyIfBoth","userSchema","timestamp","_wrapUserPayload","_logInternal","getRootActivityId","loggerName","_checkInputs","appPayload","_getPayloadFromProvider","appPayloadProvider","pagePayload","pagePayloadProvider","addLog","_errorInternal","loggedTimestamp","errorData","errorSchema","tryCatchReturn","_onActivityStoppedCallback","_onActivityErrorCallback","isRootActivitySampled","activityData","_getActivityData","_logActivity","activitySchema","provider","getPayload","htmlElement","Event","HTMLElement","template","host","acd","getClickTracker","markEventHandled","mouseEventData","getMouseEventData","getInstrumentedEventData","instrumentedEventSchema","notImplemented","checkForDenyListedValues","checkForReservedCharacters","trackValue","savedUserPayload","isInternal","validate","getUpCounters","filter","m","getLastUpdatedOn","getValueRecorders","listener","registerForLogPrompt","RootActivityImpl","onStopped","onError","super","_preRootId","rootActivityNoOp","AppInstrumentationImpl","handleRootActivityStop","newRootActivity","_onRootActivityStoppedCallback","rootActivity","getId","terminate","AutomaticClickTracker","document","clickListener","isActive","_boundClickListener","removeEventListener","ignoredEvent","eventTargets","composedPath","path","getClickableElement","domEvent","limit","currentElement","inputElement","maxInstrumentationLengthBeforeTruncated","NextgenImpl","Set","_pagePayloadProvider","_appPayloadProvider","enableBuffering","_appInstr","_instruments","_isBufferingEnabled","tracing","log","networkInstrumentation","startRootActivity","registerLogCollector","registerMetricsCollector","activateClickTracker","deactivateClickTracker","disableBuffering","promptLogCollection","_sequence","logMeta","sequence","loggerAppName","connectionType","getConnectionType","_buffer","clone","eligibleCollectors","_logCollectors","collector","_forceDisabledLogCollectors","getIsCollectDisabled","dataClone","failures","_logCollectorFailures","collect","_collectorFailureLimit","add","_autoClickTracker","window","activate","deactivate","retroactive","_metricsCollector","receiveMetricsExtractors","getAllUpCounters","getAllValueRecorders","map","pv","cv","concat","_logCollectionListeners","reason","_lazyNextGen","_nextgen","markProduction","retVal","registerApp","getInstrumentation","registerInstrumentedApp","TaskerImpl","initialCount","_doneCallback","_overDoneCallback","_busyCount","isBusy","_isOk","bgColorMap","O11ySample","colorMap","ConsoleCollector","environment","_log","label","color","bgColor","first","second","css","idleDetector","callback","_listeners","checkIfLoaded","tasker","addTasker","done","_taskers","delete","existingBusyCount","parseInt","isBusyChecker","_busyCheckers","some","t","sc","_instr","_timerCheckQueued","areAllNotifiersIdle","doubleCheck","areAllPollablesIdle","listeners","notify","idleTimestamp"],"mappings":"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"}