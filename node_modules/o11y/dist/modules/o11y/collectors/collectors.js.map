{"version":3,"file":"collectors.js","sources":["../../../../../../node_modules/o11y_schema/sf_instrumentation/core_envelope.js","../../../../src/collectors/protobuf-util.ts","../../../../src/collectors/core-collector/UploadMode.ts","../../../../../../node_modules/o11y_schema/version/version.js","../../../../src/collectors/core-collector/CoreEnvelopeBuilder.ts","../../../../src/collectors/core-collector/CoreCollector.ts","../../../../src/collectors/hybrid-collector/HybridCollector.ts"],"sourcesContent":["export const core_envelope={namespace:\"sf.instrumentation\",name:\"CoreEnvelope\",pbjsSchema:{\"nested\":{\"sf\":{\"nested\":{\"instrumentation\":{\"nested\":{\"MessageBundle\":{\"fields\":{\"messages\":{\"options\":{},\"rule\":\"repeated\",\"id\":2,\"type\":\"LogMessage\"},\"schemaName\":{\"options\":{},\"id\":1,\"type\":\"string\"}}},\"Metrics\":{\"fields\":{\"valueRecorders\":{\"options\":{},\"rule\":\"repeated\",\"id\":2,\"type\":\"ValueRecorder\"},\"upCounters\":{\"options\":{},\"rule\":\"repeated\",\"id\":1,\"type\":\"UpCounter\"}}},\"CoreEnvelopeDiagnostics\":{\"fields\":{\"schemaVersion\":{\"options\":{},\n\"id\":6,\"type\":\"string\"},\"generatedTimestamp\":{\"options\":{},\"id\":2,\"type\":\"double\"},\"bundleCount\":{\"options\":{},\"id\":3,\"type\":\"uint32\"},\"upCounterCount\":{\"options\":{},\"id\":4,\"type\":\"uint32\"},\"valueRecorderCount\":{\"options\":{},\"id\":5,\"type\":\"uint32\"},\"key\":{\"options\":{},\"id\":1,\"type\":\"string\"}}},\"LogMessage\":{\"fields\":{\"appPayload\":{\"options\":{},\"id\":10,\"type\":\"Payload\"},\"data\":{\"options\":{},\"id\":2,\"type\":\"bytes\"},\"rootId\":{\"options\":{},\"id\":4,\"type\":\"string\"},\"pagePayload\":{\"options\":{},\"id\":7,\"type\":\"Payload\"},\n\"loggerAppName\":{\"options\":{},\"id\":8,\"type\":\"string\"},\"loggerName\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"connectionType\":{\"options\":{},\"id\":9,\"type\":\"string\"},\"age\":{\"options\":{},\"id\":3,\"type\":\"double\"},\"seq\":{\"options\":{},\"id\":5,\"type\":\"uint32\"},\"timestamp\":{\"options\":{},\"id\":1,\"type\":\"double\"}}},\"CoreEnvelope\":{\"options\":{\"(meta.msg.desc)\":\"This message is used to contain data that the Core ui-telemetry Connect API endpoint accepts.\"},\"fields\":{\"diagnostics\":{\"options\":{},\"id\":1,\"type\":\"CoreEnvelopeDiagnostics\"},\n\"bundles\":{\"options\":{},\"rule\":\"repeated\",\"id\":2,\"type\":\"MessageBundle\"},\"metrics\":{\"options\":{},\"id\":3,\"type\":\"Metrics\"},\"staticAttributes\":{\"options\":{},\"id\":4,\"type\":\"StaticAttributes\"}}},\"MetricTag\":{\"fields\":{\"name\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"value\":{\"options\":{},\"id\":2,\"type\":\"string\"}}},\"ValueRecorder\":{\"fields\":{\"lastUpdatedTimestamp\":{\"options\":{},\"id\":3,\"type\":\"double\"},\"ownerName\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"ownerAppName\":{\"options\":{},\"id\":7,\"type\":\"string\"},\"createdTimestamp\":{\"options\":{},\n\"id\":2,\"type\":\"double\"},\"values\":{\"options\":{},\"rule\":\"repeated\",\"id\":4,\"type\":\"double\"},\"name\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"tags\":{\"options\":{},\"rule\":\"repeated\",\"id\":5,\"type\":\"MetricTag\"}}},\"StaticAttributes\":{\"fields\":{\"appVersion\":{\"options\":{},\"id\":2,\"type\":\"string\"},\"appName\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"deviceModel\":{\"options\":{},\"id\":5,\"type\":\"string\"},\"sdkVersion\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"deviceId\":{\"options\":{},\"id\":4,\"type\":\"string\"},\"appExperience\":{\"options\":{},\n\"id\":3,\"type\":\"string\"}}},\"Payload\":{\"fields\":{\"payload\":{\"options\":{},\"id\":2,\"type\":\"bytes\"},\"schemaName\":{\"options\":{},\"id\":1,\"type\":\"string\"}}},\"UpCounter\":{\"fields\":{\"lastUpdatedTimestamp\":{\"options\":{},\"id\":3,\"type\":\"double\"},\"ownerName\":{\"options\":{},\"id\":6,\"type\":\"string\"},\"ownerAppName\":{\"options\":{},\"id\":7,\"type\":\"string\"},\"createdTimestamp\":{\"options\":{},\"id\":2,\"type\":\"double\"},\"name\":{\"options\":{},\"id\":1,\"type\":\"string\"},\"value\":{\"options\":{},\"id\":4,\"type\":\"uint32\"},\"tags\":{\"options\":{},\n\"rule\":\"repeated\",\"id\":5,\"type\":\"MetricTag\"}}}}}}}}}};","import { Message, Root, Type } from 'protobufjs';\n\nimport { LogMeta, Schema, SchematizedPayload } from '../interfaces';\nimport { EncodedSchematizedPayload } from './EncodedSchematizedPayload';\nimport { SchematizedData, schemaUtil, utility } from 'o11y/shared';\nimport { LogMessage } from './core-collector/interfaces/LogMessage';\n\nclass ProtobufUtil {\n    private readonly _typeStore = new Map<string, Type>();\n\n    public getSchemaType(schema: Schema): Type {\n        utility.requireArgument(schema, 'schema');\n        const schemaPath = schemaUtil.getSchemaId(schema);\n        let type = this._typeStore.get(schemaPath);\n\n        if (!type) {\n            // Lazy add to the type store\n            const schemaInstance = Root.fromJSON(schema.pbjsSchema);\n            // this will throw if it can't find it\n            type = schemaInstance.lookupType(schemaPath);\n            this._typeStore.set(schemaPath, type);\n        }\n\n        return type;\n    }\n\n    public validate(schema: Schema, data: SchematizedData): Type {\n        utility.requireArgument(schema, 'schema');\n        utility.requireArgument(data, 'data');\n        const type: Type = this.getSchemaType(schema);\n\n        const errorText = type.verify(data);\n        if (errorText) {\n            throw new Error(`Data is invalid for ${type.fullName}: ${errorText}`);\n        }\n        return type;\n    }\n\n    public encode(schema: Schema, data: SchematizedData): Uint8Array {\n        const type: Type = this.validate(schema, data);\n        const message: Message = type.fromObject(data);\n        const encoded: Uint8Array = type.encode(message).finish();\n        return encoded;\n    }\n\n    public encodePayload(rawPayload: SchematizedPayload): EncodedSchematizedPayload {\n        if (rawPayload && rawPayload.schema && rawPayload.payload) {\n            return {\n                schemaName: schemaUtil.getSchemaId(rawPayload.schema),\n                payload: this.encode(rawPayload.schema, rawPayload.payload)\n            };\n        }\n        return undefined;\n    }\n\n    //  This method generates a LogMessage (used in the CoreEnvelope) from the provided arguments.\n    public getLogMessage(schema: Schema, data: SchematizedData, logMeta: LogMeta): LogMessage {\n        return {\n            timestamp: logMeta.timestamp,\n            data: this.encode(schema, data),\n            age: utility.getAge(logMeta.timestamp),\n            rootId: logMeta.rootId,\n            seq: logMeta.sequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: this.encodePayload(logMeta.pagePayload),\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: this.encodePayload(logMeta.appPayload)\n        };\n    }\n}\n\nexport const protobufUtil = new ProtobufUtil();\n","export enum UploadMode {\n    fetchBinary, // application/octet-stream\n    fetchFile, // multipart/form-data\n    noUpload\n}\n","export const version='238.0.0'","import { Metric } from '../../interfaces';\nimport { MetricsTags, utility } from 'o11y/shared';\nimport { CoreEnvelope } from './interfaces/CoreEnvelope';\nimport { LogMessage } from './interfaces/LogMessage';\nimport { MessageBundle } from './interfaces/MessageBundle';\nimport { StaticAttributes } from './interfaces/StaticAttributes';\nimport { UpCounter } from '../metrics/UpCounter';\nimport { ValueRecorder } from '../metrics/ValueRecorder';\nimport { version as schemaVersion } from 'o11y_schema/version';\nimport { MetricTag } from '../metrics/MetricTag';\n\nexport const coreEnvelopeKey = 'o11y';\nexport class CoreEnvelopeBuilder {\n    private _envelope: CoreEnvelope;\n\n    constructor() {\n        this._envelope = {\n            diagnostics: {\n                key: coreEnvelopeKey,\n                generatedTimestamp: undefined,\n                bundleCount: 0,\n                upCounterCount: 0,\n                valueRecorderCount: 0,\n                schemaVersion\n            },\n            bundles: [] as MessageBundle[],\n            metrics: {\n                upCounters: [] as UpCounter[],\n                valueRecorders: [] as ValueRecorder[]\n            },\n            staticAttributes: {}\n        };\n    }\n\n    withStaticAttributes(staticAttributes: StaticAttributes): CoreEnvelopeBuilder {\n        this._envelope.staticAttributes = staticAttributes;\n        return this;\n    }\n\n    withLogs(schemaName: string, logs: LogMessage[]): CoreEnvelopeBuilder {\n        let msgBundle: MessageBundle = this._envelope.bundles.find(\n            (bundle) => bundle.schemaName === schemaName\n        );\n\n        if (msgBundle) {\n            for (const log of logs) {\n                msgBundle.messages.push(log);\n            }\n        } else {\n            msgBundle = {\n                schemaName: schemaName,\n                messages: logs\n            };\n            this._envelope.bundles.push(msgBundle);\n        }\n        this._envelope.diagnostics.bundleCount = this._envelope.bundles.length;\n        return this;\n    }\n\n    private static _getMetricTags<T>(metric: Metric<T>): MetricTag[] {\n        const tags: MetricsTags = metric.getTags();\n        if (tags) {\n            return Object.entries(tags).map((entry) => {\n                const mt: MetricTag = {\n                    name: entry[0],\n                    value: entry[1].toString()\n                };\n                return mt;\n            });\n        }\n        return undefined;\n    }\n\n    static getUpCounters(metrics: Metric<number>[], reset = true): UpCounter[] {\n        return metrics.map((metric) => {\n            const data: UpCounter = {\n                name: metric.getName(),\n                createdTimestamp: metric.getCreatedOn(),\n                lastUpdatedTimestamp: metric.getLastUpdatedOn(),\n                value: metric.getData(),\n                ownerName: metric.getOwnerName(),\n                ownerAppName: metric.getOwnerAppName(),\n                tags: this._getMetricTags(metric)\n            };\n            if (reset) {\n                metric.reset();\n            }\n            return data;\n        });\n    }\n\n    static getValueRecorders(metrics: Metric<number[]>[], reset = true): ValueRecorder[] {\n        return metrics.map((metric) => {\n            const data: ValueRecorder = {\n                name: metric.getName(),\n                createdTimestamp: metric.getCreatedOn(),\n                lastUpdatedTimestamp: metric.getLastUpdatedOn(),\n                values: metric.getData(),\n                ownerName: metric.getOwnerName(),\n                ownerAppName: metric.getOwnerAppName(),\n                tags: this._getMetricTags(metric)\n            };\n            if (reset) {\n                metric.reset();\n            }\n            return data;\n        });\n    }\n\n    withUpCounters(upCounters: UpCounter[]): CoreEnvelopeBuilder {\n        for (const upCounter of upCounters) {\n            this._envelope.metrics.upCounters.push(upCounter);\n        }\n        this._envelope.diagnostics.upCounterCount = this._envelope.metrics.upCounters.length;\n        return this;\n    }\n\n    withValueRecorders(valueRecorders: ValueRecorder[]): CoreEnvelopeBuilder {\n        for (const valueRecorder of valueRecorders) {\n            this._envelope.metrics.valueRecorders.push(valueRecorder);\n        }\n        this._envelope.diagnostics.valueRecorderCount =\n            this._envelope.metrics.valueRecorders.length;\n        return this;\n    }\n\n    build(): CoreEnvelope {\n        this._envelope.diagnostics.generatedTimestamp = utility.time().tsNow;\n        return this._envelope;\n    }\n}\n","import { Root, Type } from 'protobufjs';\nimport { coreEnvelopeSchema } from 'o11y_schema/sf_instrumentation';\n\nimport {\n    Environment,\n    LogCollector,\n    LogMeta,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { LazyMapToList, SchematizedData, schemaUtil, utility } from 'o11y/shared';\n\nimport { protobufUtil } from '../protobuf-util';\nimport { UploadMode } from './UploadMode';\nimport { CoreCollectorOptions } from './interfaces/CoreCollectorOptions';\nimport { CoreEnvelope } from './interfaces/CoreEnvelope';\nimport { CoreEnvelopeBuilder } from './CoreEnvelopeBuilder';\nimport { LogMessage } from './interfaces/LogMessage';\nimport { StaticAttributes } from './interfaces/StaticAttributes';\nimport { CoreEnvelopeContents } from './interfaces/CoreEnvelopeContents';\nimport { UploadResult } from './interfaces/UploadResult';\n\nconst defaultMaxUniqueSchemas = 10000;\nconst defaultMaxDelayBeforeUpload = 10000;\nconst defaultMessagesLimit = 10;\nconst defaultMetricsLimit = 10;\nconst defaultFormDataKey = 'telemetry';\nconst defaultUploadMode = UploadMode.fetchBinary;\n\nexport class CoreCollector implements LogCollector, MetricsCollector {\n    private readonly _messageBuffers: LazyMapToList<Schema, LogMessage>;\n    private readonly _coreEnvelopeType: Type;\n    private _intervalHandle: NodeJS.Timeout;\n    private _metricsExtractors: MetricsExtractorMethods;\n    private readonly _staticAttributes: StaticAttributes;\n    private _immediateUpload: boolean;\n    private readonly _messagesLimit: number = defaultMessagesLimit;\n    /*\n     Known limitation:\n     Unlike _messagesLimit, _metricsLimit is not a strict limit in all cases, as the CoreCollector\n     doesn't get notified every time a new metric is added. Instead, it takes metrics into account\n     when a message is logged or the upload timer is elapsed. If the _metricsLimit is exceeded \n     with no messages logged and upload time not yet elapsed, upload will not occur.\n    */\n    private readonly _metricsLimit: number = defaultMetricsLimit;\n    private readonly _formDataKey: string = defaultFormDataKey;\n    private readonly _uploadFailedListener: (ur: UploadResult) => unknown;\n    private _uploadInterval: number = defaultMaxDelayBeforeUpload;\n    private _uploadEndpoint: string;\n    private _uploadMode: UploadMode;\n    private readonly _emptySize: number;\n    private _messageSize = 0;\n\n    constructor(\n        uploadEndpoint?: string,\n        uploadMode?: UploadMode,\n        environment?: Environment,\n        options?: CoreCollectorOptions\n    ) {\n        this.uploadEndpoint = uploadEndpoint;\n        this.uploadMode = uploadMode == undefined ? defaultUploadMode : uploadMode;\n\n        const root = Root.fromJSON(coreEnvelopeSchema.pbjsSchema);\n        this._coreEnvelopeType = root.lookupType('CoreEnvelope');\n\n        if (environment) {\n            this._staticAttributes = {\n                appName: environment.appName,\n                appVersion: environment.appVersion,\n                appExperience: environment.appExperience,\n                deviceId: environment.deviceId,\n                deviceModel: environment.deviceModel,\n                sdkVersion: environment.sdkVersion\n            };\n        }\n\n        let maxUniqueSchemas = defaultMaxUniqueSchemas;\n        if (options) {\n            const mus: number = options.maxUniqueSchemas;\n            if (mus !== undefined) {\n                if (typeof mus !== 'number' || !(mus > 0)) {\n                    throw new Error('options.maxUniqueSchemas, if defined, must be > 0');\n                }\n                maxUniqueSchemas = mus;\n            }\n\n            const msglim: number = options.messagesLimit;\n            if (msglim !== undefined) {\n                if (typeof msglim !== 'number' || !(msglim > 0)) {\n                    throw new Error('options.messagesLimit, if defined, must be > 0');\n                }\n                this._messagesLimit = msglim;\n            }\n\n            const metlim: number = options.metricsLimit;\n            if (metlim !== undefined) {\n                if (typeof metlim !== 'number' || !(metlim > 0)) {\n                    throw new Error('options.metricsLimit, if defined, must be > 0');\n                }\n                this._metricsLimit = metlim;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.formDataKeyName,\n                    'options.formDataKeyName',\n                    'string'\n                )\n            ) {\n                this._formDataKey = options.formDataKeyName;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.uploadFailedListener,\n                    'options.uploadFailedListener',\n                    'function'\n                )\n            ) {\n                this._uploadFailedListener = options.uploadFailedListener;\n            }\n        }\n        this._messageBuffers = new LazyMapToList<Schema, LogMessage>(maxUniqueSchemas);\n\n        this._emptySize = this.getByteSize(1);\n        this._restartTimer();\n    }\n\n    get uploadInterval(): number {\n        return this._uploadInterval;\n    }\n    set uploadInterval(uploadInterval: number) {\n        if (uploadInterval === undefined) {\n            uploadInterval = defaultMaxDelayBeforeUpload;\n        }\n        if (typeof uploadInterval !== 'number' || !(uploadInterval > 0)) {\n            throw new Error('uploadInterval, if defined, must be > 0');\n        }\n        if (uploadInterval !== this._uploadInterval) {\n            this._uploadInterval = uploadInterval;\n            // Now that the interval has changed, restart the timer\n            this._restartTimer();\n        }\n    }\n\n    get uploadEndpoint(): string {\n        return this._uploadEndpoint;\n    }\n    set uploadEndpoint(uploadEndpoint: string) {\n        utility.requireArgumentIfDefined(uploadEndpoint, 'uploadEndpoint', 'string');\n        this._uploadEndpoint = uploadEndpoint;\n    }\n\n    get uploadMode(): UploadMode {\n        return this._uploadMode;\n    }\n    set uploadMode(uploadMode: UploadMode) {\n        utility.requireArgumentIfDefined(uploadMode, 'uploadMode', 'number');\n        if (uploadMode === undefined) {\n            uploadMode = defaultUploadMode;\n        }\n        if (!(uploadMode in UploadMode)) {\n            throw new Error(`Unsupported upload mode: ${uploadMode}`);\n        }\n        this._uploadMode = uploadMode;\n    }\n\n    getByteSize(accuracy?: number): number {\n        // This method provides an estimate.\n        // Accuracy is specified as 1 = most accurate\n        return accuracy >= 1\n            ? this._buildProtoEncodedCoreEnvelope(false).byteLength\n            : accuracy >= 0.5\n            ? this._emptySize + this._messageSize + this.metricsCount * 8\n            : this._emptySize + this._messageSize;\n    }\n\n    private _stopTimer(): void {\n        if (this._intervalHandle !== undefined) {\n            clearInterval(this._intervalHandle);\n            this._intervalHandle = undefined;\n        }\n    }\n\n    private _restartTimer(): void {\n        this._stopTimer();\n        this._intervalHandle = setInterval(() => {\n            if (this.hasData) {\n                this._upload();\n            }\n        }, this._uploadInterval);\n    }\n\n    // This method is implementing the LogCollector interface, but needs to return (not swallow)\n    // the async result in order for direct call to it from test to handle failure cases properly.\n    async collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): Promise<UploadResult> {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const msg: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n\n        if (!this._messageBuffers.push(schema, msg)) {\n            throw new Error(`Buffer is full. Refusing schemaId ${schemaUtil.getSchemaId(schema)}`);\n        }\n        // Get an estimate\n        this._messageSize += utility.estimateObjectSize(msg);\n        if (this._shouldUpload()) {\n            return this._upload();\n        }\n        return undefined;\n    }\n\n    private _shouldUpload(): boolean {\n        return (\n            (this._immediateUpload && this.hasData) ||\n            this.messagesCount >= this._messagesLimit ||\n            this.metricsCount >= this._metricsLimit\n        );\n    }\n\n    private async _upload(userInitiated?: boolean): Promise<UploadResult> {\n        this._restartTimer();\n        if (!this._uploadEndpoint || this._uploadMode === UploadMode.noUpload) {\n            return undefined;\n        }\n\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(true);\n        return this._uploadContents(contents, userInitiated);\n    }\n\n    private async _uploadContents(\n        contents: CoreEnvelopeContents,\n        userInitiated: boolean\n    ): Promise<UploadResult> {\n        const coreEnvelope: Uint8Array = this._buildProtoEncodedCoreEnvelopeFrom(contents);\n\n        let requestInit;\n        switch (this._uploadMode) {\n            case UploadMode.fetchBinary:\n                requestInit = {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/octet-stream'\n                    },\n                    body: coreEnvelope\n                };\n                break;\n            case UploadMode.fetchFile:\n                const formData = new FormData();\n                formData.append(this._formDataKey, new Blob([coreEnvelope]));\n                // Per [this article](https://muffinman.io/uploading-files-using-fetch-multipart-form-data/)\n                // make sure not to set the Content-Type header.\n                // The browser will set it for you, including the boundary parameter.\n                requestInit = {\n                    method: 'POST',\n                    body: formData\n                };\n                break;\n        }\n\n        const ur: UploadResult = {\n            envelopeContents: contents\n        };\n        try {\n            ur.response = await fetch(this._uploadEndpoint, requestInit);\n            // fetch only throws on network errors, not HTTP errors, so handle that here\n            if (!ur.response.ok) {\n                throw new Error('HTTP Not OK');\n            }\n            return ur;\n        } catch (err) {\n            ur.error = err;\n            if (!userInitiated && this._uploadFailedListener) {\n                try {\n                    this._uploadFailedListener(ur);\n                } catch {}\n            }\n            throw ur;\n        }\n    }\n\n    private _checkUploadState(): void {\n        if (this._uploadEndpoint === undefined) {\n            throw new Error('Upload endpoint is unset');\n        }\n        if (this._uploadMode === UploadMode.noUpload) {\n            throw new Error('Upload mode is unset');\n        }\n    }\n\n    // User initiated method\n    public async upload(contents?: CoreEnvelopeContents): Promise<UploadResult> {\n        this._checkUploadState();\n        if (utility.requireArgumentIfDefined(contents, 'contents', 'object')) {\n            return this._uploadContents(contents, true);\n        }\n\n        return this.hasData ? this._upload(true) : undefined;\n    }\n\n    get hasData(): boolean {\n        return this.messagesCount > 0 || this.metricsCount > 0;\n    }\n\n    get messagesCount(): number {\n        return this._messageBuffers.totalItemCount;\n    }\n\n    get metricsCount(): number {\n        let count = 0;\n\n        if (this._metricsExtractors) {\n            let metrics: unknown[] = this._metricsExtractors.getAllUpCounters();\n            count += (metrics && metrics.length) || 0;\n            metrics = this._metricsExtractors.getAllValueRecorders();\n            count += (metrics && metrics.length) || 0;\n        }\n\n        return count;\n    }\n\n    getProtoEncodedCoreEnvelope(): Uint8Array {\n        return this._buildProtoEncodedCoreEnvelope(true);\n    }\n\n    getContentsOfCoreEnvelope(): CoreEnvelopeContents {\n        return this._getContentsOfCoreEnvelope(true);\n    }\n\n    private _getContentsOfCoreEnvelope(extract: boolean): CoreEnvelopeContents {\n        // 1. extract=true is for most use cases.\n        // 2. extract=false is for peeking into the contents without affecting them\n        //    (i.e. messages are kept in the buffers and metrics are not reset.)\n        //    Message arrays are references to the originals and should be handled carefully.\n\n        const contents: CoreEnvelopeContents = {\n            staticAttributes: this._staticAttributes,\n            messages: this._messageBuffers.getAllMessages(extract)\n        };\n\n        if (this._metricsExtractors) {\n            contents.upCounters = CoreEnvelopeBuilder.getUpCounters(\n                this._metricsExtractors.getAllUpCounters(),\n                extract\n            );\n            contents.valueRecorders = CoreEnvelopeBuilder.getValueRecorders(\n                this._metricsExtractors.getAllValueRecorders(),\n                extract\n            );\n        }\n\n        if (extract) {\n            this._messageSize = 0;\n        }\n        return contents;\n    }\n\n    private _buildProtoEncodedCoreEnvelope(extract: boolean): Uint8Array {\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(extract);\n        return this._buildProtoEncodedCoreEnvelopeFrom(contents);\n    }\n\n    private _buildProtoEncodedCoreEnvelopeFrom(contents?: CoreEnvelopeContents): Uint8Array {\n        const builder = new CoreEnvelopeBuilder();\n\n        if (contents.staticAttributes) {\n            builder.withStaticAttributes(contents.staticAttributes);\n        }\n        if (contents.messages) {\n            contents.messages.forEach((logs: LogMessage[], schema: Schema) => {\n                builder.withLogs(schemaUtil.getSchemaId(schema), logs);\n            });\n        }\n        if (contents.upCounters) {\n            builder.withUpCounters(contents.upCounters);\n        }\n        if (contents.valueRecorders) {\n            builder.withValueRecorders(contents.valueRecorders);\n        }\n\n        return this._encodeCoreEnvelope(builder.build());\n    }\n\n    private _encodeCoreEnvelope(coreEnvelope: CoreEnvelope): Uint8Array {\n        const errorMessage = this._coreEnvelopeType.verify(coreEnvelope);\n        if (errorMessage) {\n            throw new Error(`Invalid CoreEnvelope: ${errorMessage}`);\n        }\n\n        const encodedCoreEnvelope = this._coreEnvelopeType.encode(coreEnvelope).finish();\n        return encodedCoreEnvelope;\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n}\n","import {\n    LogCollector,\n    LogMeta,\n    Metric,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { SchematizedData, MetricsTags, schemaUtil, utility } from 'o11y/shared';\nimport { protobufUtil } from '../protobuf-util';\nimport { LogMessage } from '../core-collector/interfaces/LogMessage';\nimport { EncodedSchematizedPayload } from '../EncodedSchematizedPayload';\nimport { MetricTag } from '../metrics/MetricTag';\nimport { UpCounter } from '../metrics/UpCounter';\nimport { ValueRecorder } from '../metrics/ValueRecorder';\nimport { Metrics } from '../metrics/Metrics';\n\nconst metricsCollectionMilliseconds = 30000;\n\n// The observability plugin expects encoded payloads, so can't use LogMeta as-is.\ninterface LogMetaObservability {\n    timestamp: number;\n    rootId: string;\n    sequence: number;\n    loggerName: string;\n    pagePayload: EncodedSchematizedPayload;\n    loggerAppName: string;\n    connectionType: string;\n    appPayload: EncodedSchematizedPayload;\n}\n\n// The following interface is expected to be fulfilled by the\n// observability plugin in Lightning SDK.\ndeclare type NimbusObservabilityPlugin = {\n    // Called to send a collected message to native for handling\n    log: (schema: string, encodedMessage: Uint8Array, logMeta: LogMetaObservability) => void;\n\n    // Called to send metrics to native for handling\n    logMetrics: (metrics: Metrics) => void;\n\n    // Called to listen for root activity changes in native.\n    //\n    // The startListener is called with the id of the root activity when an activity is started\n    // The stopListener is called when a root activity is stopped\n    addRootActivityListeners: (\n        startListener: (activityInfo: { id: string }) => void,\n        stopListener: () => void\n    ) => void;\n\n    // Called to inform native that the web view has detected an idle state.\n    idleDetected: (timestamp: number) => void;\n};\n\n// The `HybridCollector` uses nimbus to send log data immediately across\n// to be handled by the native observability library.\nexport class HybridCollector implements LogCollector, MetricsCollector {\n    private readonly _observability: NimbusObservabilityPlugin;\n    private _metricsExtractors: MetricsExtractorMethods;\n\n    constructor() {\n        if (typeof __nimbus === 'undefined') {\n            throw new Error('Nimbus is unavailable');\n        }\n        if (!__nimbus.plugins || !__nimbus.plugins.observability) {\n            throw new Error('Observability plugin not found in Nimbus plugins');\n        }\n        this._observability = __nimbus.plugins.observability as NimbusObservabilityPlugin;\n        setInterval(() => {\n            this._collectMetrics();\n        }, metricsCollectionMilliseconds);\n    }\n\n    collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): void {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const logMessage: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n        const logMetaObs: LogMetaObservability = {\n            timestamp: logMeta.timestamp,\n            rootId: logMeta.rootId,\n            sequence: logMeta.sequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: logMessage.pagePayload,\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: logMessage.appPayload\n        };\n        this._observability.log(schemaUtil.getSchemaId(schema), logMessage.data, logMetaObs);\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n\n    // An app can call this method to listen for root activities that start and stop\n    // on the native side, in order to associate web activities with the same root id.\n    addRootActivityListeners(\n        activityStarted: (info: { id: string }) => void,\n        activityEnded: () => void\n    ): void {\n        utility.requireArgument(activityStarted, 'activityStarted', 'function');\n        utility.requireArgument(activityEnded, 'activityEnded', 'function');\n\n        this._observability.addRootActivityListeners(activityStarted, activityEnded);\n    }\n\n    // An app should call this method when it detects idle in the web view in order\n    // to inform the native app of the idle state.\n    notifyIdleDetected(timestamp: number): void {\n        this._observability.idleDetected(timestamp);\n    }\n\n    private _collectMetrics(): void {\n        if (this._metricsExtractors) {\n            const upCounters: Metric<number>[] = this._metricsExtractors.getAllUpCounters();\n            const valueRecorders: Metric<number[]>[] =\n                this._metricsExtractors.getAllValueRecorders();\n\n            const recorders: ValueRecorder[] = [];\n            const counters: UpCounter[] = [];\n\n            for (const valueRecorder of valueRecorders) {\n                const vr: ValueRecorder = {\n                    name: valueRecorder.getName(),\n                    createdTimestamp: valueRecorder.getCreatedOn(),\n                    lastUpdatedTimestamp: valueRecorder.getLastUpdatedOn(),\n                    values: valueRecorder.getData(),\n                    ownerName: valueRecorder.getOwnerName(),\n                    ownerAppName: valueRecorder.getOwnerAppName(),\n                    tags: this._getMetricTags(valueRecorder)\n                };\n                recorders.push(vr);\n                valueRecorder.reset();\n            }\n\n            for (const upCounter of upCounters) {\n                const uc: UpCounter = {\n                    name: upCounter.getName(),\n                    createdTimestamp: upCounter.getCreatedOn(),\n                    lastUpdatedTimestamp: upCounter.getLastUpdatedOn(),\n                    value: upCounter.getData(),\n                    ownerName: upCounter.getOwnerName(),\n                    ownerAppName: upCounter.getOwnerAppName(),\n                    tags: this._getMetricTags(upCounter)\n                };\n                counters.push(uc);\n                upCounter.reset();\n            }\n\n            if (recorders.length > 0 || counters.length > 0) {\n                const metrics: Metrics = {\n                    upCounters: counters,\n                    valueRecorders: recorders\n                };\n                this._observability.logMetrics(metrics);\n            }\n        }\n    }\n\n    private _getMetricTags<T>(metric: Metric<T>): MetricTag[] {\n        const metricsTags: MetricsTags = metric.getTags();\n\n        if (metricsTags) {\n            return Object.entries(metricsTags).map((entry) => {\n                const mt: MetricTag = {\n                    name: entry[0],\n                    value: entry[1].toString()\n                };\n                return mt;\n            });\n        }\n        return [];\n    }\n}\n"],"names":["core_envelope","namespace","name","pbjsSchema","nested","sf","instrumentation","MessageBundle","fields","messages","options","rule","id","type","schemaName","Metrics","valueRecorders","upCounters","CoreEnvelopeDiagnostics","schemaVersion","generatedTimestamp","bundleCount","upCounterCount","valueRecorderCount","key","LogMessage","appPayload","data","rootId","pagePayload","loggerAppName","loggerName","connectionType","age","seq","timestamp","CoreEnvelope","(meta.msg.desc)","diagnostics","bundles","metrics","staticAttributes","MetricTag","value","ValueRecorder","lastUpdatedTimestamp","ownerName","ownerAppName","createdTimestamp","values","tags","StaticAttributes","appVersion","appName","deviceModel","sdkVersion","deviceId","appExperience","Payload","payload","UpCounter","__protobufjs","UploadMode","version","coreEnvelopeKey","CoreEnvelopeBuilder","[object Object]","this","_envelope","undefined","logs","msgBundle","find","bundle","log","push","length","metric","getTags","Object","entries","map","entry","toString","reset","getName","getCreatedOn","getLastUpdatedOn","getData","getOwnerName","getOwnerAppName","_getMetricTags","upCounter","valueRecorder","utility","time","tsNow","metricsCollectionMilliseconds","HybridCollector","__nimbus","Error","plugins","observability","_observability","setInterval","_collectMetrics","schema","logMeta","schemaUtil","isInternal","userPayload","protobufUtil","encodePayload","logMessage","getLogMessage","logMetaObs","sequence","getSchemaId","metricsExtractors","_metricsExtractors","activityStarted","activityEnded","requireArgument","addRootActivityListeners","idleDetected","getAllUpCounters","getAllValueRecorders","recorders","counters","vr","uc","logMetrics","metricsTags"],"mappings":"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"}