{"version":3,"file":"shared.js","sources":["../../../../src/shared/LazyMapToList.ts","../../../../src/shared/Utility.ts","../../../../src/shared/SchemaUtil.ts"],"sourcesContent":["export class LazyMapToList<Key, ElementType> {\n    private readonly _lazyMap = new Map<Key, Array<ElementType>>();\n\n    private _maxSize: number;\n    constructor(maxSize?: number) {\n        if (maxSize !== undefined) {\n            if (typeof maxSize === 'number' && maxSize > 0) {\n                this._maxSize = Math.ceil(maxSize);\n                return;\n            }\n            throw new Error('maxSize must be a positive number');\n        }\n    }\n\n    get maxSize(): number {\n        return this._maxSize;\n    }\n\n    get size(): number {\n        return this._lazyMap.size;\n    }\n\n    /**\n     * Adds the value to the list specific to the key. If the list doesn't exist,\n     * it will be lazily created as long as there are fewer keys than the max, if specified.\n     *\n     * @param key The key for the map\n     * @param value The value to be added to the list\n     */\n    push(key: Key, value: ElementType): boolean {\n        let buffer = this._lazyMap.get(key);\n        if (!buffer) {\n            if (this.maxSize !== undefined && this.size === this.maxSize) {\n                return false;\n            }\n            buffer = new Array<ElementType>();\n            this._lazyMap.set(key, buffer);\n        }\n        buffer.push(value);\n        return true;\n    }\n\n    getMessages(key: Key, extract?: boolean): Array<ElementType> {\n        const msgs = this._lazyMap.get(key);\n        if (extract && this._lazyMap.has(key)) {\n            this._lazyMap.set(key, []);\n        }\n        return msgs || [];\n    }\n\n    getAllMessages(extract?: boolean): Map<Key, Array<ElementType>> {\n        const map = new Map<Key, Array<ElementType>>();\n        for (const [key, value] of this._lazyMap.entries()) {\n            if (value.length) {\n                map.set(key, this.getMessages(key, extract));\n            }\n        }\n        return map;\n    }\n\n    // Convenience functions for backwards compatibility\n    extractMessages(key: Key): Array<ElementType> {\n        return this.getMessages(key, true);\n    }\n    extractAllMessages(): Map<Key, Array<ElementType>> {\n        return this.getAllMessages(true);\n    }\n\n    get totalItemCount(): number {\n        let count = 0;\n        for (const array of this._lazyMap.values()) {\n            count += array.length;\n        }\n        return count;\n    }\n}\n","import { ObjectType } from './TypeDefinitions';\n\nclass Utility {\n    private static _isProduction = false;\n    public readonly notImplemented = 'Method not implemented.';\n    public readonly perfNow: () => number;\n    public readonly time: () => { tsNow: number; perfNow: number };\n    private readonly _timeOrigin: number;\n\n    constructor() {\n        const performanceExists = typeof performance !== 'undefined';\n        if (performanceExists) {\n            if (performance.timeOrigin) {\n                this._timeOrigin = performance.timeOrigin;\n            } else if (performance.timing && performance.timing.navigationStart) {\n                this._timeOrigin = performance.timing.navigationStart;\n            } else {\n                // if we don't have any start time, we consider our init to be the time origin\n                this._timeOrigin = Date.now();\n            }\n        } else {\n            this._timeOrigin = Date.now();\n        }\n\n        const timeOrigin = this._timeOrigin;\n        if (performanceExists && typeof performance.now === 'function') {\n            this.perfNow = performance.now.bind(performance);\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: timeOrigin + perfNow, perfNow };\n            };\n        } else {\n            this.perfNow = () => {\n                return Date.now() - timeOrigin;\n            };\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: Date.now(), perfNow };\n            };\n        }\n    }\n\n    public get isProduction(): boolean {\n        return Utility._isProduction;\n    }\n\n    public markProduction(): void {\n        // Don't allow production to be set to false once set\n        Utility._isProduction = true;\n    }\n\n    // Returns false if check fails\n    // if argKind is a string, uses typeof.\n    // if argKind is a function, such as String, Number, HTMLElement, uses instanceof.\n    // if argKind is an array, expects at least one of the element types to match.\n    private checkArgument<T>(argument: T, argKind: unknown): boolean {\n        if (typeof argKind === 'string') {\n            return typeof argument === argKind;\n        }\n        if (typeof argKind === 'function') {\n            return argument instanceof argKind;\n        }\n        if (Array.isArray(argKind)) {\n            return argKind.some((arg) => this.checkArgument(argument, arg));\n        }\n        throw new Error(`Invalid argKind ${argKind}`);\n    }\n\n    public requireArgument<T>(argument: T, argumentName: string, argKind?: unknown): void {\n        let disallowed =\n            argument === undefined || argument === null || (argument as unknown) === '';\n        const kindSpecified = argKind !== undefined;\n\n        if (!disallowed && kindSpecified) {\n            disallowed = !this.checkArgument(argument, argKind);\n        }\n\n        if (disallowed) {\n            throw new Error(\n                `${argumentName} argument is required${\n                    kindSpecified ? ' and must be of a supported type.' : '.'\n                }`\n            );\n        }\n    }\n\n    public requireArgumentIfDefined<T>(\n        argument: T,\n        argumentName: string,\n        argKind: unknown\n    ): boolean {\n        if (argument === undefined) {\n            return false;\n        }\n        const disallowed =\n            argument === null ||\n            (argument as unknown) === '' ||\n            !this.checkArgument(argument, argKind);\n\n        if (disallowed) {\n            throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);\n        }\n\n        return true;\n    }\n\n    public checkForDenyListedValues<T>(\n        argument: T,\n        argumentName: string,\n        denyList: ReadonlyArray<T>\n    ): void {\n        if (denyList.some((x) => argument === x)) {\n            throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);\n        }\n    }\n\n    public checkForReservedCharacters(\n        argument: string,\n        argumentName: string,\n        reservedChars: ReadonlyArray<string>\n    ): void {\n        if (argument && reservedChars.some((c) => argument.indexOf(c) >= 0)) {\n            throw new Error(\n                `The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(\n                    ', '\n                )}']. Received: ${argument}.`\n            );\n        }\n    }\n\n    public generateUniqueId(length = 16): string {\n        const chars: string[] = [];\n        const digits = '0123456789abcdef';\n        if (!(length === undefined || length > 0)) {\n            throw new Error('If specified, the argument \"length\" must be a positive integer');\n        }\n        for (let i = 0; i < length; i++) {\n            const rand = Math.floor(Math.random() * 16);\n            chars.push(digits[rand]);\n        }\n        return chars.join('');\n    }\n\n    public getXpath(_element: HTMLElement): string {\n        //if the element has siblings with the same type we should return 1, otherwise not\n        function hasSameSibs(elm: Element): boolean {\n            const name = elm.localName;\n            while (elm.nextElementSibling) {\n                elm = elm.nextElementSibling;\n                if (elm.localName === name) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function idx(sib: Element, name?: string): number {\n            //we want to count the siblings of the same type for the xpath, otherwise it is just 1\n            if (sib) {\n                return (\n                    idx(sib.previousElementSibling, name || sib.localName) +\n                    (sib.localName === name ? 1 : 0)\n                );\n            }\n            return 1;\n        }\n        function segs(elm: HTMLElement): string[] {\n            // only run for element nodes\n            if (!elm || elm.nodeType !== 1) {\n                return [''];\n            }\n            //only add the number if it is over 1, or if it the first of siblings\n            const nodeValue =\n                idx(elm) > 1 || hasSameSibs(elm)\n                    ? `${elm.localName.toLowerCase()}[${idx(elm)}]`\n                    : elm.localName.toLowerCase();\n            //go up and add the element at the end of the path\n            return [...segs(elm.parentNode as HTMLElement), nodeValue];\n        }\n        //concat at the end\n        return segs(_element).join('/');\n    }\n\n    public getAge(timestamp: number): number {\n        return timestamp - this._timeOrigin;\n    }\n\n    public getConnectionType(): string {\n        let connectionType;\n        if (typeof navigator !== 'undefined') {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection\n            interface NavigatorExperimental extends Navigator {\n                connection: {\n                    effectiveType: string;\n                };\n            }\n            const expNav = navigator as unknown as NavigatorExperimental;\n            connectionType = expNav && expNav.connection && expNav.connection.effectiveType;\n        }\n        return connectionType;\n    }\n\n    public clone<T>(value: T): T {\n        return JSON.parse(JSON.stringify(value));\n    }\n\n    public definedValueOrDefault<T>(value: T, defaultValue: T): T {\n        return value !== undefined ? value : defaultValue;\n    }\n\n    public getGlobal(): typeof globalThis {\n        if (typeof globalThis === 'object') {\n            return globalThis;\n        }\n        if (typeof self === 'object') {\n            return self;\n        }\n        throw new Error('Unable to locate globalThis or self');\n    }\n\n    public getIsBeaconSupported(): boolean {\n        const a =\n            typeof navigator !== undefined &&\n            typeof navigator.sendBeacon === 'function' &&\n            typeof Blob !== undefined;\n        return a;\n    }\n\n    public estimateObjectSize(object: unknown): number {\n        const objectSet = new Set<ObjectType>();\n        const stack: Array<unknown> = [object];\n        let bytes = 0;\n\n        while (stack.length) {\n            const value: unknown = stack.pop();\n            if (typeof value === 'boolean') {\n                bytes += 4;\n            } else if (typeof value === 'string') {\n                bytes += value.length * 2;\n            } else if (typeof value === 'number') {\n                bytes += 8;\n            } else if (\n                value instanceof Uint8Array ||\n                value instanceof Uint8ClampedArray ||\n                value instanceof Uint16Array ||\n                value instanceof Uint32Array ||\n                value instanceof Int8Array ||\n                value instanceof Int16Array ||\n                value instanceof Int32Array ||\n                value instanceof Float32Array ||\n                value instanceof Float64Array\n            ) {\n                bytes += value.byteLength;\n            } else if (typeof value === 'object') {\n                const obj: ObjectType = value as ObjectType;\n                if (!objectSet.has(obj)) {\n                    objectSet.add(obj);\n                    for (const key in obj) {\n                        stack.push(obj[key]);\n                    }\n                }\n            }\n        }\n        return bytes;\n    }\n}\n\nexport const utility = Object.freeze(new Utility());\n","import { IField, INamespace, IType, Schema, SchematizedPayload, SchemaTokens } from '../interfaces';\nimport {\n    AnyNestedObject,\n    PbjsNestedObjectDescriptor,\n    ProtoOptions,\n    SchematizedData\n} from './TypeDefinitions';\nimport { utility } from './Utility';\n\nclass SchemaUtil {\n    public getSchemaId(schema: Schema): string {\n        return `${schema.namespace}.${schema.name}`;\n    }\n    public isInternal(schema: Schema): boolean {\n        return schema && schema.namespace === 'sf.instrumentation';\n    }\n\n    public makePayload(\n        schema: Schema,\n        data: SchematizedData,\n        onlyIfBoth = true\n    ): SchematizedPayload {\n        if (!onlyIfBoth || (schema !== undefined && data !== undefined)) {\n            return {\n                schema,\n                payload: data\n            };\n        }\n        return undefined;\n    }\n\n    public checkSchema(schema: Schema): SchemaTokens {\n        utility.requireArgument(schema, 'schema', 'object');\n        utility.requireArgument(schema.namespace, 'schema.namespace', 'string');\n        utility.requireArgument(schema.name, 'schema.name', 'string');\n        utility.requireArgument(schema.pbjsSchema, 'schema.pbjsSchema', 'object');\n        const parts: string[] = schema.namespace.split('.');\n        if (parts.length !== 2) {\n            throw new Error(\n                `Schema \"${this.getSchemaId(\n                    schema\n                )}\" must have a namespace of the form \"domain.feature\".`\n            );\n        }\n        return {\n            domain: parts[0],\n            feature: parts[1],\n            message: schema.name\n        };\n    }\n\n    private getAnyNestedObject(schema: Schema, scopes: string[]): AnyNestedObject {\n        return scopes.reduce((prev: INamespace, currentScope: string) => {\n            const descriptor: PbjsNestedObjectDescriptor = prev.nested;\n            if (descriptor) {\n                const ano: AnyNestedObject = descriptor[currentScope];\n                if (ano) {\n                    return ano;\n                }\n            }\n            throw new Error(\n                `Cannot locate ${scopes.join('.')} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }, schema.pbjsSchema);\n    }\n\n    public getTypes(schema: Schema): PbjsNestedObjectDescriptor {\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n        const namespace: INamespace = this.getAnyNestedObject(schema, [\n            schemaTokens.domain,\n            schemaTokens.feature\n        ]);\n        const descriptor: PbjsNestedObjectDescriptor = namespace.nested;\n        if (!descriptor) {\n            throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);\n        }\n        return descriptor;\n    }\n\n    public getType(schema: Schema, messageName: string): IType {\n        utility.requireArgument(messageName, 'messageName', 'string');\n        const descriptor: PbjsNestedObjectDescriptor = this.getTypes(schema);\n\n        const message = descriptor[messageName] as IType;\n        if (!message) {\n            throw new Error(\n                `Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }\n        return message;\n    }\n\n    public getOptions(schema: Schema, messageName?: string, fieldName?: string): ProtoOptions {\n        if (fieldName) {\n            utility.requireArgument(messageName, 'messageName', 'string');\n        }\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n\n        if (!messageName) {\n            const namespace: INamespace = this.getAnyNestedObject(schema, [\n                schemaTokens.domain,\n                schemaTokens.feature\n            ]);\n            return namespace.options;\n        }\n\n        const type: IType = this.getType(schema, messageName);\n        if (!fieldName) {\n            return type.options;\n        }\n\n        const field: IField = type.fields[fieldName];\n        if (!field) {\n            const schemaId = this.getSchemaId(schema);\n            throw new Error(\n                `Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`\n            );\n        }\n        return field.options;\n    }\n}\n\nexport const schemaUtil = new SchemaUtil();\n"],"names":["LazyMapToList","[object Object]","maxSize","this","Map","undefined","_maxSize","Math","ceil","Error","size","_lazyMap","key","value","buffer","get","Array","set","push","extract","msgs","has","map","entries","length","getMessages","getAllMessages","totalItemCount","count","array","values","Utility","performanceExists","performance","timeOrigin","_timeOrigin","timing","navigationStart","Date","now","perfNow","bind","time","tsNow","isProduction","_isProduction","argument","argKind","isArray","some","arg","checkArgument","argumentName","disallowed","kindSpecified","denyList","x","reservedChars","c","indexOf","join","chars","i","rand","floor","random","_element","idx","sib","name","previousElementSibling","localName","segs","elm","nodeType","nodeValue","nextElementSibling","hasSameSibs","toLowerCase","parentNode","timestamp","connectionType","navigator","expNav","connection","effectiveType","JSON","parse","stringify","defaultValue","globalThis","self","sendBeacon","Blob","object","objectSet","Set","stack","bytes","pop","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","byteLength","obj","add","utility","Object","freeze","schemaUtil","schema","namespace","data","onlyIfBoth","payload","requireArgument","pbjsSchema","parts","split","getSchemaId","domain","feature","message","scopes","reduce","prev","currentScope","descriptor","nested","ano","schemaTokens","checkSchema","getAnyNestedObject","messageName","getTypes","fieldName","options","type","getType","field","fields","schemaId"],"mappings":"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"}